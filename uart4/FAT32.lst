   1               		.file	"FAT32.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	getFirstSector
  12               	getFirstSector:
  13               	.LFB2:
  14               		.file 1 "FAT32.c"
   1:FAT32.c       **** //*******************************************************
   2:FAT32.c       **** // **** ROUTINES FOR FAT32 IMPLEMATATION OF SD CARD ****
   3:FAT32.c       **** //**********************************************************
   4:FAT32.c       **** //Controller: ATmega32 (Clock: 8 Mhz-internal)
   5:FAT32.c       **** //Compiler	: AVR-GCC (winAVR with AVRStudio)
   6:FAT32.c       **** //Project V.: Version - 2.4.1
   7:FAT32.c       **** //Author	: CC Dharmani, Chennai (India)
   8:FAT32.c       **** //			  www.dharmanitech.com
   9:FAT32.c       **** //Date		: 24 Apr 2011
  10:FAT32.c       **** //********************************************************
  11:FAT32.c       **** 
  12:FAT32.c       **** //Link to the Post: http://www.dharmanitech.com/2009/01/sd-card-interfacing-with-atmega8-fat32.html
  13:FAT32.c       **** 
  14:FAT32.c       **** #include <avr/io.h>
  15:FAT32.c       **** #include <avr/pgmspace.h>
  16:FAT32.c       **** #include "FAT32.h"
  17:FAT32.c       **** #include "UART_routines.h"
  18:FAT32.c       **** #include "SD_routines.h"
  19:FAT32.c       **** #include "RTC_routines.h"
  20:FAT32.c       **** 
  21:FAT32.c       **** //***************************************************************************
  22:FAT32.c       **** //Function: to read data from boot sector of SD card, to determine important
  23:FAT32.c       **** //parameters like bytesPerSector, sectorsPerCluster etc.
  24:FAT32.c       **** //Arguments: none
  25:FAT32.c       **** //return: none
  26:FAT32.c       **** //***************************************************************************
  27:FAT32.c       **** unsigned char getBootSectorData (void)
  28:FAT32.c       **** {
  29:FAT32.c       **** struct BS_Structure *bpb; //mapping the buffer onto the structure
  30:FAT32.c       **** struct MBRinfo_Structure *mbr;
  31:FAT32.c       **** struct partitionInfo_Structure *partition;
  32:FAT32.c       **** unsigned long dataSectors;
  33:FAT32.c       **** 
  34:FAT32.c       **** unusedSectors = 0;
  35:FAT32.c       **** 
  36:FAT32.c       **** SD_readSingleBlock(0);
  37:FAT32.c       **** bpb = (struct BS_Structure *)buffer;
  38:FAT32.c       **** 
  39:FAT32.c       **** if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
  40:FAT32.c       **** {
  41:FAT32.c       ****   mbr = (struct MBRinfo_Structure *) buffer;       //if it is not boot sector, it must be MBR
  42:FAT32.c       ****   
  43:FAT32.c       ****   if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
  44:FAT32.c       ****   	
  45:FAT32.c       ****   partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  46:FAT32.c       ****   unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
  47:FAT32.c       ****   
  48:FAT32.c       ****   SD_readSingleBlock(partition->firstSector);//read the bpb sector
  49:FAT32.c       ****   bpb = (struct BS_Structure *)buffer;
  50:FAT32.c       ****   if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
  51:FAT32.c       **** }
  52:FAT32.c       **** 
  53:FAT32.c       **** bytesPerSector = bpb->bytesPerSector;
  54:FAT32.c       **** //transmitHex(INT, bytesPerSector); transmitByte(' ');
  55:FAT32.c       **** sectorPerCluster = bpb->sectorPerCluster;
  56:FAT32.c       **** //transmitHex(INT, sectorPerCluster); transmitByte(' ');
  57:FAT32.c       **** reservedSectorCount = bpb->reservedSectorCount;
  58:FAT32.c       **** rootCluster = bpb->rootCluster;// + (sector / sectorPerCluster) +1;
  59:FAT32.c       **** firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32)
  60:FAT32.c       **** 
  61:FAT32.c       **** dataSectors = bpb->totalSectors_F32
  62:FAT32.c       ****               - bpb->reservedSectorCount
  63:FAT32.c       ****               - ( bpb->numberofFATs * bpb->FATsize_F32);
  64:FAT32.c       **** totalClusters = dataSectors / sectorPerCluster;
  65:FAT32.c       **** //transmitHex(LONG, totalClusters); transmitByte(' ');
  66:FAT32.c       **** 
  67:FAT32.c       **** if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count
  68:FAT32.c       ****      freeClusterCountUpdated = 0;
  69:FAT32.c       **** else
  70:FAT32.c       **** 	 freeClusterCountUpdated = 1;
  71:FAT32.c       **** return 0;
  72:FAT32.c       **** }
  73:FAT32.c       **** 
  74:FAT32.c       **** //***************************************************************************
  75:FAT32.c       **** //Function: to calculate first sector address of any given cluster
  76:FAT32.c       **** //Arguments: cluster number for which first sector is to be found
  77:FAT32.c       **** //return: first sector address
  78:FAT32.c       **** //***************************************************************************
  79:FAT32.c       **** unsigned long getFirstSector(unsigned long clusterNumber)
  80:FAT32.c       **** {
  15               		.loc 1 80 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 CF92      		push r12
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 12, -2
  22 0002 DF92      		push r13
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 13, -3
  26 0004 EF92      		push r14
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 14, -4
  30 0006 FF92      		push r15
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 15, -5
  34               	/* prologue: function */
  35               	/* frame size = 0 */
  36               	/* stack size = 4 */
  37               	.L__stack_usage = 4
  38 0008 9B01      		movw r18,r22
  39 000a AC01      		movw r20,r24
  81:FAT32.c       ****   return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
  40               		.loc 1 81 0
  41 000c A091 0000 		lds r26,sectorPerCluster
  42 0010 B091 0000 		lds r27,sectorPerCluster+1
  43 0014 C090 0000 		lds r12,firstDataSector
  44 0018 D090 0000 		lds r13,firstDataSector+1
  45 001c E090 0000 		lds r14,firstDataSector+2
  46 0020 F090 0000 		lds r15,firstDataSector+3
  47 0024 2250      		subi r18,2
  48 0026 3109      		sbc r19,__zero_reg__
  49 0028 4109      		sbc r20,__zero_reg__
  50 002a 5109      		sbc r21,__zero_reg__
  51 002c 0E94 0000 		call __muluhisi3
  52               	.LVL1:
  53 0030 6C0D      		add r22,r12
  54 0032 7D1D      		adc r23,r13
  55 0034 8E1D      		adc r24,r14
  56 0036 9F1D      		adc r25,r15
  57               	/* epilogue start */
  82:FAT32.c       **** }
  58               		.loc 1 82 0
  59 0038 FF90      		pop r15
  60 003a EF90      		pop r14
  61 003c DF90      		pop r13
  62 003e CF90      		pop r12
  63 0040 0895      		ret
  64               		.cfi_endproc
  65               	.LFE2:
  67               	.global	getSetNextCluster
  69               	getSetNextCluster:
  70               	.LFB3:
  83:FAT32.c       **** 
  84:FAT32.c       **** //***************************************************************************
  85:FAT32.c       **** //Function: get cluster entry value from FAT to find out the next cluster in the chain
  86:FAT32.c       **** //or set new cluster entry in FAT
  87:FAT32.c       **** //Arguments: 1. current cluster number, 2. get_set (=GET, if next cluster is to be found or = SET,
  88:FAT32.c       **** //if next cluster is to be set 3. next cluster number, if argument#2 = SET, else 0
  89:FAT32.c       **** //return: next cluster number, if if argument#2 = GET, else 0
  90:FAT32.c       **** //****************************************************************************
  91:FAT32.c       **** unsigned long getSetNextCluster (unsigned long clusterNumber,
  92:FAT32.c       ****                                  unsigned char get_set,
  93:FAT32.c       ****                                  unsigned long clusterEntry)
  94:FAT32.c       **** {
  71               		.loc 1 94 0
  72               		.cfi_startproc
  73               	.LVL2:
  74 0042 4F92      		push r4
  75               	.LCFI4:
  76               		.cfi_def_cfa_offset 3
  77               		.cfi_offset 4, -2
  78 0044 5F92      		push r5
  79               	.LCFI5:
  80               		.cfi_def_cfa_offset 4
  81               		.cfi_offset 5, -3
  82 0046 6F92      		push r6
  83               	.LCFI6:
  84               		.cfi_def_cfa_offset 5
  85               		.cfi_offset 6, -4
  86 0048 7F92      		push r7
  87               	.LCFI7:
  88               		.cfi_def_cfa_offset 6
  89               		.cfi_offset 7, -5
  90 004a 8F92      		push r8
  91               	.LCFI8:
  92               		.cfi_def_cfa_offset 7
  93               		.cfi_offset 8, -6
  94 004c 9F92      		push r9
  95               	.LCFI9:
  96               		.cfi_def_cfa_offset 8
  97               		.cfi_offset 9, -7
  98 004e AF92      		push r10
  99               	.LCFI10:
 100               		.cfi_def_cfa_offset 9
 101               		.cfi_offset 10, -8
 102 0050 BF92      		push r11
 103               	.LCFI11:
 104               		.cfi_def_cfa_offset 10
 105               		.cfi_offset 11, -9
 106 0052 CF92      		push r12
 107               	.LCFI12:
 108               		.cfi_def_cfa_offset 11
 109               		.cfi_offset 12, -10
 110 0054 DF92      		push r13
 111               	.LCFI13:
 112               		.cfi_def_cfa_offset 12
 113               		.cfi_offset 13, -11
 114 0056 EF92      		push r14
 115               	.LCFI14:
 116               		.cfi_def_cfa_offset 13
 117               		.cfi_offset 14, -12
 118 0058 FF92      		push r15
 119               	.LCFI15:
 120               		.cfi_def_cfa_offset 14
 121               		.cfi_offset 15, -13
 122 005a 0F93      		push r16
 123               	.LCFI16:
 124               		.cfi_def_cfa_offset 15
 125               		.cfi_offset 16, -14
 126 005c 1F93      		push r17
 127               	.LCFI17:
 128               		.cfi_def_cfa_offset 16
 129               		.cfi_offset 17, -15
 130 005e CF93      		push r28
 131               	.LCFI18:
 132               		.cfi_def_cfa_offset 17
 133               		.cfi_offset 28, -16
 134 0060 DF93      		push r29
 135               	.LCFI19:
 136               		.cfi_def_cfa_offset 18
 137               		.cfi_offset 29, -17
 138               	/* prologue: function */
 139               	/* frame size = 0 */
 140               	/* stack size = 16 */
 141               	.L__stack_usage = 16
 142 0062 4B01      		movw r8,r22
 143 0064 5C01      		movw r10,r24
 144 0066 C42F      		mov r28,r20
 145 0068 2801      		movw r4,r16
 146 006a 3901      		movw r6,r18
 147               	.LVL3:
  95:FAT32.c       **** unsigned int FATEntryOffset;
  96:FAT32.c       **** unsigned long *FATEntryValue;
  97:FAT32.c       **** unsigned long FATEntrySector;
  98:FAT32.c       **** unsigned char retry = 0;
  99:FAT32.c       **** 
 100:FAT32.c       **** //get sector number of the cluster entry in the FAT
 101:FAT32.c       **** FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
 148               		.loc 1 101 0
 149 006c 8091 0000 		lds r24,reservedSectorCount
 150 0070 9091 0000 		lds r25,reservedSectorCount+1
 151 0074 22E0      		ldi r18,2
 152               		1:
 153 0076 880C      		lsl r8
 154 0078 991C      		rol r9
 155 007a AA1C      		rol r10
 156 007c BB1C      		rol r11
 157 007e 2A95      		dec r18
 158 0080 01F4      		brne 1b
 159 0082 2091 0000 		lds r18,bytesPerSector
 160 0086 3091 0000 		lds r19,bytesPerSector+1
 161 008a C090 0000 		lds r12,unusedSectors
 162 008e D090 0000 		lds r13,unusedSectors+1
 163 0092 E090 0000 		lds r14,unusedSectors+2
 164 0096 F090 0000 		lds r15,unusedSectors+3
 165 009a C80E      		add r12,r24
 166 009c D91E      		adc r13,r25
 167 009e E11C      		adc r14,__zero_reg__
 168 00a0 F11C      		adc r15,__zero_reg__
 169 00a2 40E0      		ldi r20,0
 170 00a4 50E0      		ldi r21,0
 171               	.LVL4:
 172 00a6 C501      		movw r24,r10
 173 00a8 B401      		movw r22,r8
 174               	.LVL5:
 175 00aa 0E94 0000 		call __udivmodsi4
 176 00ae C20E      		add r12,r18
 177 00b0 D31E      		adc r13,r19
 178 00b2 E41E      		adc r14,r20
 179 00b4 F51E      		adc r15,r21
 180               	.LVL6:
 102:FAT32.c       **** 
 103:FAT32.c       **** //get the offset address in that sector number
 104:FAT32.c       **** FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
 181               		.loc 1 104 0
 182 00b6 2091 0000 		lds r18,bytesPerSector
 183 00ba 3091 0000 		lds r19,bytesPerSector+1
 184 00be 40E0      		ldi r20,0
 185 00c0 50E0      		ldi r21,0
 186 00c2 C501      		movw r24,r10
 187 00c4 B401      		movw r22,r8
 188 00c6 0E94 0000 		call __udivmodsi4
 189 00ca 4B01      		movw r8,r22
 190 00cc 5C01      		movw r10,r24
 191               	.LVL7:
 192 00ce DAE0      		ldi r29,lo8(10)
 193               	.LVL8:
 194               	.L4:
 105:FAT32.c       **** 
 106:FAT32.c       **** //read the sector into a buffer
 107:FAT32.c       **** while(retry <10)
 108:FAT32.c       **** { if(!SD_readSingleBlock(FATEntrySector)) break; retry++;}
 195               		.loc 1 108 0
 196 00d0 C701      		movw r24,r14
 197 00d2 B601      		movw r22,r12
 198 00d4 0E94 0000 		call SD_readSingleBlock
 199               	.LVL9:
 200 00d8 8823      		tst r24
 201 00da 01F0      		breq .L3
 202               	.LVL10:
 203 00dc D150      		subi r29,lo8(-(-1))
 204               	.LVL11:
 107:FAT32.c       **** while(retry <10)
 205               		.loc 1 107 0 discriminator 1
 206 00de 01F4      		brne .L4
 207               	.LVL12:
 208               	.L3:
 109:FAT32.c       **** 
 110:FAT32.c       **** //get the cluster address from the buffer
 111:FAT32.c       **** FATEntryValue = (unsigned long *) &buffer[FATEntryOffset];
 209               		.loc 1 111 0
 210 00e0 F401      		movw r30,r8
 211 00e2 E050      		subi r30,lo8(-(buffer))
 212 00e4 F040      		sbci r31,hi8(-(buffer))
 213               	.LVL13:
 112:FAT32.c       **** 
 113:FAT32.c       **** if(get_set == GET)
 214               		.loc 1 113 0
 215 00e6 C111      		cpse r28,__zero_reg__
 216 00e8 00C0      		rjmp .L5
 114:FAT32.c       ****   return ((*FATEntryValue) & 0x0fffffff);
 217               		.loc 1 114 0
 218 00ea 6081      		ld r22,Z
 219 00ec 7181      		ldd r23,Z+1
 220 00ee 8281      		ldd r24,Z+2
 221 00f0 9381      		ldd r25,Z+3
 222 00f2 9F70      		andi r25,15
 223 00f4 00C0      		rjmp .L6
 224               	.L5:
 115:FAT32.c       **** 
 116:FAT32.c       **** 
 117:FAT32.c       **** *FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
 225               		.loc 1 117 0
 226 00f6 4082      		st Z,r4
 227 00f8 5182      		std Z+1,r5
 228 00fa 6282      		std Z+2,r6
 229 00fc 7382      		std Z+3,r7
 118:FAT32.c       **** 
 119:FAT32.c       **** SD_writeSingleBlock(FATEntrySector);
 230               		.loc 1 119 0
 231 00fe C701      		movw r24,r14
 232 0100 B601      		movw r22,r12
 233 0102 0E94 0000 		call SD_writeSingleBlock
 234               	.LVL14:
 120:FAT32.c       **** 
 121:FAT32.c       **** return (0);
 235               		.loc 1 121 0
 236 0106 60E0      		ldi r22,0
 237 0108 70E0      		ldi r23,0
 238 010a CB01      		movw r24,r22
 239               	.LVL15:
 240               	.L6:
 241               	/* epilogue start */
 122:FAT32.c       **** }
 242               		.loc 1 122 0
 243 010c DF91      		pop r29
 244 010e CF91      		pop r28
 245               	.LVL16:
 246 0110 1F91      		pop r17
 247 0112 0F91      		pop r16
 248 0114 FF90      		pop r15
 249 0116 EF90      		pop r14
 250 0118 DF90      		pop r13
 251 011a CF90      		pop r12
 252               	.LVL17:
 253 011c BF90      		pop r11
 254 011e AF90      		pop r10
 255 0120 9F90      		pop r9
 256 0122 8F90      		pop r8
 257               	.LVL18:
 258 0124 7F90      		pop r7
 259 0126 6F90      		pop r6
 260 0128 5F90      		pop r5
 261 012a 4F90      		pop r4
 262               	.LVL19:
 263 012c 0895      		ret
 264               		.cfi_endproc
 265               	.LFE3:
 267               	.global	getSetFreeCluster
 269               	getSetFreeCluster:
 270               	.LFB4:
 123:FAT32.c       **** 
 124:FAT32.c       **** //********************************************************************************************
 125:FAT32.c       **** //Function: to get or set next free cluster or total free clusters in FSinfo sector of SD card
 126:FAT32.c       **** //Arguments: 1.flag:TOTAL_FREE or NEXT_FREE, 
 127:FAT32.c       **** //			 2.flag: GET or SET 
 128:FAT32.c       **** //			 3.new FS entry, when argument2 is SET; or 0, when argument2 is GET
 129:FAT32.c       **** //return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
 130:FAT32.c       **** //        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
 131:FAT32.c       **** //		  0xffffffff, if any error or if arg2 is SET
 132:FAT32.c       **** //********************************************************************************************
 133:FAT32.c       **** unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEnt
 134:FAT32.c       **** {
 271               		.loc 1 134 0
 272               		.cfi_startproc
 273               	.LVL20:
 274 012e CF92      		push r12
 275               	.LCFI20:
 276               		.cfi_def_cfa_offset 3
 277               		.cfi_offset 12, -2
 278 0130 DF92      		push r13
 279               	.LCFI21:
 280               		.cfi_def_cfa_offset 4
 281               		.cfi_offset 13, -3
 282 0132 EF92      		push r14
 283               	.LCFI22:
 284               		.cfi_def_cfa_offset 5
 285               		.cfi_offset 14, -4
 286 0134 FF92      		push r15
 287               	.LCFI23:
 288               		.cfi_def_cfa_offset 6
 289               		.cfi_offset 15, -5
 290 0136 0F93      		push r16
 291               	.LCFI24:
 292               		.cfi_def_cfa_offset 7
 293               		.cfi_offset 16, -6
 294 0138 1F93      		push r17
 295               	.LCFI25:
 296               		.cfi_def_cfa_offset 8
 297               		.cfi_offset 17, -7
 298 013a CF93      		push r28
 299               	.LCFI26:
 300               		.cfi_def_cfa_offset 9
 301               		.cfi_offset 28, -8
 302 013c DF93      		push r29
 303               	.LCFI27:
 304               		.cfi_def_cfa_offset 10
 305               		.cfi_offset 29, -9
 306 013e 00D0      		rcall .
 307 0140 00D0      		rcall .
 308               	.LCFI28:
 309               		.cfi_def_cfa_offset 14
 310 0142 CDB7      		in r28,__SP_L__
 311 0144 DEB7      		in r29,__SP_H__
 312               	.LCFI29:
 313               		.cfi_def_cfa_register 28
 314               	/* prologue: function */
 315               	/* frame size = 4 */
 316               	/* stack size = 12 */
 317               	.L__stack_usage = 12
 318 0146 182F      		mov r17,r24
 319 0148 062F      		mov r16,r22
 320               	.LVL21:
 135:FAT32.c       **** struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &buffer;
 136:FAT32.c       **** unsigned char error;
 137:FAT32.c       **** 
 138:FAT32.c       **** SD_readSingleBlock(unusedSectors + 1);
 321               		.loc 1 138 0
 322 014a 6091 0000 		lds r22,unusedSectors
 323 014e 7091 0000 		lds r23,unusedSectors+1
 324 0152 8091 0000 		lds r24,unusedSectors+2
 325 0156 9091 0000 		lds r25,unusedSectors+3
 326               	.LVL22:
 327 015a 6F5F      		subi r22,-1
 328 015c 7F4F      		sbci r23,-1
 329 015e 8F4F      		sbci r24,-1
 330 0160 9F4F      		sbci r25,-1
 331 0162 2983      		std Y+1,r18
 332 0164 3A83      		std Y+2,r19
 333 0166 4B83      		std Y+3,r20
 334 0168 5C83      		std Y+4,r21
 335 016a 0E94 0000 		call SD_readSingleBlock
 336               	.LVL23:
 139:FAT32.c       **** 
 140:FAT32.c       **** if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignatu
 337               		.loc 1 140 0
 338 016e C090 0000 		lds r12,buffer
 339 0172 D090 0000 		lds r13,buffer+1
 340 0176 E090 0000 		lds r14,buffer+2
 341 017a F090 0000 		lds r15,buffer+3
 342 017e 2981      		ldd r18,Y+1
 343 0180 3A81      		ldd r19,Y+2
 344 0182 4B81      		ldd r20,Y+3
 345 0184 5C81      		ldd r21,Y+4
 346 0186 82E5      		ldi r24,82
 347 0188 C816      		cp r12,r24
 348 018a D806      		cpc r13,r24
 349 018c 81E6      		ldi r24,97
 350 018e E806      		cpc r14,r24
 351 0190 81E4      		ldi r24,65
 352 0192 F806      		cpc r15,r24
 353 0194 01F0      		breq .+2
 354 0196 00C0      		rjmp .L23
 355               		.loc 1 140 0 is_stmt 0 discriminator 1
 356 0198 C090 0000 		lds r12,buffer+484
 357 019c D090 0000 		lds r13,buffer+484+1
 358 01a0 E090 0000 		lds r14,buffer+484+2
 359 01a4 F090 0000 		lds r15,buffer+484+3
 360 01a8 E2E7      		ldi r30,114
 361 01aa CE16      		cp r12,r30
 362 01ac DE06      		cpc r13,r30
 363 01ae E1E4      		ldi r30,65
 364 01b0 EE06      		cpc r14,r30
 365 01b2 E1E6      		ldi r30,97
 366 01b4 FE06      		cpc r15,r30
 367 01b6 01F0      		breq .+2
 368 01b8 00C0      		rjmp .L23
 369 01ba C090 0000 		lds r12,buffer+508
 370 01be D090 0000 		lds r13,buffer+508+1
 371 01c2 E090 0000 		lds r14,buffer+508+2
 372 01c6 F090 0000 		lds r15,buffer+508+3
 373 01ca C114      		cp r12,__zero_reg__
 374 01cc D104      		cpc r13,__zero_reg__
 375 01ce F5E5      		ldi r31,85
 376 01d0 EF06      		cpc r14,r31
 377 01d2 FAEA      		ldi r31,-86
 378 01d4 FF06      		cpc r15,r31
 379 01d6 01F4      		brne .L23
 141:FAT32.c       ****   return 0xffffffff;
 142:FAT32.c       **** 
 143:FAT32.c       ****  if(get_set == GET)
 380               		.loc 1 143 0 is_stmt 1
 381 01d8 0111      		cpse r16,__zero_reg__
 382 01da 00C0      		rjmp .L16
 383               	.LVL24:
 384               	.LBB4:
 385               	.LBB5:
 144:FAT32.c       ****  {
 145:FAT32.c       ****    if(totOrNext == TOTAL_FREE)
 386               		.loc 1 145 0
 387 01dc 1130      		cpi r17,lo8(1)
 388 01de 01F4      		brne .L17
 146:FAT32.c       ****       return(FS->freeClusterCount);
 389               		.loc 1 146 0
 390 01e0 6091 0000 		lds r22,buffer+488
 391 01e4 7091 0000 		lds r23,buffer+488+1
 392 01e8 8091 0000 		lds r24,buffer+488+2
 393 01ec 9091 0000 		lds r25,buffer+488+3
 394 01f0 00C0      		rjmp .L15
 395               	.L17:
 147:FAT32.c       ****    else // when totOrNext = NEXT_FREE
 148:FAT32.c       ****       return(FS->nextFreeCluster);
 396               		.loc 1 148 0
 397 01f2 6091 0000 		lds r22,buffer+492
 398 01f6 7091 0000 		lds r23,buffer+492+1
 399 01fa 8091 0000 		lds r24,buffer+492+2
 400 01fe 9091 0000 		lds r25,buffer+492+3
 401 0202 00C0      		rjmp .L15
 402               	.LVL25:
 403               	.L16:
 404               	.LBE5:
 405               	.LBE4:
 149:FAT32.c       ****  }
 150:FAT32.c       ****  else
 151:FAT32.c       ****  {
 152:FAT32.c       ****    if(totOrNext == TOTAL_FREE)
 406               		.loc 1 152 0
 407 0204 1130      		cpi r17,lo8(1)
 408 0206 01F4      		brne .L19
 153:FAT32.c       ****       FS->freeClusterCount = FSEntry;
 409               		.loc 1 153 0
 410 0208 2093 0000 		sts buffer+488,r18
 411 020c 3093 0000 		sts buffer+488+1,r19
 412 0210 4093 0000 		sts buffer+488+2,r20
 413 0214 5093 0000 		sts buffer+488+3,r21
 414 0218 00C0      		rjmp .L20
 415               	.L19:
 154:FAT32.c       ****    else // when totOrNext = NEXT_FREE
 155:FAT32.c       **** 	  FS->nextFreeCluster = FSEntry;
 416               		.loc 1 155 0
 417 021a 2093 0000 		sts buffer+492,r18
 418 021e 3093 0000 		sts buffer+492+1,r19
 419 0222 4093 0000 		sts buffer+492+2,r20
 420 0226 5093 0000 		sts buffer+492+3,r21
 421               	.L20:
 156:FAT32.c       ****  
 157:FAT32.c       ****    error = SD_writeSingleBlock(unusedSectors + 1);	//update FSinfo
 422               		.loc 1 157 0
 423 022a 6091 0000 		lds r22,unusedSectors
 424 022e 7091 0000 		lds r23,unusedSectors+1
 425 0232 8091 0000 		lds r24,unusedSectors+2
 426 0236 9091 0000 		lds r25,unusedSectors+3
 427 023a 6F5F      		subi r22,-1
 428 023c 7F4F      		sbci r23,-1
 429 023e 8F4F      		sbci r24,-1
 430 0240 9F4F      		sbci r25,-1
 431 0242 0E94 0000 		call SD_writeSingleBlock
 432               	.LVL26:
 433               	.L23:
 141:FAT32.c       ****   return 0xffffffff;
 434               		.loc 1 141 0
 435 0246 6FEF      		ldi r22,lo8(-1)
 436 0248 7FEF      		ldi r23,lo8(-1)
 437 024a CB01      		movw r24,r22
 438               	.L15:
 439               	/* epilogue start */
 158:FAT32.c       ****  }
 159:FAT32.c       ****  return 0xffffffff;
 160:FAT32.c       **** }
 440               		.loc 1 160 0
 441 024c 0F90      		pop __tmp_reg__
 442 024e 0F90      		pop __tmp_reg__
 443 0250 0F90      		pop __tmp_reg__
 444 0252 0F90      		pop __tmp_reg__
 445 0254 DF91      		pop r29
 446 0256 CF91      		pop r28
 447 0258 1F91      		pop r17
 448               	.LVL27:
 449 025a 0F91      		pop r16
 450               	.LVL28:
 451 025c FF90      		pop r15
 452 025e EF90      		pop r14
 453 0260 DF90      		pop r13
 454 0262 CF90      		pop r12
 455 0264 0895      		ret
 456               		.cfi_endproc
 457               	.LFE4:
 459               	.global	getBootSectorData
 461               	getBootSectorData:
 462               	.LFB1:
  28:FAT32.c       **** {
 463               		.loc 1 28 0
 464               		.cfi_startproc
 465 0266 0F93      		push r16
 466               	.LCFI30:
 467               		.cfi_def_cfa_offset 3
 468               		.cfi_offset 16, -2
 469 0268 1F93      		push r17
 470               	.LCFI31:
 471               		.cfi_def_cfa_offset 4
 472               		.cfi_offset 17, -3
 473 026a CF93      		push r28
 474               	.LCFI32:
 475               		.cfi_def_cfa_offset 5
 476               		.cfi_offset 28, -4
 477 026c DF93      		push r29
 478               	.LCFI33:
 479               		.cfi_def_cfa_offset 6
 480               		.cfi_offset 29, -5
 481               	/* prologue: function */
 482               	/* frame size = 0 */
 483               	/* stack size = 4 */
 484               	.L__stack_usage = 4
  34:FAT32.c       **** unusedSectors = 0;
 485               		.loc 1 34 0
 486 026e 1092 0000 		sts unusedSectors,__zero_reg__
 487 0272 1092 0000 		sts unusedSectors+1,__zero_reg__
 488 0276 1092 0000 		sts unusedSectors+2,__zero_reg__
 489 027a 1092 0000 		sts unusedSectors+3,__zero_reg__
  36:FAT32.c       **** SD_readSingleBlock(0);
 490               		.loc 1 36 0
 491 027e 60E0      		ldi r22,0
 492 0280 70E0      		ldi r23,0
 493 0282 CB01      		movw r24,r22
 494 0284 0E94 0000 		call SD_readSingleBlock
 495               	.LVL29:
  39:FAT32.c       **** if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
 496               		.loc 1 39 0
 497 0288 8091 0000 		lds r24,buffer
 498 028c 8D7F      		andi r24,lo8(-3)
 499 028e 893E      		cpi r24,lo8(-23)
 500 0290 01F0      		breq .+2
 501 0292 00C0      		rjmp .L25
 502               	.L31:
  53:FAT32.c       **** bytesPerSector = bpb->bytesPerSector;
 503               		.loc 1 53 0
 504 0294 8091 0000 		lds r24,buffer+11
 505 0298 9091 0000 		lds r25,buffer+11+1
 506 029c 9093 0000 		sts bytesPerSector+1,r25
 507 02a0 8093 0000 		sts bytesPerSector,r24
  55:FAT32.c       **** sectorPerCluster = bpb->sectorPerCluster;
 508               		.loc 1 55 0
 509 02a4 8091 0000 		lds r24,buffer+13
 510 02a8 90E0      		ldi r25,0
 511 02aa 9093 0000 		sts sectorPerCluster+1,r25
 512 02ae 8093 0000 		sts sectorPerCluster,r24
  57:FAT32.c       **** reservedSectorCount = bpb->reservedSectorCount;
 513               		.loc 1 57 0
 514 02b2 E091 0000 		lds r30,buffer+14
 515 02b6 F091 0000 		lds r31,buffer+14+1
 516 02ba F093 0000 		sts reservedSectorCount+1,r31
 517 02be E093 0000 		sts reservedSectorCount,r30
  58:FAT32.c       **** rootCluster = bpb->rootCluster;// + (sector / sectorPerCluster) +1;
 518               		.loc 1 58 0
 519 02c2 8091 0000 		lds r24,buffer+44
 520 02c6 9091 0000 		lds r25,buffer+44+1
 521 02ca A091 0000 		lds r26,buffer+44+2
 522 02ce B091 0000 		lds r27,buffer+44+3
 523 02d2 8093 0000 		sts rootCluster,r24
 524 02d6 9093 0000 		sts rootCluster+1,r25
 525 02da A093 0000 		sts rootCluster+2,r26
 526 02de B093 0000 		sts rootCluster+3,r27
  59:FAT32.c       **** firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32)
 527               		.loc 1 59 0
 528 02e2 C091 0000 		lds r28,reservedSectorCount
 529 02e6 D091 0000 		lds r29,reservedSectorCount+1
 530 02ea A091 0000 		lds r26,buffer+16
 531 02ee 2091 0000 		lds r18,buffer+36
 532 02f2 3091 0000 		lds r19,buffer+36+1
 533 02f6 4091 0000 		lds r20,buffer+36+2
 534 02fa 5091 0000 		lds r21,buffer+36+3
 535 02fe B0E0      		ldi r27,0
 536 0300 0E94 0000 		call __muluhisi3
 537 0304 8B01      		movw r16,r22
 538 0306 9C01      		movw r18,r24
 539 0308 8091 0000 		lds r24,buffer+28
 540 030c 9091 0000 		lds r25,buffer+28+1
 541 0310 A091 0000 		lds r26,buffer+28+2
 542 0314 B091 0000 		lds r27,buffer+28+3
 543 0318 8C0F      		add r24,r28
 544 031a 9D1F      		adc r25,r29
 545 031c A11D      		adc r26,__zero_reg__
 546 031e B11D      		adc r27,__zero_reg__
 547 0320 800F      		add r24,r16
 548 0322 911F      		adc r25,r17
 549 0324 A21F      		adc r26,r18
 550 0326 B31F      		adc r27,r19
 551 0328 8093 0000 		sts firstDataSector,r24
 552 032c 9093 0000 		sts firstDataSector+1,r25
 553 0330 A093 0000 		sts firstDataSector+2,r26
 554 0334 B093 0000 		sts firstDataSector+3,r27
  64:FAT32.c       **** totalClusters = dataSectors / sectorPerCluster;
 555               		.loc 1 64 0
 556 0338 4091 0000 		lds r20,sectorPerCluster
 557 033c 5091 0000 		lds r21,sectorPerCluster+1
  62:FAT32.c       ****               - bpb->reservedSectorCount
 558               		.loc 1 62 0
 559 0340 6091 0000 		lds r22,buffer+32
 560 0344 7091 0000 		lds r23,buffer+32+1
 561 0348 8091 0000 		lds r24,buffer+32+2
 562 034c 9091 0000 		lds r25,buffer+32+3
 563 0350 6E1B      		sub r22,r30
 564 0352 7F0B      		sbc r23,r31
 565 0354 8109      		sbc r24,__zero_reg__
 566 0356 9109      		sbc r25,__zero_reg__
  61:FAT32.c       **** dataSectors = bpb->totalSectors_F32
 567               		.loc 1 61 0
 568 0358 601B      		sub r22,r16
 569 035a 710B      		sbc r23,r17
 570 035c 820B      		sbc r24,r18
 571 035e 930B      		sbc r25,r19
  64:FAT32.c       **** totalClusters = dataSectors / sectorPerCluster;
 572               		.loc 1 64 0
 573 0360 9A01      		movw r18,r20
 574 0362 40E0      		ldi r20,0
 575 0364 50E0      		ldi r21,0
 576 0366 0E94 0000 		call __udivmodsi4
 577 036a 2093 0000 		sts totalClusters,r18
 578 036e 3093 0000 		sts totalClusters+1,r19
 579 0372 4093 0000 		sts totalClusters+2,r20
 580 0376 5093 0000 		sts totalClusters+3,r21
  67:FAT32.c       **** if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count
 581               		.loc 1 67 0
 582 037a 20E0      		ldi r18,0
 583 037c 30E0      		ldi r19,0
 584 037e A901      		movw r20,r18
 585 0380 60E0      		ldi r22,0
 586 0382 81E0      		ldi r24,lo8(1)
 587 0384 0E94 0000 		call getSetFreeCluster
 588               	.LVL30:
 589 0388 0091 0000 		lds r16,totalClusters
 590 038c 1091 0000 		lds r17,totalClusters+1
 591 0390 2091 0000 		lds r18,totalClusters+2
 592 0394 3091 0000 		lds r19,totalClusters+3
 593 0398 0617      		cp r16,r22
 594 039a 1707      		cpc r17,r23
 595 039c 2807      		cpc r18,r24
 596 039e 3907      		cpc r19,r25
 597 03a0 00F4      		brsh .L32
  68:FAT32.c       ****      freeClusterCountUpdated = 0;
 598               		.loc 1 68 0
 599 03a2 1092 0000 		sts freeClusterCountUpdated,__zero_reg__
 600 03a6 00C0      		rjmp .L33
 601               	.L25:
 602               	.LVL31:
  43:FAT32.c       ****   if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
 603               		.loc 1 43 0
 604 03a8 8091 0000 		lds r24,buffer+510
 605 03ac 9091 0000 		lds r25,buffer+510+1
 606 03b0 8535      		cpi r24,85
 607 03b2 9A4A      		sbci r25,-86
 608 03b4 01F0      		breq .L28
 609               	.L30:
 610 03b6 81E0      		ldi r24,lo8(1)
 611 03b8 00C0      		rjmp .L29
 612               	.L28:
 613               	.LVL32:
  46:FAT32.c       ****   unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
 614               		.loc 1 46 0
 615 03ba 6091 0000 		lds r22,buffer+454
 616 03be 7091 0000 		lds r23,buffer+454+1
 617 03c2 8091 0000 		lds r24,buffer+454+2
 618 03c6 9091 0000 		lds r25,buffer+454+3
 619 03ca 6093 0000 		sts unusedSectors,r22
 620 03ce 7093 0000 		sts unusedSectors+1,r23
 621 03d2 8093 0000 		sts unusedSectors+2,r24
 622 03d6 9093 0000 		sts unusedSectors+3,r25
  48:FAT32.c       ****   SD_readSingleBlock(partition->firstSector);//read the bpb sector
 623               		.loc 1 48 0
 624 03da 0E94 0000 		call SD_readSingleBlock
 625               	.LVL33:
  50:FAT32.c       ****   if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
 626               		.loc 1 50 0
 627 03de 8091 0000 		lds r24,buffer
 628 03e2 8D7F      		andi r24,lo8(-3)
 629 03e4 893E      		cpi r24,lo8(-23)
 630 03e6 01F4      		brne .L30
 631 03e8 00C0      		rjmp .L31
 632               	.LVL34:
 633               	.L32:
  70:FAT32.c       **** 	 freeClusterCountUpdated = 1;
 634               		.loc 1 70 0
 635 03ea 81E0      		ldi r24,lo8(1)
 636 03ec 8093 0000 		sts freeClusterCountUpdated,r24
 637               	.L33:
  71:FAT32.c       **** return 0;
 638               		.loc 1 71 0
 639 03f0 80E0      		ldi r24,0
 640               	.L29:
 641               	/* epilogue start */
  72:FAT32.c       **** }
 642               		.loc 1 72 0
 643 03f2 DF91      		pop r29
 644 03f4 CF91      		pop r28
 645 03f6 1F91      		pop r17
 646 03f8 0F91      		pop r16
 647 03fa 0895      		ret
 648               		.cfi_endproc
 649               	.LFE1:
 651               	.global	convertFileName
 653               	convertFileName:
 654               	.LFB7:
 161:FAT32.c       **** 
 162:FAT32.c       **** //***************************************************************************
 163:FAT32.c       **** //Function: to get DIR/FILE list or a single file address (cluster number) or to delete a specified
 164:FAT32.c       **** //Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_L
 165:FAT32.c       **** //return: first cluster of the file, if flag = GET_FILE
 166:FAT32.c       **** //        print file/dir list of the root directory, if flag = GET_LIST
 167:FAT32.c       **** //		  Delete the file mentioned in arg#2, if flag = DELETE
 168:FAT32.c       **** //****************************************************************************
 169:FAT32.c       **** struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
 170:FAT32.c       **** {
 171:FAT32.c       **** unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
 172:FAT32.c       **** struct dir_Structure *dir;
 173:FAT32.c       **** unsigned int i;
 174:FAT32.c       **** unsigned char j;
 175:FAT32.c       **** 
 176:FAT32.c       **** cluster = rootCluster; //root cluster
 177:FAT32.c       **** 
 178:FAT32.c       **** while(1)
 179:FAT32.c       **** {
 180:FAT32.c       ****    firstSector = getFirstSector (cluster);
 181:FAT32.c       **** 
 182:FAT32.c       ****    for(sector = 0; sector < sectorPerCluster; sector++)
 183:FAT32.c       ****    {
 184:FAT32.c       ****      SD_readSingleBlock (firstSector + sector);
 185:FAT32.c       **** 	
 186:FAT32.c       **** 
 187:FAT32.c       ****      for(i=0; i<bytesPerSector; i+=32)
 188:FAT32.c       ****      {
 189:FAT32.c       **** 	    dir = (struct dir_Structure *) &buffer[i];
 190:FAT32.c       **** 
 191:FAT32.c       ****         if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
 192:FAT32.c       **** 		{
 193:FAT32.c       **** 		  if((flag == GET_FILE) || (flag == DELETE))
 194:FAT32.c       **** 		      transmitString_F(PSTR("File does not exist!"));
 195:FAT32.c       **** 		  return 0;   
 196:FAT32.c       **** 		}
 197:FAT32.c       **** 		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
 198:FAT32.c       ****         {
 199:FAT32.c       ****           if((flag == GET_FILE) || (flag == DELETE))
 200:FAT32.c       ****           {
 201:FAT32.c       ****             for(j=0; j<11; j++)
 202:FAT32.c       ****             if(dir->name[j] != fileName[j]) break;
 203:FAT32.c       ****             if(j == 11)
 204:FAT32.c       **** 			{
 205:FAT32.c       **** 			  if(flag == GET_FILE)
 206:FAT32.c       ****               {
 207:FAT32.c       **** 			    appendFileSector = firstSector + sector;
 208:FAT32.c       **** 				appendFileLocation = i;
 209:FAT32.c       **** 				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
 210:FAT32.c       **** 				fileSize = dir->fileSize;
 211:FAT32.c       **** 			    return (dir);
 212:FAT32.c       **** 			  }	
 213:FAT32.c       **** 			  else    //when flag = DELETE
 214:FAT32.c       **** 			  {
 215:FAT32.c       **** 			     TX_NEWLINE;
 216:FAT32.c       **** 				 transmitString_F(PSTR("Deleting.."));
 217:FAT32.c       **** 				 TX_NEWLINE;
 218:FAT32.c       **** 				 TX_NEWLINE;
 219:FAT32.c       **** 				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
 220:FAT32.c       ****                 
 221:FAT32.c       **** 				 //mark file as 'deleted' in FAT table
 222:FAT32.c       **** 				 dir->name[0] = DELETED;    
 223:FAT32.c       **** 				 SD_writeSingleBlock (firstSector+sector);
 224:FAT32.c       **** 				 			 
 225:FAT32.c       **** 				 freeMemoryUpdate (ADD, dir->fileSize);
 226:FAT32.c       **** 
 227:FAT32.c       **** 				 //update next free cluster entry in FSinfo sector
 228:FAT32.c       **** 				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
 229:FAT32.c       **** 				 if(firstCluster < cluster)
 230:FAT32.c       **** 				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
 231:FAT32.c       **** 
 232:FAT32.c       **** 				 //mark all the clusters allocated to the file as 'free'
 233:FAT32.c       **** 			     while(1)  
 234:FAT32.c       **** 			     {
 235:FAT32.c       **** 			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
 236:FAT32.c       **** 					getSetNextCluster (firstCluster, SET, 0);
 237:FAT32.c       **** 					if(nextCluster > 0x0ffffff6) 
 238:FAT32.c       **** 					   {transmitString_F(PSTR("File deleted!"));return 0;}
 239:FAT32.c       **** 					firstCluster = nextCluster;
 240:FAT32.c       **** 			  	 } 
 241:FAT32.c       **** 			  }
 242:FAT32.c       ****             }
 243:FAT32.c       ****           }
 244:FAT32.c       ****           else  //when flag = GET_LIST
 245:FAT32.c       **** 		  {
 246:FAT32.c       **** 		     TX_NEWLINE;
 247:FAT32.c       **** 			 for(j=0; j<11; j++)
 248:FAT32.c       **** 		     {
 249:FAT32.c       **** 			   if(j == 8) transmitByte(' ');
 250:FAT32.c       **** 			   transmitByte (dir->name[j]);
 251:FAT32.c       **** 			 }
 252:FAT32.c       **** 		     transmitString_F (PSTR("   "));
 253:FAT32.c       **** 		     if((dir->attrib != 0x10) && (dir->attrib != 0x08))
 254:FAT32.c       **** 			 {
 255:FAT32.c       **** 			     transmitString_F (PSTR("FILE" ));
 256:FAT32.c       **** 		         transmitString_F (PSTR("   "));
 257:FAT32.c       **** 			     displayMemory (LOW, dir->fileSize);
 258:FAT32.c       **** 			 }
 259:FAT32.c       **** 			 else
 260:FAT32.c       **** 			   transmitString_F ((dir->attrib == 0x10)? PSTR("DIR") : PSTR("ROOT"));
 261:FAT32.c       **** 		  }
 262:FAT32.c       ****        }
 263:FAT32.c       ****      }
 264:FAT32.c       ****    }
 265:FAT32.c       **** 
 266:FAT32.c       ****    cluster = (getSetNextCluster (cluster, GET, 0));
 267:FAT32.c       **** 
 268:FAT32.c       ****    if(cluster > 0x0ffffff6)
 269:FAT32.c       ****    	 return 0;
 270:FAT32.c       ****    if(cluster == 0) 
 271:FAT32.c       ****    {transmitString_F(PSTR("Error in getting cluster"));  return 0;}
 272:FAT32.c       ****  }
 273:FAT32.c       **** return 0;
 274:FAT32.c       **** }
 275:FAT32.c       **** 
 276:FAT32.c       **** //***************************************************************************
 277:FAT32.c       **** //Function: if flag=READ then to read file from SD card and send contents to UART 
 278:FAT32.c       **** //if flag=VERIFY then functions will verify whether a specified file is already existing
 279:FAT32.c       **** //Arguments: flag (READ or VERIFY) and pointer to the file name
 280:FAT32.c       **** //return: 0, if normal operation or flag is READ
 281:FAT32.c       **** //	      1, if file is already existing and flag = VERIFY
 282:FAT32.c       **** //		  2, if file name is incompatible
 283:FAT32.c       **** //***************************************************************************
 284:FAT32.c       **** unsigned char readFile (unsigned char flag, unsigned char *fileName)
 285:FAT32.c       **** {
 286:FAT32.c       **** struct dir_Structure *dir;
 287:FAT32.c       **** unsigned long cluster, byteCounter = 0, fileSize, firstSector;
 288:FAT32.c       **** unsigned int k;
 289:FAT32.c       **** unsigned char j, error;
 290:FAT32.c       **** 
 291:FAT32.c       **** error = convertFileName (fileName); //convert fileName into FAT format
 292:FAT32.c       **** if(error) return 2;
 293:FAT32.c       **** 
 294:FAT32.c       **** dir = findFiles (GET_FILE, fileName); //get the file location
 295:FAT32.c       **** if(dir == 0) 
 296:FAT32.c       ****   return (0);
 297:FAT32.c       **** 
 298:FAT32.c       **** if(flag == VERIFY) return (1);	//specified file name is already existing
 299:FAT32.c       **** 
 300:FAT32.c       **** cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
 301:FAT32.c       **** 
 302:FAT32.c       **** fileSize = dir->fileSize;
 303:FAT32.c       **** 
 304:FAT32.c       **** TX_NEWLINE;
 305:FAT32.c       **** TX_NEWLINE;
 306:FAT32.c       **** 
 307:FAT32.c       **** while(1)
 308:FAT32.c       **** {
 309:FAT32.c       ****   firstSector = getFirstSector (cluster);
 310:FAT32.c       **** 
 311:FAT32.c       ****   for(j=0; j<sectorPerCluster; j++)
 312:FAT32.c       ****   {
 313:FAT32.c       ****     SD_readSingleBlock(firstSector + j);
 314:FAT32.c       ****     
 315:FAT32.c       **** 	for(k=0; k<512; k++)
 316:FAT32.c       ****     {
 317:FAT32.c       ****       transmitByte(buffer[k]);
 318:FAT32.c       ****       if ((byteCounter++) >= fileSize ) return 0;
 319:FAT32.c       ****     }
 320:FAT32.c       ****   }
 321:FAT32.c       ****   cluster = getSetNextCluster (cluster, GET, 0);
 322:FAT32.c       ****   if(cluster == 0) {transmitString_F(PSTR("Error in getting cluster")); return 0;}
 323:FAT32.c       **** }
 324:FAT32.c       **** return 0;
 325:FAT32.c       **** }
 326:FAT32.c       **** 
 327:FAT32.c       **** //***************************************************************************
 328:FAT32.c       **** //Function: to convert normal short file name into FAT format
 329:FAT32.c       **** //Arguments: pointer to the file name
 330:FAT32.c       **** //return: 0, if successful else 1.
 331:FAT32.c       **** //***************************************************************************
 332:FAT32.c       **** unsigned char convertFileName (unsigned char *fileName)
 333:FAT32.c       **** {
 655               		.loc 1 333 0
 656               		.cfi_startproc
 657               	.LVL35:
 658 03fc CF93      		push r28
 659               	.LCFI34:
 660               		.cfi_def_cfa_offset 3
 661               		.cfi_offset 28, -2
 662 03fe DF93      		push r29
 663               	.LCFI35:
 664               		.cfi_def_cfa_offset 4
 665               		.cfi_offset 29, -3
 666 0400 CDB7      		in r28,__SP_L__
 667 0402 DEB7      		in r29,__SP_H__
 668               	.LCFI36:
 669               		.cfi_def_cfa_register 28
 670 0404 2B97      		sbiw r28,11
 671               	.LCFI37:
 672               		.cfi_def_cfa_offset 15
 673 0406 0FB6      		in __tmp_reg__,__SREG__
 674 0408 F894      		cli
 675 040a DEBF      		out __SP_H__,r29
 676 040c 0FBE      		out __SREG__,__tmp_reg__
 677 040e CDBF      		out __SP_L__,r28
 678               	/* prologue: function */
 679               	/* frame size = 11 */
 680               	/* stack size = 13 */
 681               	.L__stack_usage = 13
 682               	.LVL36:
 683               		.loc 1 333 0
 684 0410 FC01      		movw r30,r24
 334:FAT32.c       **** unsigned char fileNameFAT[11];
 335:FAT32.c       **** unsigned char j, k;
 336:FAT32.c       **** 
 337:FAT32.c       **** for(j=0; j<12; j++)
 685               		.loc 1 337 0
 686 0412 40E0      		ldi r20,0
 687               	.LVL37:
 688               	.L37:
 338:FAT32.c       **** if(fileName[j] == '.') break;
 689               		.loc 1 338 0
 690 0414 2191      		ld r18,Z+
 691 0416 2E32      		cpi r18,lo8(46)
 692 0418 01F0      		breq .L35
 337:FAT32.c       **** for(j=0; j<12; j++)
 693               		.loc 1 337 0
 694 041a 4F5F      		subi r20,lo8(-(1))
 695               	.LVL38:
 696 041c 4C30      		cpi r20,lo8(12)
 697 041e 01F4      		brne .L37
 698 0420 00C0      		rjmp .L36
 699               	.L35:
 700 0422 542F      		mov r21,r20
 339:FAT32.c       **** 
 340:FAT32.c       **** if(j>8) {transmitString_F(PSTR("Invalid fileName..")); return 1;}
 701               		.loc 1 340 0
 702 0424 4930      		cpi r20,lo8(9)
 703 0426 00F4      		brsh .L36
 704 0428 9E01      		movw r18,r28
 705 042a 2F5F      		subi r18,-1
 706 042c 3F4F      		sbci r19,-1
 707 042e F901      		movw r30,r18
 708 0430 DC01      		movw r26,r24
 709 0432 00C0      		rjmp .L38
 710               	.L36:
 711               		.loc 1 340 0 is_stmt 0 discriminator 1
 712 0434 80E0      		ldi r24,lo8(__c.1935)
 713 0436 90E0      		ldi r25,hi8(__c.1935)
 714               	.LVL39:
 715 0438 0E94 0000 		call transmitString_F
 716               	.LVL40:
 717 043c 81E0      		ldi r24,lo8(1)
 718 043e 00C0      		rjmp .L39
 719               	.LVL41:
 720               	.L38:
 721 0440 6E2F      		mov r22,r30
 722 0442 621B      		sub r22,r18
 341:FAT32.c       **** 
 342:FAT32.c       **** for(k=0; k<j; k++) //setting file name
 723               		.loc 1 342 0 is_stmt 1 discriminator 1
 724 0444 6417      		cp r22,r20
 725 0446 00F4      		brsh .L56
 343:FAT32.c       ****   fileNameFAT[k] = fileName[k];
 726               		.loc 1 343 0 discriminator 2
 727 0448 6D91      		ld r22,X+
 728 044a 6193      		st Z+,r22
 729 044c 00C0      		rjmp .L38
 730               	.L56:
 344:FAT32.c       **** 
 345:FAT32.c       **** for(k=j; k<=7; k++) //filling file name trail with blanks
 346:FAT32.c       ****   fileNameFAT[k] = ' ';
 731               		.loc 1 346 0
 732 044e 60E2      		ldi r22,lo8(32)
 733               	.LVL42:
 734               	.L41:
 345:FAT32.c       **** for(k=j; k<=7; k++) //filling file name trail with blanks
 735               		.loc 1 345 0 discriminator 1
 736 0450 4830      		cpi r20,lo8(8)
 737 0452 01F0      		breq .L57
 738               		.loc 1 346 0 discriminator 2
 739 0454 F901      		movw r30,r18
 740 0456 E40F      		add r30,r20
 741 0458 F11D      		adc r31,__zero_reg__
 742 045a 6083      		st Z,r22
 345:FAT32.c       **** for(k=j; k<=7; k++) //filling file name trail with blanks
 743               		.loc 1 345 0 discriminator 2
 744 045c 4F5F      		subi r20,lo8(-(1))
 745               	.LVL43:
 746 045e 00C0      		rjmp .L41
 747               	.L57:
 347:FAT32.c       **** 
 348:FAT32.c       **** j++;
 748               		.loc 1 348 0
 749 0460 5F5F      		subi r21,lo8(-(1))
 750               	.LVL44:
 349:FAT32.c       **** for(k=8; k<11; k++) //setting file extention
 350:FAT32.c       **** {
 351:FAT32.c       ****   if(fileName[j] != 0)
 352:FAT32.c       ****     fileNameFAT[k] = fileName[j++];
 353:FAT32.c       ****   else //filling extension trail with blanks
 354:FAT32.c       ****     while(k<11)
 355:FAT32.c       ****       fileNameFAT[k++] = ' ';
 751               		.loc 1 355 0
 752 0462 70E2      		ldi r23,lo8(32)
 753               	.LVL45:
 754               	.L47:
 351:FAT32.c       ****   if(fileName[j] != 0)
 755               		.loc 1 351 0
 756 0464 FC01      		movw r30,r24
 757 0466 E50F      		add r30,r21
 758 0468 F11D      		adc r31,__zero_reg__
 759 046a 6081      		ld r22,Z
 760 046c 6623      		tst r22
 761 046e 01F0      		breq .L43
 352:FAT32.c       ****     fileNameFAT[k] = fileName[j++];
 762               		.loc 1 352 0
 763 0470 5F5F      		subi r21,lo8(-(1))
 764               	.LVL46:
 765 0472 F901      		movw r30,r18
 766 0474 E40F      		add r30,r20
 767 0476 F11D      		adc r31,__zero_reg__
 768 0478 6083      		st Z,r22
 769 047a 00C0      		rjmp .L44
 770               	.L43:
 351:FAT32.c       ****   if(fileName[j] != 0)
 771               		.loc 1 351 0
 772 047c 642F      		mov r22,r20
 773               	.LVL47:
 774               		.loc 1 355 0
 775 047e 4F5F      		subi r20,lo8(-(1))
 776               	.LVL48:
 777 0480 F901      		movw r30,r18
 778 0482 E60F      		add r30,r22
 779 0484 F11D      		adc r31,__zero_reg__
 780 0486 7083      		st Z,r23
 354:FAT32.c       ****     while(k<11)
 781               		.loc 1 354 0
 782 0488 4B30      		cpi r20,lo8(11)
 783 048a 00F0      		brlo .L43
 784               	.L44:
 349:FAT32.c       **** for(k=8; k<11; k++) //setting file extention
 785               		.loc 1 349 0
 786 048c 4F5F      		subi r20,lo8(-(1))
 787               	.LVL49:
 788 048e 4B30      		cpi r20,lo8(11)
 789 0490 00F0      		brlo .L47
 790 0492 AE01      		movw r20,r28
 791               	.LVL50:
 792 0494 445F      		subi r20,-12
 793 0496 5F4F      		sbci r21,-1
 794 0498 F901      		movw r30,r18
 795               	.LVL51:
 796               	.L50:
 356:FAT32.c       **** }
 357:FAT32.c       **** 
 358:FAT32.c       **** for(j=0; j<11; j++) //converting small letters to caps
 359:FAT32.c       ****   if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
 797               		.loc 1 359 0
 798 049a 6081      		ld r22,Z
 799 049c 7FE9      		ldi r23,lo8(-97)
 800 049e 760F      		add r23,r22
 801 04a0 7A31      		cpi r23,lo8(26)
 802 04a2 00F4      		brsh .L48
 360:FAT32.c       ****     fileNameFAT[j] -= 0x20;
 803               		.loc 1 360 0
 804 04a4 6052      		subi r22,lo8(-(-32))
 805 04a6 6083      		st Z,r22
 806               	.L48:
 807 04a8 3196      		adiw r30,1
 358:FAT32.c       **** for(j=0; j<11; j++) //converting small letters to caps
 808               		.loc 1 358 0
 809 04aa E417      		cp r30,r20
 810 04ac F507      		cpc r31,r21
 811 04ae 01F4      		brne .L50
 812 04b0 DC01      		movw r26,r24
 813 04b2 F901      		movw r30,r18
 814               	.LVL52:
 815               	.L51:
 361:FAT32.c       **** 
 362:FAT32.c       **** for(j=0; j<11; j++)
 363:FAT32.c       ****   fileName[j] = fileNameFAT[j];
 816               		.loc 1 363 0 discriminator 2
 817 04b4 8191      		ld r24,Z+
 818 04b6 8D93      		st X+,r24
 362:FAT32.c       **** for(j=0; j<11; j++)
 819               		.loc 1 362 0 discriminator 2
 820 04b8 E417      		cp r30,r20
 821 04ba F507      		cpc r31,r21
 822 04bc 01F4      		brne .L51
 364:FAT32.c       **** 
 365:FAT32.c       **** return 0;
 823               		.loc 1 365 0
 824 04be 80E0      		ldi r24,0
 825               	.L39:
 826               	/* epilogue start */
 366:FAT32.c       **** }
 827               		.loc 1 366 0
 828 04c0 2B96      		adiw r28,11
 829 04c2 0FB6      		in __tmp_reg__,__SREG__
 830 04c4 F894      		cli
 831 04c6 DEBF      		out __SP_H__,r29
 832 04c8 0FBE      		out __SREG__,__tmp_reg__
 833 04ca CDBF      		out __SP_L__,r28
 834 04cc DF91      		pop r29
 835 04ce CF91      		pop r28
 836 04d0 0895      		ret
 837               		.cfi_endproc
 838               	.LFE7:
 840               	.global	searchNextFreeCluster
 842               	searchNextFreeCluster:
 843               	.LFB9:
 367:FAT32.c       **** 
 368:FAT32.c       **** //************************************************************************************
 369:FAT32.c       **** //Function: to create a file in FAT32 format in the root directory if given 
 370:FAT32.c       **** //			file name does not exist; if the file already exists then append the data
 371:FAT32.c       **** //Arguments: pointer to the file name
 372:FAT32.c       **** //return: none
 373:FAT32.c       **** //************************************************************************************
 374:FAT32.c       **** void writeFile (unsigned char *fileName)
 375:FAT32.c       **** {
 376:FAT32.c       **** unsigned char j, data, error, fileCreatedFlag = 0, start = 0, appendFile = 0, sectorEndFlag = 0, se
 377:FAT32.c       **** unsigned int i, firstClusterHigh=0, firstClusterLow=0;  //value 0 is assigned just to avoid warning
 378:FAT32.c       **** struct dir_Structure *dir;
 379:FAT32.c       **** unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;
 380:FAT32.c       **** 
 381:FAT32.c       **** j = readFile (VERIFY, fileName);
 382:FAT32.c       **** 
 383:FAT32.c       **** if(j == 1) 
 384:FAT32.c       **** {
 385:FAT32.c       ****   transmitString_F(PSTR(" File already exists, appending data..")); 
 386:FAT32.c       ****   appendFile = 1;
 387:FAT32.c       ****   cluster = appendStartCluster;
 388:FAT32.c       ****   clusterCount=0;
 389:FAT32.c       ****   while(1)
 390:FAT32.c       ****   {
 391:FAT32.c       ****     nextCluster = getSetNextCluster (cluster, GET, 0);
 392:FAT32.c       ****     if(nextCluster == EOF) break;
 393:FAT32.c       **** 	cluster = nextCluster;
 394:FAT32.c       **** 	clusterCount++;
 395:FAT32.c       ****   }
 396:FAT32.c       **** 
 397:FAT32.c       ****   sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last
 398:FAT32.c       ****   start = 1;
 399:FAT32.c       **** //  appendFile();
 400:FAT32.c       **** //  return;
 401:FAT32.c       **** }
 402:FAT32.c       **** else if(j == 2) 
 403:FAT32.c       **** {
 404:FAT32.c       ****    return; //invalid file name
 405:FAT32.c       **** }
 406:FAT32.c       **** else
 407:FAT32.c       **** {
 408:FAT32.c       ****   TX_NEWLINE;
 409:FAT32.c       ****   transmitString_F(PSTR(" Creating File.."));
 410:FAT32.c       **** 
 411:FAT32.c       ****   cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
 412:FAT32.c       ****   if(cluster > totalClusters)
 413:FAT32.c       ****      cluster = rootCluster;
 414:FAT32.c       **** 
 415:FAT32.c       ****   cluster = searchNextFreeCluster(cluster);
 416:FAT32.c       ****    if(cluster == 0)
 417:FAT32.c       ****    {
 418:FAT32.c       ****       TX_NEWLINE;
 419:FAT32.c       ****       transmitString_F(PSTR(" No free cluster!"));
 420:FAT32.c       **** 	  return;
 421:FAT32.c       ****    }
 422:FAT32.c       ****   getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
 423:FAT32.c       ****    
 424:FAT32.c       ****   firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
 425:FAT32.c       ****   firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
 426:FAT32.c       ****   fileSize = 0;
 427:FAT32.c       **** }
 428:FAT32.c       **** 
 429:FAT32.c       **** 
 430:FAT32.c       **** 
 431:FAT32.c       **** while(1)
 432:FAT32.c       **** {
 433:FAT32.c       ****    if(start)
 434:FAT32.c       ****    {
 435:FAT32.c       ****       start = 0;
 436:FAT32.c       **** 	  startBlock = getFirstSector (cluster) + sector;
 437:FAT32.c       **** 	  SD_readSingleBlock (startBlock);
 438:FAT32.c       **** 	  i = fileSize % bytesPerSector;
 439:FAT32.c       **** 	  j = sector;
 440:FAT32.c       ****    }
 441:FAT32.c       ****    else
 442:FAT32.c       ****    {
 443:FAT32.c       ****       startBlock = getFirstSector (cluster);
 444:FAT32.c       **** 	  i=0;
 445:FAT32.c       **** 	  j=0;
 446:FAT32.c       ****    }
 447:FAT32.c       ****    
 448:FAT32.c       **** 
 449:FAT32.c       ****    TX_NEWLINE;
 450:FAT32.c       ****    transmitString_F(PSTR(" Enter text (end with ~):"));
 451:FAT32.c       ****    
 452:FAT32.c       ****    do
 453:FAT32.c       ****    {
 454:FAT32.c       ****      if(sectorEndFlag == 1) //special case when the last character in previous sector was '\r'
 455:FAT32.c       **** 	 {
 456:FAT32.c       **** 	 	transmitByte ('\n');
 457:FAT32.c       ****         buffer[i++] = '\n'; //appending 'Line Feed (LF)' character
 458:FAT32.c       **** 		fileSize++;
 459:FAT32.c       **** 	 }
 460:FAT32.c       **** 
 461:FAT32.c       **** 	sectorEndFlag = 0;
 462:FAT32.c       **** 
 463:FAT32.c       **** 	 data = receiveByte();
 464:FAT32.c       **** 	 if(data == 0x08)	//'Back Space' key pressed
 465:FAT32.c       **** 	 { 
 466:FAT32.c       **** 	   if(i != 0)
 467:FAT32.c       **** 	   { 
 468:FAT32.c       **** 	     transmitByte(data);
 469:FAT32.c       **** 		 transmitByte(' '); 
 470:FAT32.c       **** 	     transmitByte(data); 
 471:FAT32.c       **** 	     i--; 
 472:FAT32.c       **** 		 fileSize--;
 473:FAT32.c       **** 	   } 
 474:FAT32.c       **** 	   continue;     
 475:FAT32.c       **** 	 }
 476:FAT32.c       **** 	 transmitByte(data);
 477:FAT32.c       ****      buffer[i++] = data;
 478:FAT32.c       **** 	 fileSize++;
 479:FAT32.c       ****      if(data == '\r')  //'Carriege Return (CR)' character
 480:FAT32.c       ****      {
 481:FAT32.c       ****         if(i == 512)
 482:FAT32.c       **** 		   sectorEndFlag = 1;  //flag to indicate that the appended '\n' char should be put in the next s
 483:FAT32.c       **** 	    else
 484:FAT32.c       **** 		{ 
 485:FAT32.c       **** 		   transmitByte ('\n');
 486:FAT32.c       ****            buffer[i++] = '\n'; //appending 'Line Feed (LF)' character
 487:FAT32.c       **** 		   fileSize++;
 488:FAT32.c       **** 	    }
 489:FAT32.c       ****      }
 490:FAT32.c       **** 	 
 491:FAT32.c       ****      if(i >= 512)   //though 'i' will never become greater than 512, it's kept here to avoid 
 492:FAT32.c       **** 	 {				//infinite loop in case it happens to be greater than 512 due to some data corruption
 493:FAT32.c       **** 	   i=0;
 494:FAT32.c       **** 	   error = SD_writeSingleBlock (startBlock);
 495:FAT32.c       ****        j++;
 496:FAT32.c       **** 	   if(j == sectorPerCluster) {j = 0; break;}
 497:FAT32.c       **** 	   startBlock++; 
 498:FAT32.c       ****      }
 499:FAT32.c       **** 	}while (data != '~');
 500:FAT32.c       **** 
 501:FAT32.c       ****    if(data == '~') 
 502:FAT32.c       ****    {
 503:FAT32.c       ****       fileSize--;	//to remove the last entered '~' character
 504:FAT32.c       **** 	  i--;
 505:FAT32.c       **** 	  for(;i<512;i++)  //fill the rest of the buffer with 0x00
 506:FAT32.c       ****         buffer[i]= 0x00;
 507:FAT32.c       ****    	  error = SD_writeSingleBlock (startBlock);
 508:FAT32.c       **** 
 509:FAT32.c       ****       break;
 510:FAT32.c       ****    } 
 511:FAT32.c       **** 	  
 512:FAT32.c       ****    prevCluster = cluster;
 513:FAT32.c       **** 
 514:FAT32.c       ****    cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the curren
 515:FAT32.c       **** 
 516:FAT32.c       ****    if(cluster == 0)
 517:FAT32.c       ****    {
 518:FAT32.c       ****       TX_NEWLINE;
 519:FAT32.c       ****       transmitString_F(PSTR(" No free cluster!"));
 520:FAT32.c       **** 	  return;
 521:FAT32.c       ****    }
 522:FAT32.c       **** 
 523:FAT32.c       ****    getSetNextCluster(prevCluster, SET, cluster);
 524:FAT32.c       ****    getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
 525:FAT32.c       **** }        
 526:FAT32.c       **** 
 527:FAT32.c       **** getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
 528:FAT32.c       **** 
 529:FAT32.c       **** error = getDateTime_FAT();    //get current date & time from the RTC
 530:FAT32.c       **** if(error) { dateFAT = 0; timeFAT = 0;}
 531:FAT32.c       **** 
 532:FAT32.c       **** if(appendFile)  //executes this loop if file is to be appended
 533:FAT32.c       **** {
 534:FAT32.c       ****   SD_readSingleBlock (appendFileSector);    
 535:FAT32.c       ****   dir = (struct dir_Structure *) &buffer[appendFileLocation]; 
 536:FAT32.c       **** 
 537:FAT32.c       ****   dir->lastAccessDate = 0;   //date of last access ignored
 538:FAT32.c       ****   dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
 539:FAT32.c       ****   dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
 540:FAT32.c       ****   extraMemory = fileSize - dir->fileSize;
 541:FAT32.c       ****   dir->fileSize = fileSize;
 542:FAT32.c       ****   SD_writeSingleBlock (appendFileSector);
 543:FAT32.c       ****   freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
 544:FAT32.c       **** 
 545:FAT32.c       ****   
 546:FAT32.c       ****   TX_NEWLINE;
 547:FAT32.c       ****   transmitString_F(PSTR(" File appended!"));
 548:FAT32.c       ****   TX_NEWLINE;
 549:FAT32.c       **** 
 550:FAT32.c       ****   return;
 551:FAT32.c       **** }
 552:FAT32.c       **** 
 553:FAT32.c       **** //executes following portion when new file is created
 554:FAT32.c       **** 
 555:FAT32.c       **** prevCluster = rootCluster; //root cluster
 556:FAT32.c       **** 
 557:FAT32.c       **** while(1)
 558:FAT32.c       **** {
 559:FAT32.c       ****    firstSector = getFirstSector (prevCluster);
 560:FAT32.c       **** 
 561:FAT32.c       ****    for(sector = 0; sector < sectorPerCluster; sector++)
 562:FAT32.c       ****    {
 563:FAT32.c       ****      SD_readSingleBlock (firstSector + sector);
 564:FAT32.c       **** 	
 565:FAT32.c       **** 
 566:FAT32.c       ****      for(i=0; i<bytesPerSector; i+=32)
 567:FAT32.c       ****      {
 568:FAT32.c       **** 	    dir = (struct dir_Structure *) &buffer[i];
 569:FAT32.c       **** 
 570:FAT32.c       **** 		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
 571:FAT32.c       **** 		 { 					  //indicating end of the directory file list
 572:FAT32.c       **** 		   //dir->name[0] = EMPTY;
 573:FAT32.c       **** 		   //SD_writeSingleBlock (firstSector + sector);
 574:FAT32.c       ****            return;
 575:FAT32.c       ****          }
 576:FAT32.c       **** 
 577:FAT32.c       ****         if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to en
 578:FAT32.c       **** 		{
 579:FAT32.c       **** 		  for(j=0; j<11; j++)
 580:FAT32.c       ****   			dir->name[j] = fileName[j];
 581:FAT32.c       **** 		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
 582:FAT32.c       **** 		  dir->NTreserved = 0;			//always set to 0
 583:FAT32.c       **** 		  dir->timeTenth = 0;			//always set to 0
 584:FAT32.c       **** 		  dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
 585:FAT32.c       **** 		  dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
 586:FAT32.c       **** 		  dir->lastAccessDate = 0;   	//date of last access ignored
 587:FAT32.c       **** 		  dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
 588:FAT32.c       **** 		  dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
 589:FAT32.c       **** 		  dir->firstClusterHI = firstClusterHigh;
 590:FAT32.c       **** 		  dir->firstClusterLO = firstClusterLow;
 591:FAT32.c       **** 		  dir->fileSize = fileSize;
 592:FAT32.c       **** 
 593:FAT32.c       **** 		  SD_writeSingleBlock (firstSector + sector);
 594:FAT32.c       **** 		  fileCreatedFlag = 1;
 595:FAT32.c       **** 
 596:FAT32.c       **** 		  TX_NEWLINE;
 597:FAT32.c       **** 		  TX_NEWLINE;
 598:FAT32.c       **** 		  transmitString_F(PSTR(" File Created! "));
 599:FAT32.c       **** 
 600:FAT32.c       **** 		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
 601:FAT32.c       **** 	     
 602:FAT32.c       ****         }
 603:FAT32.c       ****      }
 604:FAT32.c       ****    }
 605:FAT32.c       **** 
 606:FAT32.c       ****    cluster = getSetNextCluster (prevCluster, GET, 0);
 607:FAT32.c       **** 
 608:FAT32.c       ****    if(cluster > 0x0ffffff6)
 609:FAT32.c       ****    {
 610:FAT32.c       ****       if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*s
 611:FAT32.c       **** 	  {  
 612:FAT32.c       **** 		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
 613:FAT32.c       **** 		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous clus
 614:FAT32.c       **** 		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
 615:FAT32.c       ****       } 
 616:FAT32.c       **** 
 617:FAT32.c       ****       else
 618:FAT32.c       ****       {	
 619:FAT32.c       **** 	    transmitString_F(PSTR("End of Cluster Chain")); 
 620:FAT32.c       **** 	    return;
 621:FAT32.c       ****       }
 622:FAT32.c       ****    }
 623:FAT32.c       ****    if(cluster == 0) {transmitString_F(PSTR("Error in getting cluster")); return;}
 624:FAT32.c       ****    
 625:FAT32.c       ****    prevCluster = cluster;
 626:FAT32.c       ****  }
 627:FAT32.c       ****  
 628:FAT32.c       ****  return;
 629:FAT32.c       **** }
 630:FAT32.c       **** 
 631:FAT32.c       **** 
 632:FAT32.c       **** //***************************************************************************
 633:FAT32.c       **** //Function: to search for the next free cluster in the root directory
 634:FAT32.c       **** //          starting from a specified cluster
 635:FAT32.c       **** //Arguments: Starting cluster
 636:FAT32.c       **** //return: the next free cluster
 637:FAT32.c       **** //****************************************************************
 638:FAT32.c       **** unsigned long searchNextFreeCluster (unsigned long startCluster)
 639:FAT32.c       **** {
 844               		.loc 1 639 0
 845               		.cfi_startproc
 846               	.LVL53:
 847 04d2 4F92      		push r4
 848               	.LCFI38:
 849               		.cfi_def_cfa_offset 3
 850               		.cfi_offset 4, -2
 851 04d4 5F92      		push r5
 852               	.LCFI39:
 853               		.cfi_def_cfa_offset 4
 854               		.cfi_offset 5, -3
 855 04d6 6F92      		push r6
 856               	.LCFI40:
 857               		.cfi_def_cfa_offset 5
 858               		.cfi_offset 6, -4
 859 04d8 7F92      		push r7
 860               	.LCFI41:
 861               		.cfi_def_cfa_offset 6
 862               		.cfi_offset 7, -5
 863 04da 8F92      		push r8
 864               	.LCFI42:
 865               		.cfi_def_cfa_offset 7
 866               		.cfi_offset 8, -6
 867 04dc 9F92      		push r9
 868               	.LCFI43:
 869               		.cfi_def_cfa_offset 8
 870               		.cfi_offset 9, -7
 871 04de AF92      		push r10
 872               	.LCFI44:
 873               		.cfi_def_cfa_offset 9
 874               		.cfi_offset 10, -8
 875 04e0 BF92      		push r11
 876               	.LCFI45:
 877               		.cfi_def_cfa_offset 10
 878               		.cfi_offset 11, -9
 879 04e2 CF92      		push r12
 880               	.LCFI46:
 881               		.cfi_def_cfa_offset 11
 882               		.cfi_offset 12, -10
 883 04e4 DF92      		push r13
 884               	.LCFI47:
 885               		.cfi_def_cfa_offset 12
 886               		.cfi_offset 13, -11
 887 04e6 EF92      		push r14
 888               	.LCFI48:
 889               		.cfi_def_cfa_offset 13
 890               		.cfi_offset 14, -12
 891 04e8 FF92      		push r15
 892               	.LCFI49:
 893               		.cfi_def_cfa_offset 14
 894               		.cfi_offset 15, -13
 895               	/* prologue: function */
 896               	/* frame size = 0 */
 897               	/* stack size = 12 */
 898               	.L__stack_usage = 12
 899 04ea 6B01      		movw r12,r22
 900 04ec 7C01      		movw r14,r24
 640:FAT32.c       ****   unsigned long cluster, *value, sector;
 641:FAT32.c       ****   unsigned char i;
 642:FAT32.c       ****     
 643:FAT32.c       **** 	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
 901               		.loc 1 643 0
 902 04ee 80E8      		ldi r24,128
 903 04f0 C822      		and r12,r24
 904               	.LVL54:
 905 04f2 2601      		movw r4,r12
 906 04f4 3701      		movw r6,r14
 907 04f6 32E0      		ldi r19,2
 908               		1:
 909 04f8 440C      		lsl r4
 910 04fa 551C      		rol r5
 911 04fc 661C      		rol r6
 912 04fe 771C      		rol r7
 913 0500 3A95      		dec r19
 914 0502 01F4      		brne 1b
 915               	.LVL55:
 916               	.L59:
 644:FAT32.c       ****     for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
 917               		.loc 1 644 0 discriminator 1
 918 0504 8091 0000 		lds r24,totalClusters
 919 0508 9091 0000 		lds r25,totalClusters+1
 920 050c A091 0000 		lds r26,totalClusters+2
 921 0510 B091 0000 		lds r27,totalClusters+3
 922 0514 C816      		cp r12,r24
 923 0516 D906      		cpc r13,r25
 924 0518 EA06      		cpc r14,r26
 925 051a FB06      		cpc r15,r27
 926 051c 00F0      		brlo .+2
 927 051e 00C0      		rjmp .L65
 645:FAT32.c       ****     {
 646:FAT32.c       ****       sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
 928               		.loc 1 646 0
 929 0520 8091 0000 		lds r24,reservedSectorCount
 930 0524 9091 0000 		lds r25,reservedSectorCount+1
 931 0528 2091 0000 		lds r18,bytesPerSector
 932 052c 3091 0000 		lds r19,bytesPerSector+1
 933               	.LVL56:
 934 0530 8090 0000 		lds r8,unusedSectors
 935 0534 9090 0000 		lds r9,unusedSectors+1
 936 0538 A090 0000 		lds r10,unusedSectors+2
 937 053c B090 0000 		lds r11,unusedSectors+3
 938 0540 880E      		add r8,r24
 939 0542 991E      		adc r9,r25
 940 0544 A11C      		adc r10,__zero_reg__
 941 0546 B11C      		adc r11,__zero_reg__
 942 0548 40E0      		ldi r20,0
 943 054a 50E0      		ldi r21,0
 944 054c C301      		movw r24,r6
 945 054e B201      		movw r22,r4
 946 0550 0E94 0000 		call __udivmodsi4
 947               	.LVL57:
 948 0554 820E      		add r8,r18
 949 0556 931E      		adc r9,r19
 950 0558 A41E      		adc r10,r20
 951 055a B51E      		adc r11,r21
 647:FAT32.c       ****       SD_readSingleBlock(sector);
 952               		.loc 1 647 0
 953 055c C501      		movw r24,r10
 954 055e B401      		movw r22,r8
 955 0560 0E94 0000 		call SD_readSingleBlock
 956               	.LVL58:
 957 0564 E0E0      		ldi r30,lo8(buffer)
 958 0566 F0E0      		ldi r31,hi8(buffer)
 648:FAT32.c       ****       for(i=0; i<128; i++)
 959               		.loc 1 648 0
 960 0568 20E0      		ldi r18,0
 961               	.LVL59:
 962               	.L60:
 649:FAT32.c       ****       {
 650:FAT32.c       ****        	 value = (unsigned long *) &buffer[i*4];
 651:FAT32.c       ****          if(((*value) & 0x0fffffff) == 0)
 963               		.loc 1 651 0
 964 056a 8191      		ld r24,Z+
 965 056c 9191      		ld r25,Z+
 966 056e A191      		ld r26,Z+
 967 0570 B191      		ld r27,Z+
 968               	.LVL60:
 969 0572 BF70      		andi r27,15
 970 0574 892B      		or r24,r25
 971 0576 8A2B      		or r24,r26
 972 0578 8B2B      		or r24,r27
 973 057a 01F4      		brne .L61
 652:FAT32.c       ****             return(cluster+i);
 974               		.loc 1 652 0
 975 057c C701      		movw r24,r14
 976 057e B601      		movw r22,r12
 977 0580 620F      		add r22,r18
 978 0582 711D      		adc r23,__zero_reg__
 979 0584 811D      		adc r24,__zero_reg__
 980 0586 911D      		adc r25,__zero_reg__
 981 0588 00C0      		rjmp .L62
 982               	.L61:
 648:FAT32.c       ****       for(i=0; i<128; i++)
 983               		.loc 1 648 0
 984 058a 2F5F      		subi r18,lo8(-(1))
 985               	.LVL61:
 986 058c 2038      		cpi r18,lo8(-128)
 987 058e 01F4      		brne .L60
 644:FAT32.c       ****     for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
 988               		.loc 1 644 0
 989 0590 80E8      		ldi r24,-128
 990 0592 C80E      		add r12,r24
 991 0594 D11C      		adc r13,__zero_reg__
 992 0596 E11C      		adc r14,__zero_reg__
 993 0598 F11C      		adc r15,__zero_reg__
 994               	.LVL62:
 995 059a 82E0      		ldi r24,2
 996 059c 580E      		add r5,r24
 997 059e 611C      		adc r6,__zero_reg__
 998 05a0 711C      		adc r7,__zero_reg__
 999 05a2 00C0      		rjmp .L59
 1000               	.LVL63:
 1001               	.L65:
 653:FAT32.c       ****       }  
 654:FAT32.c       ****     } 
 655:FAT32.c       **** 
 656:FAT32.c       ****  return 0;
 1002               		.loc 1 656 0
 1003 05a4 60E0      		ldi r22,0
 1004 05a6 70E0      		ldi r23,0
 1005 05a8 CB01      		movw r24,r22
 1006               	.L62:
 1007               	/* epilogue start */
 657:FAT32.c       **** }
 1008               		.loc 1 657 0
 1009 05aa FF90      		pop r15
 1010 05ac EF90      		pop r14
 1011 05ae DF90      		pop r13
 1012 05b0 CF90      		pop r12
 1013               	.LVL64:
 1014 05b2 BF90      		pop r11
 1015 05b4 AF90      		pop r10
 1016 05b6 9F90      		pop r9
 1017 05b8 8F90      		pop r8
 1018 05ba 7F90      		pop r7
 1019 05bc 6F90      		pop r6
 1020 05be 5F90      		pop r5
 1021 05c0 4F90      		pop r4
 1022 05c2 0895      		ret
 1023               		.cfi_endproc
 1024               	.LFE9:
 1026               		.section	.rodata.str1.1,"aMS",@progbits,1
 1027               	.LC0:
 1028 0000 2020 2020 		.string	"              Bytes"
 1028      2020 2020 
 1028      2020 2020 
 1028      2020 4279 
 1028      7465 7300 
 1029               		.text
 1030               	.global	displayMemory
 1032               	displayMemory:
 1033               	.LFB11:
 658:FAT32.c       **** 
 659:FAT32.c       **** //***************************************************************************
 660:FAT32.c       **** //Function: to display total memory and free memory of SD card, using UART
 661:FAT32.c       **** //Arguments: none
 662:FAT32.c       **** //return: none
 663:FAT32.c       **** //Note: this routine can take upto 15sec for 1GB card (@1MHz clock)
 664:FAT32.c       **** //it tries to read from SD whether a free cluster count is stored, if it is stored
 665:FAT32.c       **** //then it will return immediately. Otherwise it will count the total number of
 666:FAT32.c       **** //free clusters, which takes time
 667:FAT32.c       **** //****************************************************************************
 668:FAT32.c       **** void memoryStatistics (void)
 669:FAT32.c       **** {
 670:FAT32.c       **** unsigned long freeClusters, totalClusterCount, cluster;
 671:FAT32.c       **** unsigned long totalMemory, freeMemory;
 672:FAT32.c       **** unsigned long sector, *value;
 673:FAT32.c       **** unsigned int i;
 674:FAT32.c       **** 
 675:FAT32.c       **** 
 676:FAT32.c       **** totalMemory = totalClusters * sectorPerCluster / 1024;
 677:FAT32.c       **** totalMemory *= bytesPerSector;
 678:FAT32.c       **** 
 679:FAT32.c       **** TX_NEWLINE;
 680:FAT32.c       **** TX_NEWLINE;
 681:FAT32.c       **** transmitString_F(PSTR("Total Memory: "));
 682:FAT32.c       **** 
 683:FAT32.c       **** displayMemory (HIGH, totalMemory);
 684:FAT32.c       **** 
 685:FAT32.c       **** freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
 686:FAT32.c       **** //freeClusters = 0xffffffff;    
 687:FAT32.c       **** 
 688:FAT32.c       **** if(freeClusters > totalClusters)
 689:FAT32.c       **** {
 690:FAT32.c       ****    freeClusterCountUpdated = 0;
 691:FAT32.c       ****    freeClusters = 0;
 692:FAT32.c       ****    totalClusterCount = 0;
 693:FAT32.c       ****    cluster = rootCluster;    
 694:FAT32.c       ****     while(1)
 695:FAT32.c       ****     {
 696:FAT32.c       ****       sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector) ;
 697:FAT32.c       ****       SD_readSingleBlock(sector);
 698:FAT32.c       ****       for(i=0; i<128; i++)
 699:FAT32.c       ****       {
 700:FAT32.c       ****            value = (unsigned long *) &buffer[i*4];
 701:FAT32.c       ****          if(((*value)& 0x0fffffff) == 0)
 702:FAT32.c       ****             freeClusters++;;
 703:FAT32.c       ****         
 704:FAT32.c       ****          totalClusterCount++;
 705:FAT32.c       ****          if(totalClusterCount == (totalClusters+2)) break;
 706:FAT32.c       ****       }  
 707:FAT32.c       ****       if(i < 128) break;
 708:FAT32.c       ****       cluster+=128;
 709:FAT32.c       ****     } 
 710:FAT32.c       **** }
 711:FAT32.c       **** 
 712:FAT32.c       **** if(!freeClusterCountUpdated)
 713:FAT32.c       ****   getSetFreeCluster (TOTAL_FREE, SET, freeClusters); //update FSinfo next free cluster entry
 714:FAT32.c       **** freeClusterCountUpdated = 1;  //set flag
 715:FAT32.c       **** freeMemory = freeClusters * sectorPerCluster / 1024;
 716:FAT32.c       **** freeMemory *= bytesPerSector ;
 717:FAT32.c       **** TX_NEWLINE;
 718:FAT32.c       **** transmitString_F(PSTR(" Free Memory: "));
 719:FAT32.c       **** displayMemory (HIGH, freeMemory);
 720:FAT32.c       **** TX_NEWLINE; 
 721:FAT32.c       **** }
 722:FAT32.c       **** 
 723:FAT32.c       **** //************************************************************
 724:FAT32.c       **** //Function: To convert the unsigned long value of memory into 
 725:FAT32.c       **** //          text string and send to UART
 726:FAT32.c       **** //Arguments: 1. unsigned char flag. If flag is HIGH, memory will be displayed in KBytes, else in By
 727:FAT32.c       **** //			 2. unsigned long memory value
 728:FAT32.c       **** //return: none
 729:FAT32.c       **** //************************************************************
 730:FAT32.c       **** void displayMemory (unsigned char flag, unsigned long memory)
 731:FAT32.c       **** {
 1034               		.loc 1 731 0
 1035               		.cfi_startproc
 1036               	.LVL65:
 1037 05c4 9F92      		push r9
 1038               	.LCFI50:
 1039               		.cfi_def_cfa_offset 3
 1040               		.cfi_offset 9, -2
 1041 05c6 AF92      		push r10
 1042               	.LCFI51:
 1043               		.cfi_def_cfa_offset 4
 1044               		.cfi_offset 10, -3
 1045 05c8 BF92      		push r11
 1046               	.LCFI52:
 1047               		.cfi_def_cfa_offset 5
 1048               		.cfi_offset 11, -4
 1049 05ca CF92      		push r12
 1050               	.LCFI53:
 1051               		.cfi_def_cfa_offset 6
 1052               		.cfi_offset 12, -5
 1053 05cc DF92      		push r13
 1054               	.LCFI54:
 1055               		.cfi_def_cfa_offset 7
 1056               		.cfi_offset 13, -6
 1057 05ce EF92      		push r14
 1058               	.LCFI55:
 1059               		.cfi_def_cfa_offset 8
 1060               		.cfi_offset 14, -7
 1061 05d0 FF92      		push r15
 1062               	.LCFI56:
 1063               		.cfi_def_cfa_offset 9
 1064               		.cfi_offset 15, -8
 1065 05d2 0F93      		push r16
 1066               	.LCFI57:
 1067               		.cfi_def_cfa_offset 10
 1068               		.cfi_offset 16, -9
 1069 05d4 1F93      		push r17
 1070               	.LCFI58:
 1071               		.cfi_def_cfa_offset 11
 1072               		.cfi_offset 17, -10
 1073 05d6 CF93      		push r28
 1074               	.LCFI59:
 1075               		.cfi_def_cfa_offset 12
 1076               		.cfi_offset 28, -11
 1077 05d8 DF93      		push r29
 1078               	.LCFI60:
 1079               		.cfi_def_cfa_offset 13
 1080               		.cfi_offset 29, -12
 1081 05da CDB7      		in r28,__SP_L__
 1082 05dc DEB7      		in r29,__SP_H__
 1083               	.LCFI61:
 1084               		.cfi_def_cfa_register 28
 1085 05de 6497      		sbiw r28,20
 1086               	.LCFI62:
 1087               		.cfi_def_cfa_offset 33
 1088 05e0 0FB6      		in __tmp_reg__,__SREG__
 1089 05e2 F894      		cli
 1090 05e4 DEBF      		out __SP_H__,r29
 1091 05e6 0FBE      		out __SREG__,__tmp_reg__
 1092 05e8 CDBF      		out __SP_L__,r28
 1093               	/* prologue: function */
 1094               	/* frame size = 20 */
 1095               	/* stack size = 31 */
 1096               	.L__stack_usage = 31
 1097 05ea A82E      		mov r10,r24
 732:FAT32.c       ****   unsigned char memoryString[] = "              Bytes"; //19 character long string for memory displ
 1098               		.loc 1 732 0
 1099 05ec 94E1      		ldi r25,lo8(20)
 1100 05ee E0E0      		ldi r30,lo8(.LC0)
 1101 05f0 F0E0      		ldi r31,hi8(.LC0)
 1102 05f2 DE01      		movw r26,r28
 1103 05f4 1196      		adiw r26,1
 1104               		0:
 1105 05f6 0190      		ld r0,Z+
 1106 05f8 0D92      		st X+,r0
 1107 05fa 9A95      		dec r25
 1108 05fc 01F4      		brne 0b
 1109               	.LVL66:
 733:FAT32.c       ****   unsigned char i;
 734:FAT32.c       ****   for(i=12; i>0; i--) //converting freeMemory into ASCII string
 1110               		.loc 1 734 0
 1111 05fe ECE0      		ldi r30,lo8(12)
 1112 0600 BE2E      		mov r11,r30
 735:FAT32.c       ****   {
 736:FAT32.c       ****     if(i==5 || i==9) 
 737:FAT32.c       **** 	{
 738:FAT32.c       **** 	   memoryString[i-1] = ',';  
 1113               		.loc 1 738 0
 1114 0602 FCE2      		ldi r31,lo8(44)
 1115 0604 9F2E      		mov r9,r31
 739:FAT32.c       **** 	   i--;
 740:FAT32.c       **** 	}
 741:FAT32.c       ****     memoryString[i-1] = (memory % 10) | 0x30;
 1116               		.loc 1 741 0
 1117 0606 AAE0      		ldi r26,lo8(10)
 1118 0608 CA2E      		mov r12,r26
 1119 060a D12C      		mov r13,__zero_reg__
 1120 060c E12C      		mov r14,__zero_reg__
 1121 060e F12C      		mov r15,__zero_reg__
 1122               	.LVL67:
 1123               	.L70:
 736:FAT32.c       ****     if(i==5 || i==9) 
 1124               		.loc 1 736 0
 1125 0610 85E0      		ldi r24,lo8(5)
 1126 0612 B816      		cp r11,r24
 1127 0614 01F0      		breq .L67
 736:FAT32.c       ****     if(i==5 || i==9) 
 1128               		.loc 1 736 0 is_stmt 0 discriminator 1
 1129 0616 E9E0      		ldi r30,lo8(9)
 1130 0618 BE12      		cpse r11,r30
 1131 061a 00C0      		rjmp .L68
 1132               	.L67:
 738:FAT32.c       **** 	   memoryString[i-1] = ',';  
 1133               		.loc 1 738 0 is_stmt 1
 1134 061c FE01      		movw r30,r28
 1135 061e EB0D      		add r30,r11
 1136 0620 F11D      		adc r31,__zero_reg__
 1137 0622 9082      		st Z,r9
 739:FAT32.c       **** 	   i--;
 1138               		.loc 1 739 0
 1139 0624 BA94      		dec r11
 1140               	.LVL68:
 1141               	.L68:
 1142               		.loc 1 741 0
 1143 0626 8E01      		movw r16,r28
 1144 0628 0B0D      		add r16,r11
 1145 062a 111D      		adc r17,__zero_reg__
 1146 062c CB01      		movw r24,r22
 1147 062e BA01      		movw r22,r20
 1148 0630 A701      		movw r20,r14
 1149 0632 9601      		movw r18,r12
 1150 0634 0E94 0000 		call __udivmodsi4
 1151 0638 CA01      		movw r24,r20
 1152 063a 6063      		ori r22,lo8(48)
 1153 063c F801      		movw r30,r16
 1154 063e 6083      		st Z,r22
 742:FAT32.c       ****     memory /= 10;
 1155               		.loc 1 742 0
 1156 0640 A901      		movw r20,r18
 1157               	.LVL69:
 1158 0642 BC01      		movw r22,r24
 743:FAT32.c       **** 	if(memory == 0) break;
 1159               		.loc 1 743 0
 1160 0644 4115      		cp r20,__zero_reg__
 1161 0646 5105      		cpc r21,__zero_reg__
 1162 0648 6105      		cpc r22,__zero_reg__
 1163 064a 7105      		cpc r23,__zero_reg__
 1164 064c 01F0      		breq .L69
 734:FAT32.c       ****   for(i=12; i>0; i--) //converting freeMemory into ASCII string
 1165               		.loc 1 734 0
 1166 064e BA94      		dec r11
 1167               	.LVL70:
 1168 0650 01F4      		brne .L70
 1169               	.L69:
 744:FAT32.c       ****   }
 745:FAT32.c       ****   if(flag == HIGH)  memoryString[13] = 'K';
 1170               		.loc 1 745 0
 1171 0652 F1E0      		ldi r31,lo8(1)
 1172 0654 AF12      		cpse r10,r31
 1173 0656 00C0      		rjmp .L71
 1174               		.loc 1 745 0 is_stmt 0 discriminator 1
 1175 0658 8BE4      		ldi r24,lo8(75)
 1176 065a 8E87      		std Y+14,r24
 1177               	.L71:
 746:FAT32.c       ****   transmitString(memoryString);
 1178               		.loc 1 746 0 is_stmt 1
 1179 065c CE01      		movw r24,r28
 1180 065e 0196      		adiw r24,1
 1181 0660 0E94 0000 		call transmitString
 1182               	.LVL71:
 1183               	/* epilogue start */
 747:FAT32.c       **** }
 1184               		.loc 1 747 0
 1185 0664 6496      		adiw r28,20
 1186 0666 0FB6      		in __tmp_reg__,__SREG__
 1187 0668 F894      		cli
 1188 066a DEBF      		out __SP_H__,r29
 1189 066c 0FBE      		out __SREG__,__tmp_reg__
 1190 066e CDBF      		out __SP_L__,r28
 1191 0670 DF91      		pop r29
 1192 0672 CF91      		pop r28
 1193 0674 1F91      		pop r17
 1194 0676 0F91      		pop r16
 1195 0678 FF90      		pop r15
 1196 067a EF90      		pop r14
 1197 067c DF90      		pop r13
 1198 067e CF90      		pop r12
 1199 0680 BF90      		pop r11
 1200               	.LVL72:
 1201 0682 AF90      		pop r10
 1202               	.LVL73:
 1203 0684 9F90      		pop r9
 1204 0686 0895      		ret
 1205               		.cfi_endproc
 1206               	.LFE11:
 1208               	.global	memoryStatistics
 1210               	memoryStatistics:
 1211               	.LFB10:
 669:FAT32.c       **** {
 1212               		.loc 1 669 0
 1213               		.cfi_startproc
 1214 0688 4F92      		push r4
 1215               	.LCFI63:
 1216               		.cfi_def_cfa_offset 3
 1217               		.cfi_offset 4, -2
 1218 068a 5F92      		push r5
 1219               	.LCFI64:
 1220               		.cfi_def_cfa_offset 4
 1221               		.cfi_offset 5, -3
 1222 068c 6F92      		push r6
 1223               	.LCFI65:
 1224               		.cfi_def_cfa_offset 5
 1225               		.cfi_offset 6, -4
 1226 068e 7F92      		push r7
 1227               	.LCFI66:
 1228               		.cfi_def_cfa_offset 6
 1229               		.cfi_offset 7, -5
 1230 0690 8F92      		push r8
 1231               	.LCFI67:
 1232               		.cfi_def_cfa_offset 7
 1233               		.cfi_offset 8, -6
 1234 0692 9F92      		push r9
 1235               	.LCFI68:
 1236               		.cfi_def_cfa_offset 8
 1237               		.cfi_offset 9, -7
 1238 0694 AF92      		push r10
 1239               	.LCFI69:
 1240               		.cfi_def_cfa_offset 9
 1241               		.cfi_offset 10, -8
 1242 0696 BF92      		push r11
 1243               	.LCFI70:
 1244               		.cfi_def_cfa_offset 10
 1245               		.cfi_offset 11, -9
 1246 0698 CF92      		push r12
 1247               	.LCFI71:
 1248               		.cfi_def_cfa_offset 11
 1249               		.cfi_offset 12, -10
 1250 069a DF92      		push r13
 1251               	.LCFI72:
 1252               		.cfi_def_cfa_offset 12
 1253               		.cfi_offset 13, -11
 1254 069c EF92      		push r14
 1255               	.LCFI73:
 1256               		.cfi_def_cfa_offset 13
 1257               		.cfi_offset 14, -12
 1258 069e FF92      		push r15
 1259               	.LCFI74:
 1260               		.cfi_def_cfa_offset 14
 1261               		.cfi_offset 15, -13
 1262 06a0 CF93      		push r28
 1263               	.LCFI75:
 1264               		.cfi_def_cfa_offset 15
 1265               		.cfi_offset 28, -14
 1266 06a2 DF93      		push r29
 1267               	.LCFI76:
 1268               		.cfi_def_cfa_offset 16
 1269               		.cfi_offset 29, -15
 1270 06a4 CDB7      		in r28,__SP_L__
 1271 06a6 DEB7      		in r29,__SP_H__
 1272               	.LCFI77:
 1273               		.cfi_def_cfa_register 28
 1274 06a8 2897      		sbiw r28,8
 1275               	.LCFI78:
 1276               		.cfi_def_cfa_offset 24
 1277 06aa 0FB6      		in __tmp_reg__,__SREG__
 1278 06ac F894      		cli
 1279 06ae DEBF      		out __SP_H__,r29
 1280 06b0 0FBE      		out __SREG__,__tmp_reg__
 1281 06b2 CDBF      		out __SP_L__,r28
 1282               	/* prologue: function */
 1283               	/* frame size = 8 */
 1284               	/* stack size = 22 */
 1285               	.L__stack_usage = 22
 676:FAT32.c       **** totalMemory = totalClusters * sectorPerCluster / 1024;
 1286               		.loc 1 676 0
 1287 06b4 2091 0000 		lds r18,totalClusters
 1288 06b8 3091 0000 		lds r19,totalClusters+1
 1289 06bc 4091 0000 		lds r20,totalClusters+2
 1290 06c0 5091 0000 		lds r21,totalClusters+3
 1291 06c4 A091 0000 		lds r26,sectorPerCluster
 1292 06c8 B091 0000 		lds r27,sectorPerCluster+1
 1293 06cc 0E94 0000 		call __muluhisi3
 1294 06d0 9B01      		movw r18,r22
 1295 06d2 AC01      		movw r20,r24
 1296 06d4 9AE0      		ldi r25,10
 1297               		1:
 1298 06d6 5695      		lsr r21
 1299 06d8 4795      		ror r20
 1300 06da 3795      		ror r19
 1301 06dc 2795      		ror r18
 1302 06de 9A95      		dec r25
 1303 06e0 01F4      		brne 1b
 1304               	.LVL74:
 677:FAT32.c       **** totalMemory *= bytesPerSector;
 1305               		.loc 1 677 0
 1306 06e2 A091 0000 		lds r26,bytesPerSector
 1307 06e6 B091 0000 		lds r27,bytesPerSector+1
 1308 06ea 0E94 0000 		call __muluhisi3
 1309 06ee AB01      		movw r20,r22
 1310 06f0 BC01      		movw r22,r24
 1311               	.LVL75:
 679:FAT32.c       **** TX_NEWLINE;
 1312               		.loc 1 679 0
 1313 06f2 8DE0      		ldi r24,lo8(13)
 1314 06f4 4D83      		std Y+5,r20
 1315 06f6 5E83      		std Y+6,r21
 1316 06f8 6F83      		std Y+7,r22
 1317 06fa 7887      		std Y+8,r23
 1318 06fc 0E94 0000 		call transmitByte
 1319               	.LVL76:
 1320 0700 8AE0      		ldi r24,lo8(10)
 1321 0702 0E94 0000 		call transmitByte
 1322               	.LVL77:
 680:FAT32.c       **** TX_NEWLINE;
 1323               		.loc 1 680 0
 1324 0706 8DE0      		ldi r24,lo8(13)
 1325 0708 0E94 0000 		call transmitByte
 1326               	.LVL78:
 1327 070c 8AE0      		ldi r24,lo8(10)
 1328 070e 0E94 0000 		call transmitByte
 1329               	.LVL79:
 681:FAT32.c       **** transmitString_F(PSTR("Total Memory: "));
 1330               		.loc 1 681 0
 1331 0712 80E0      		ldi r24,lo8(__c.2038)
 1332 0714 90E0      		ldi r25,hi8(__c.2038)
 1333 0716 0E94 0000 		call transmitString_F
 1334               	.LVL80:
 683:FAT32.c       **** displayMemory (HIGH, totalMemory);
 1335               		.loc 1 683 0
 1336 071a 4D81      		ldd r20,Y+5
 1337 071c 5E81      		ldd r21,Y+6
 1338 071e 6F81      		ldd r22,Y+7
 1339 0720 7885      		ldd r23,Y+8
 1340 0722 81E0      		ldi r24,lo8(1)
 1341 0724 0E94 0000 		call displayMemory
 1342               	.LVL81:
 685:FAT32.c       **** freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
 1343               		.loc 1 685 0
 1344 0728 20E0      		ldi r18,0
 1345 072a 30E0      		ldi r19,0
 1346 072c A901      		movw r20,r18
 1347 072e 60E0      		ldi r22,0
 1348 0730 81E0      		ldi r24,lo8(1)
 1349 0732 0E94 0000 		call getSetFreeCluster
 1350               	.LVL82:
 1351 0736 6B01      		movw r12,r22
 1352 0738 7C01      		movw r14,r24
 1353               	.LVL83:
 688:FAT32.c       **** if(freeClusters > totalClusters)
 1354               		.loc 1 688 0
 1355 073a 8091 0000 		lds r24,totalClusters
 1356 073e 9091 0000 		lds r25,totalClusters+1
 1357 0742 A091 0000 		lds r26,totalClusters+2
 1358 0746 B091 0000 		lds r27,totalClusters+3
 1359 074a 8C15      		cp r24,r12
 1360 074c 9D05      		cpc r25,r13
 1361 074e AE05      		cpc r26,r14
 1362 0750 BF05      		cpc r27,r15
 1363 0752 00F0      		brlo .+2
 1364 0754 00C0      		rjmp .L82
 690:FAT32.c       ****    freeClusterCountUpdated = 0;
 1365               		.loc 1 690 0
 1366 0756 1092 0000 		sts freeClusterCountUpdated,__zero_reg__
 1367               	.LVL84:
 693:FAT32.c       ****    cluster = rootCluster;    
 1368               		.loc 1 693 0
 1369 075a 8090 0000 		lds r8,rootCluster
 1370 075e 9090 0000 		lds r9,rootCluster+1
 1371 0762 A090 0000 		lds r10,rootCluster+2
 1372 0766 B090 0000 		lds r11,rootCluster+3
 1373               	.LVL85:
 1374 076a 82E0      		ldi r24,2
 1375               		1:
 1376 076c 880C      		lsl r8
 1377 076e 991C      		rol r9
 1378 0770 AA1C      		rol r10
 1379 0772 BB1C      		rol r11
 1380 0774 8A95      		dec r24
 1381 0776 01F4      		brne 1b
 1382               	.LVL86:
 692:FAT32.c       ****    totalClusterCount = 0;
 1383               		.loc 1 692 0
 1384 0778 1982      		std Y+1,__zero_reg__
 1385 077a 1A82      		std Y+2,__zero_reg__
 1386 077c 1B82      		std Y+3,__zero_reg__
 1387 077e 1C82      		std Y+4,__zero_reg__
 691:FAT32.c       ****    freeClusters = 0;
 1388               		.loc 1 691 0
 1389 0780 C12C      		mov r12,__zero_reg__
 1390 0782 D12C      		mov r13,__zero_reg__
 1391 0784 7601      		movw r14,r12
 1392               	.LVL87:
 1393               	.L87:
 696:FAT32.c       ****       sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector) ;
 1394               		.loc 1 696 0
 1395 0786 8091 0000 		lds r24,reservedSectorCount
 1396 078a 9091 0000 		lds r25,reservedSectorCount+1
 1397 078e 2091 0000 		lds r18,bytesPerSector
 1398 0792 3091 0000 		lds r19,bytesPerSector+1
 1399               	.LVL88:
 1400 0796 4090 0000 		lds r4,unusedSectors
 1401 079a 5090 0000 		lds r5,unusedSectors+1
 1402 079e 6090 0000 		lds r6,unusedSectors+2
 1403 07a2 7090 0000 		lds r7,unusedSectors+3
 1404 07a6 480E      		add r4,r24
 1405 07a8 591E      		adc r5,r25
 1406 07aa 611C      		adc r6,__zero_reg__
 1407 07ac 711C      		adc r7,__zero_reg__
 1408 07ae 40E0      		ldi r20,0
 1409 07b0 50E0      		ldi r21,0
 1410 07b2 C501      		movw r24,r10
 1411 07b4 B401      		movw r22,r8
 1412 07b6 0E94 0000 		call __udivmodsi4
 1413               	.LVL89:
 1414 07ba 420E      		add r4,r18
 1415 07bc 531E      		adc r5,r19
 1416 07be 641E      		adc r6,r20
 1417 07c0 751E      		adc r7,r21
 697:FAT32.c       ****       SD_readSingleBlock(sector);
 1418               		.loc 1 697 0
 1419 07c2 C301      		movw r24,r6
 1420 07c4 B201      		movw r22,r4
 1421 07c6 0E94 0000 		call SD_readSingleBlock
 1422               	.LVL90:
 1423 07ca 60E0      		ldi r22,lo8(buffer)
 1424 07cc 70E0      		ldi r23,hi8(buffer)
 1425               	.LVL91:
 1426               	.L85:
 701:FAT32.c       ****          if(((*value)& 0x0fffffff) == 0)
 1427               		.loc 1 701 0
 1428 07ce FB01      		movw r30,r22
 1429 07d0 8191      		ld r24,Z+
 1430 07d2 9191      		ld r25,Z+
 1431 07d4 A191      		ld r26,Z+
 1432 07d6 B191      		ld r27,Z+
 1433 07d8 BF01      		movw r22,r30
 1434               	.LVL92:
 1435 07da BF70      		andi r27,15
 1436 07dc 892B      		or r24,r25
 1437 07de 8A2B      		or r24,r26
 1438 07e0 8B2B      		or r24,r27
 1439 07e2 01F4      		brne .L83
 702:FAT32.c       ****             freeClusters++;;
 1440               		.loc 1 702 0
 1441 07e4 FFEF      		ldi r31,-1
 1442 07e6 CF1A      		sub r12,r31
 1443 07e8 DF0A      		sbc r13,r31
 1444 07ea EF0A      		sbc r14,r31
 1445 07ec FF0A      		sbc r15,r31
 1446               	.LVL93:
 1447               	.L83:
 704:FAT32.c       ****          totalClusterCount++;
 1448               		.loc 1 704 0
 1449 07ee 2981      		ldd r18,Y+1
 1450 07f0 3A81      		ldd r19,Y+2
 1451 07f2 4B81      		ldd r20,Y+3
 1452 07f4 5C81      		ldd r21,Y+4
 1453 07f6 2F5F      		subi r18,-1
 1454 07f8 3F4F      		sbci r19,-1
 1455 07fa 4F4F      		sbci r20,-1
 1456 07fc 5F4F      		sbci r21,-1
 1457 07fe 2983      		std Y+1,r18
 1458 0800 3A83      		std Y+2,r19
 1459 0802 4B83      		std Y+3,r20
 1460 0804 5C83      		std Y+4,r21
 1461               	.LVL94:
 705:FAT32.c       ****          if(totalClusterCount == (totalClusters+2)) break;
 1462               		.loc 1 705 0
 1463 0806 8091 0000 		lds r24,totalClusters
 1464 080a 9091 0000 		lds r25,totalClusters+1
 1465 080e A091 0000 		lds r26,totalClusters+2
 1466 0812 B091 0000 		lds r27,totalClusters+3
 1467 0816 0296      		adiw r24,2
 1468 0818 A11D      		adc r26,__zero_reg__
 1469 081a B11D      		adc r27,__zero_reg__
 1470 081c 2817      		cp r18,r24
 1471 081e 3907      		cpc r19,r25
 1472 0820 4A07      		cpc r20,r26
 1473 0822 5B07      		cpc r21,r27
 1474 0824 01F0      		breq .L82
 698:FAT32.c       ****       for(i=0; i<128; i++)
 1475               		.loc 1 698 0
 1476 0826 30E0      		ldi r19,hi8(buffer+512)
 1477 0828 6030      		cpi r22,lo8(buffer+512)
 1478 082a 7307      		cpc r23,r19
 1479 082c 01F4      		brne .L85
 1480 082e 42E0      		ldi r20,2
 1481 0830 940E      		add r9,r20
 1482 0832 A11C      		adc r10,__zero_reg__
 1483 0834 B11C      		adc r11,__zero_reg__
 709:FAT32.c       ****     } 
 1484               		.loc 1 709 0
 1485 0836 00C0      		rjmp .L87
 1486               	.LVL95:
 1487               	.L82:
 712:FAT32.c       **** if(!freeClusterCountUpdated)
 1488               		.loc 1 712 0
 1489 0838 8091 0000 		lds r24,freeClusterCountUpdated
 1490 083c 8111      		cpse r24,__zero_reg__
 1491 083e 00C0      		rjmp .L86
 713:FAT32.c       ****   getSetFreeCluster (TOTAL_FREE, SET, freeClusters); //update FSinfo next free cluster entry
 1492               		.loc 1 713 0
 1493 0840 A701      		movw r20,r14
 1494 0842 9601      		movw r18,r12
 1495 0844 61E0      		ldi r22,lo8(1)
 1496 0846 81E0      		ldi r24,lo8(1)
 1497 0848 0E94 0000 		call getSetFreeCluster
 1498               	.LVL96:
 1499               	.L86:
 714:FAT32.c       **** freeClusterCountUpdated = 1;  //set flag
 1500               		.loc 1 714 0
 1501 084c 81E0      		ldi r24,lo8(1)
 1502 084e 8093 0000 		sts freeClusterCountUpdated,r24
 715:FAT32.c       **** freeMemory = freeClusters * sectorPerCluster / 1024;
 1503               		.loc 1 715 0
 1504 0852 A091 0000 		lds r26,sectorPerCluster
 1505 0856 B091 0000 		lds r27,sectorPerCluster+1
 1506 085a A701      		movw r20,r14
 1507 085c 9601      		movw r18,r12
 1508 085e 0E94 0000 		call __muluhisi3
 1509 0862 9B01      		movw r18,r22
 1510 0864 AC01      		movw r20,r24
 1511 0866 BAE0      		ldi r27,10
 1512               		1:
 1513 0868 5695      		lsr r21
 1514 086a 4795      		ror r20
 1515 086c 3795      		ror r19
 1516 086e 2795      		ror r18
 1517 0870 BA95      		dec r27
 1518 0872 01F4      		brne 1b
 1519               	.LVL97:
 716:FAT32.c       **** freeMemory *= bytesPerSector ;
 1520               		.loc 1 716 0
 1521 0874 A091 0000 		lds r26,bytesPerSector
 1522 0878 B091 0000 		lds r27,bytesPerSector+1
 1523 087c 0E94 0000 		call __muluhisi3
 1524 0880 AB01      		movw r20,r22
 1525 0882 BC01      		movw r22,r24
 1526               	.LVL98:
 717:FAT32.c       **** TX_NEWLINE;
 1527               		.loc 1 717 0
 1528 0884 8DE0      		ldi r24,lo8(13)
 1529 0886 4D83      		std Y+5,r20
 1530 0888 5E83      		std Y+6,r21
 1531 088a 6F83      		std Y+7,r22
 1532 088c 7887      		std Y+8,r23
 1533 088e 0E94 0000 		call transmitByte
 1534               	.LVL99:
 1535 0892 8AE0      		ldi r24,lo8(10)
 1536 0894 0E94 0000 		call transmitByte
 1537               	.LVL100:
 718:FAT32.c       **** transmitString_F(PSTR(" Free Memory: "));
 1538               		.loc 1 718 0
 1539 0898 80E0      		ldi r24,lo8(__c.2045)
 1540 089a 90E0      		ldi r25,hi8(__c.2045)
 1541 089c 0E94 0000 		call transmitString_F
 1542               	.LVL101:
 719:FAT32.c       **** displayMemory (HIGH, freeMemory);
 1543               		.loc 1 719 0
 1544 08a0 4D81      		ldd r20,Y+5
 1545 08a2 5E81      		ldd r21,Y+6
 1546 08a4 6F81      		ldd r22,Y+7
 1547 08a6 7885      		ldd r23,Y+8
 1548 08a8 81E0      		ldi r24,lo8(1)
 1549 08aa 0E94 0000 		call displayMemory
 1550               	.LVL102:
 720:FAT32.c       **** TX_NEWLINE; 
 1551               		.loc 1 720 0
 1552 08ae 8DE0      		ldi r24,lo8(13)
 1553 08b0 0E94 0000 		call transmitByte
 1554               	.LVL103:
 1555 08b4 8AE0      		ldi r24,lo8(10)
 1556               	/* epilogue start */
 721:FAT32.c       **** }
 1557               		.loc 1 721 0
 1558 08b6 2896      		adiw r28,8
 1559 08b8 0FB6      		in __tmp_reg__,__SREG__
 1560 08ba F894      		cli
 1561 08bc DEBF      		out __SP_H__,r29
 1562 08be 0FBE      		out __SREG__,__tmp_reg__
 1563 08c0 CDBF      		out __SP_L__,r28
 1564 08c2 DF91      		pop r29
 1565 08c4 CF91      		pop r28
 1566 08c6 FF90      		pop r15
 1567 08c8 EF90      		pop r14
 1568 08ca DF90      		pop r13
 1569 08cc CF90      		pop r12
 1570               	.LVL104:
 1571 08ce BF90      		pop r11
 1572 08d0 AF90      		pop r10
 1573 08d2 9F90      		pop r9
 1574 08d4 8F90      		pop r8
 1575 08d6 7F90      		pop r7
 1576 08d8 6F90      		pop r6
 1577 08da 5F90      		pop r5
 1578 08dc 4F90      		pop r4
 720:FAT32.c       **** TX_NEWLINE; 
 1579               		.loc 1 720 0
 1580 08de 0C94 0000 		jmp transmitByte
 1581               	.LVL105:
 1582               		.cfi_endproc
 1583               	.LFE10:
 1585               	.global	freeMemoryUpdate
 1587               	freeMemoryUpdate:
 1588               	.LFB13:
 748:FAT32.c       **** 
 749:FAT32.c       **** //********************************************************************
 750:FAT32.c       **** //Function: to delete a specified file from the root directory
 751:FAT32.c       **** //Arguments: pointer to the file name
 752:FAT32.c       **** //return: none
 753:FAT32.c       **** //********************************************************************
 754:FAT32.c       **** void deleteFile (unsigned char *fileName)
 755:FAT32.c       **** {
 756:FAT32.c       ****   unsigned char error;
 757:FAT32.c       **** 
 758:FAT32.c       ****   error = convertFileName (fileName);
 759:FAT32.c       ****   if(error) return;
 760:FAT32.c       **** 
 761:FAT32.c       ****   findFiles (DELETE, fileName);
 762:FAT32.c       **** }
 763:FAT32.c       **** 
 764:FAT32.c       **** //********************************************************************
 765:FAT32.c       **** //Function: update the free memory count in the FSinfo sector. 
 766:FAT32.c       **** //			Whenever a file is deleted or created, this function will be called
 767:FAT32.c       **** //			to ADD or REMOVE clusters occupied by the file
 768:FAT32.c       **** //Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
 769:FAT32.c       **** //return: none
 770:FAT32.c       **** //********************************************************************
 771:FAT32.c       **** void freeMemoryUpdate (unsigned char flag, unsigned long size)
 772:FAT32.c       **** {
 1589               		.loc 1 772 0
 1590               		.cfi_startproc
 1591               	.LVL106:
 1592 08e2 CF92      		push r12
 1593               	.LCFI79:
 1594               		.cfi_def_cfa_offset 3
 1595               		.cfi_offset 12, -2
 1596 08e4 DF92      		push r13
 1597               	.LCFI80:
 1598               		.cfi_def_cfa_offset 4
 1599               		.cfi_offset 13, -3
 1600 08e6 EF92      		push r14
 1601               	.LCFI81:
 1602               		.cfi_def_cfa_offset 5
 1603               		.cfi_offset 14, -4
 1604 08e8 FF92      		push r15
 1605               	.LCFI82:
 1606               		.cfi_def_cfa_offset 6
 1607               		.cfi_offset 15, -5
 1608 08ea 0F93      		push r16
 1609               	.LCFI83:
 1610               		.cfi_def_cfa_offset 7
 1611               		.cfi_offset 16, -6
 1612 08ec 1F93      		push r17
 1613               	.LCFI84:
 1614               		.cfi_def_cfa_offset 8
 1615               		.cfi_offset 17, -7
 1616 08ee CF93      		push r28
 1617               	.LCFI85:
 1618               		.cfi_def_cfa_offset 9
 1619               		.cfi_offset 28, -8
 1620               	/* prologue: function */
 1621               	/* frame size = 0 */
 1622               	/* stack size = 7 */
 1623               	.L__stack_usage = 7
 1624 08f0 C82F      		mov r28,r24
 773:FAT32.c       ****   unsigned long freeClusters;
 774:FAT32.c       ****   //convert file size into number of clusters occupied
 775:FAT32.c       ****   if((size % 512) == 0) size = size / 512;
 1625               		.loc 1 775 0
 1626 08f2 8A01      		movw r16,r20
 1627 08f4 9B01      		movw r18,r22
 1628 08f6 1170      		andi r17,1
 1629 08f8 2227      		clr r18
 1630 08fa 3327      		clr r19
 1631 08fc 6A01      		movw r12,r20
 1632 08fe 7B01      		movw r14,r22
 1633 0900 49E0      		ldi r20,9
 1634               		1:
 1635 0902 F694      		lsr r15
 1636 0904 E794      		ror r14
 1637 0906 D794      		ror r13
 1638 0908 C794      		ror r12
 1639 090a 4A95      		dec r20
 1640 090c 01F4      		brne 1b
 1641               	.LVL107:
 1642 090e 012B      		or r16,r17
 1643 0910 022B      		or r16,r18
 1644 0912 032B      		or r16,r19
 1645 0914 01F0      		breq .L90
 776:FAT32.c       ****   else size = (size / 512) +1;
 1646               		.loc 1 776 0
 1647 0916 8FEF      		ldi r24,-1
 1648 0918 C81A      		sub r12,r24
 1649 091a D80A      		sbc r13,r24
 1650 091c E80A      		sbc r14,r24
 1651 091e F80A      		sbc r15,r24
 1652               	.LVL108:
 1653               	.L90:
 777:FAT32.c       ****   if((size % 8) == 0) size = size / 8;
 1654               		.loc 1 777 0
 1655 0920 B701      		movw r22,r14
 1656 0922 A601      		movw r20,r12
 1657 0924 4770      		andi r20,7
 1658 0926 5527      		clr r21
 1659 0928 6627      		clr r22
 1660 092a 7727      		clr r23
 1661 092c 23E0      		ldi r18,3
 1662               		1:
 1663 092e F694      		lsr r15
 1664 0930 E794      		ror r14
 1665 0932 D794      		ror r13
 1666 0934 C794      		ror r12
 1667 0936 2A95      		dec r18
 1668 0938 01F4      		brne 1b
 1669               	.LVL109:
 1670 093a 452B      		or r20,r21
 1671 093c 462B      		or r20,r22
 1672 093e 472B      		or r20,r23
 1673 0940 01F0      		breq .L92
 778:FAT32.c       ****   else size = (size / 8) +1;
 1674               		.loc 1 778 0
 1675 0942 8FEF      		ldi r24,-1
 1676 0944 C81A      		sub r12,r24
 1677 0946 D80A      		sbc r13,r24
 1678 0948 E80A      		sbc r14,r24
 1679 094a F80A      		sbc r15,r24
 1680               	.LVL110:
 1681               	.L92:
 779:FAT32.c       **** 
 780:FAT32.c       ****   if(freeClusterCountUpdated)
 1682               		.loc 1 780 0
 1683 094c 8091 0000 		lds r24,freeClusterCountUpdated
 1684 0950 8823      		tst r24
 1685 0952 01F0      		breq .L88
 781:FAT32.c       ****   {
 782:FAT32.c       **** 	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
 1686               		.loc 1 782 0
 1687 0954 20E0      		ldi r18,0
 1688 0956 30E0      		ldi r19,0
 1689 0958 A901      		movw r20,r18
 1690 095a 60E0      		ldi r22,0
 1691 095c 81E0      		ldi r24,lo8(1)
 1692 095e 0E94 0000 		call getSetFreeCluster
 1693               	.LVL111:
 783:FAT32.c       **** 	if(flag == ADD)
 784:FAT32.c       ****   	   freeClusters = freeClusters + size;
 1694               		.loc 1 784 0
 1695 0962 9B01      		movw r18,r22
 1696 0964 AC01      		movw r20,r24
 783:FAT32.c       **** 	if(flag == ADD)
 1697               		.loc 1 783 0
 1698 0966 C111      		cpse r28,__zero_reg__
 1699 0968 00C0      		rjmp .L94
 1700               		.loc 1 784 0
 1701 096a 2C0D      		add r18,r12
 1702 096c 3D1D      		adc r19,r13
 1703 096e 4E1D      		adc r20,r14
 1704 0970 5F1D      		adc r21,r15
 1705               	.LVL112:
 1706 0972 00C0      		rjmp .L95
 1707               	.L94:
 785:FAT32.c       **** 	else  //when flag = REMOVE
 786:FAT32.c       **** 	   freeClusters = freeClusters - size;
 1708               		.loc 1 786 0
 1709 0974 2C19      		sub r18,r12
 1710 0976 3D09      		sbc r19,r13
 1711 0978 4E09      		sbc r20,r14
 1712 097a 5F09      		sbc r21,r15
 1713               	.LVL113:
 1714               	.L95:
 787:FAT32.c       **** 	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
 1715               		.loc 1 787 0
 1716 097c 61E0      		ldi r22,lo8(1)
 1717 097e 81E0      		ldi r24,lo8(1)
 1718               	/* epilogue start */
 788:FAT32.c       ****   }
 789:FAT32.c       **** }
 1719               		.loc 1 789 0
 1720 0980 CF91      		pop r28
 1721               	.LVL114:
 1722 0982 1F91      		pop r17
 1723 0984 0F91      		pop r16
 1724 0986 FF90      		pop r15
 1725 0988 EF90      		pop r14
 1726 098a DF90      		pop r13
 1727 098c CF90      		pop r12
 1728               	.LVL115:
 787:FAT32.c       **** 	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
 1729               		.loc 1 787 0
 1730 098e 0C94 0000 		jmp getSetFreeCluster
 1731               	.LVL116:
 1732               	.L88:
 1733               	/* epilogue start */
 1734               		.loc 1 789 0
 1735 0992 CF91      		pop r28
 1736               	.LVL117:
 1737 0994 1F91      		pop r17
 1738 0996 0F91      		pop r16
 1739 0998 FF90      		pop r15
 1740 099a EF90      		pop r14
 1741 099c DF90      		pop r13
 1742 099e CF90      		pop r12
 1743               	.LVL118:
 1744 09a0 0895      		ret
 1745               		.cfi_endproc
 1746               	.LFE13:
 1748               	.global	findFiles
 1750               	findFiles:
 1751               	.LFB5:
 170:FAT32.c       **** {
 1752               		.loc 1 170 0
 1753               		.cfi_startproc
 1754               	.LVL119:
 1755 09a2 2F92      		push r2
 1756               	.LCFI86:
 1757               		.cfi_def_cfa_offset 3
 1758               		.cfi_offset 2, -2
 1759 09a4 3F92      		push r3
 1760               	.LCFI87:
 1761               		.cfi_def_cfa_offset 4
 1762               		.cfi_offset 3, -3
 1763 09a6 4F92      		push r4
 1764               	.LCFI88:
 1765               		.cfi_def_cfa_offset 5
 1766               		.cfi_offset 4, -4
 1767 09a8 5F92      		push r5
 1768               	.LCFI89:
 1769               		.cfi_def_cfa_offset 6
 1770               		.cfi_offset 5, -5
 1771 09aa 6F92      		push r6
 1772               	.LCFI90:
 1773               		.cfi_def_cfa_offset 7
 1774               		.cfi_offset 6, -6
 1775 09ac 7F92      		push r7
 1776               	.LCFI91:
 1777               		.cfi_def_cfa_offset 8
 1778               		.cfi_offset 7, -7
 1779 09ae 8F92      		push r8
 1780               	.LCFI92:
 1781               		.cfi_def_cfa_offset 9
 1782               		.cfi_offset 8, -8
 1783 09b0 9F92      		push r9
 1784               	.LCFI93:
 1785               		.cfi_def_cfa_offset 10
 1786               		.cfi_offset 9, -9
 1787 09b2 AF92      		push r10
 1788               	.LCFI94:
 1789               		.cfi_def_cfa_offset 11
 1790               		.cfi_offset 10, -10
 1791 09b4 BF92      		push r11
 1792               	.LCFI95:
 1793               		.cfi_def_cfa_offset 12
 1794               		.cfi_offset 11, -11
 1795 09b6 CF92      		push r12
 1796               	.LCFI96:
 1797               		.cfi_def_cfa_offset 13
 1798               		.cfi_offset 12, -12
 1799 09b8 DF92      		push r13
 1800               	.LCFI97:
 1801               		.cfi_def_cfa_offset 14
 1802               		.cfi_offset 13, -13
 1803 09ba EF92      		push r14
 1804               	.LCFI98:
 1805               		.cfi_def_cfa_offset 15
 1806               		.cfi_offset 14, -14
 1807 09bc FF92      		push r15
 1808               	.LCFI99:
 1809               		.cfi_def_cfa_offset 16
 1810               		.cfi_offset 15, -15
 1811 09be 0F93      		push r16
 1812               	.LCFI100:
 1813               		.cfi_def_cfa_offset 17
 1814               		.cfi_offset 16, -16
 1815 09c0 1F93      		push r17
 1816               	.LCFI101:
 1817               		.cfi_def_cfa_offset 18
 1818               		.cfi_offset 17, -17
 1819 09c2 CF93      		push r28
 1820               	.LCFI102:
 1821               		.cfi_def_cfa_offset 19
 1822               		.cfi_offset 28, -18
 1823 09c4 DF93      		push r29
 1824               	.LCFI103:
 1825               		.cfi_def_cfa_offset 20
 1826               		.cfi_offset 29, -19
 1827 09c6 CDB7      		in r28,__SP_L__
 1828 09c8 DEB7      		in r29,__SP_H__
 1829               	.LCFI104:
 1830               		.cfi_def_cfa_register 28
 1831 09ca 2B97      		sbiw r28,11
 1832               	.LCFI105:
 1833               		.cfi_def_cfa_offset 31
 1834 09cc 0FB6      		in __tmp_reg__,__SREG__
 1835 09ce F894      		cli
 1836 09d0 DEBF      		out __SP_H__,r29
 1837 09d2 0FBE      		out __SREG__,__tmp_reg__
 1838 09d4 CDBF      		out __SP_L__,r28
 1839               	/* prologue: function */
 1840               	/* frame size = 11 */
 1841               	/* stack size = 29 */
 1842               	.L__stack_usage = 29
 1843 09d6 382E      		mov r3,r24
 1844 09d8 6887      		std Y+8,r22
 1845 09da 272E      		mov r2,r23
 176:FAT32.c       **** cluster = rootCluster; //root cluster
 1846               		.loc 1 176 0
 1847 09dc C090 0000 		lds r12,rootCluster
 1848 09e0 D090 0000 		lds r13,rootCluster+1
 1849 09e4 E090 0000 		lds r14,rootCluster+2
 1850 09e8 F090 0000 		lds r15,rootCluster+3
 1851               	.LVL120:
 199:FAT32.c       ****           if((flag == GET_FILE) || (flag == DELETE))
 1852               		.loc 1 199 0
 1853 09ec 8FEF      		ldi r24,lo8(-1)
 1854               	.LVL121:
 1855 09ee 830D      		add r24,r3
 1856 09f0 8F83      		std Y+7,r24
 1857               	.LVL122:
 1858               	.L117:
 180:FAT32.c       ****    firstSector = getFirstSector (cluster);
 1859               		.loc 1 180 0
 1860 09f2 C701      		movw r24,r14
 1861 09f4 B601      		movw r22,r12
 1862 09f6 0E94 0000 		call getFirstSector
 1863               	.LVL123:
 1864 09fa 6B83      		std Y+3,r22
 1865 09fc 7C83      		std Y+4,r23
 1866 09fe 8D83      		std Y+5,r24
 1867 0a00 9E83      		std Y+6,r25
 1868               	.LVL124:
 182:FAT32.c       ****    for(sector = 0; sector < sectorPerCluster; sector++)
 1869               		.loc 1 182 0
 1870 0a02 412C      		mov r4,__zero_reg__
 1871 0a04 512C      		mov r5,__zero_reg__
 1872 0a06 3201      		movw r6,r4
 1873               	.LVL125:
 1874               	.L97:
 182:FAT32.c       ****    for(sector = 0; sector < sectorPerCluster; sector++)
 1875               		.loc 1 182 0 is_stmt 0 discriminator 1
 1876 0a08 8091 0000 		lds r24,sectorPerCluster
 1877 0a0c 9091 0000 		lds r25,sectorPerCluster+1
 1878 0a10 A0E0      		ldi r26,0
 1879 0a12 B0E0      		ldi r27,0
 1880 0a14 4816      		cp r4,r24
 1881 0a16 5906      		cpc r5,r25
 1882 0a18 6A06      		cpc r6,r26
 1883 0a1a 7B06      		cpc r7,r27
 1884 0a1c 00F0      		brlo .+2
 1885 0a1e 00C0      		rjmp .L132
 184:FAT32.c       ****      SD_readSingleBlock (firstSector + sector);
 1886               		.loc 1 184 0 is_stmt 1
 1887 0a20 8B80      		ldd r8,Y+3
 1888 0a22 9C80      		ldd r9,Y+4
 1889 0a24 AD80      		ldd r10,Y+5
 1890 0a26 BE80      		ldd r11,Y+6
 1891 0a28 840C      		add r8,r4
 1892 0a2a 951C      		adc r9,r5
 1893 0a2c A61C      		adc r10,r6
 1894 0a2e B71C      		adc r11,r7
 1895 0a30 C501      		movw r24,r10
 1896 0a32 B401      		movw r22,r8
 1897 0a34 0E94 0000 		call SD_readSingleBlock
 1898               	.LVL126:
 1899 0a38 00E0      		ldi r16,lo8(buffer+11)
 1900 0a3a 10E0      		ldi r17,hi8(buffer+11)
 187:FAT32.c       ****      for(i=0; i<bytesPerSector; i+=32)
 1901               		.loc 1 187 0
 1902 0a3c A0E0      		ldi r26,lo8(buffer)
 1903 0a3e B0E0      		ldi r27,hi8(buffer)
 1904 0a40 BB87      		std Y+11,r27
 1905 0a42 AA87      		std Y+10,r26
 1906               	.LVL127:
 1907               	.L98:
 1908 0a44 2A85      		ldd r18,Y+10
 1909 0a46 3B85      		ldd r19,Y+11
 1910 0a48 2050      		subi r18,lo8(buffer)
 1911 0a4a 3040      		sbci r19,hi8(buffer)
 1912               	.LVL128:
 187:FAT32.c       ****      for(i=0; i<bytesPerSector; i+=32)
 1913               		.loc 1 187 0 is_stmt 0 discriminator 1
 1914 0a4c 8091 0000 		lds r24,bytesPerSector
 1915 0a50 9091 0000 		lds r25,bytesPerSector+1
 1916 0a54 2817      		cp r18,r24
 1917 0a56 3907      		cpc r19,r25
 1918 0a58 00F0      		brlo .+2
 1919 0a5a 00C0      		rjmp .L133
 1920               	.LVL129:
 191:FAT32.c       ****         if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
 1921               		.loc 1 191 0 is_stmt 1
 1922 0a5c EA85      		ldd r30,Y+10
 1923 0a5e FB85      		ldd r31,Y+11
 1924 0a60 8081      		ld r24,Z
 1925 0a62 8111      		cpse r24,__zero_reg__
 1926 0a64 00C0      		rjmp .L99
 193:FAT32.c       **** 		  if((flag == GET_FILE) || (flag == DELETE))
 1927               		.loc 1 193 0
 1928 0a66 8FEF      		ldi r24,lo8(-1)
 1929 0a68 830D      		add r24,r3
 1930 0a6a 8230      		cpi r24,lo8(2)
 1931 0a6c 00F0      		brlo .+2
 1932 0a6e 00C0      		rjmp .L131
 194:FAT32.c       **** 		      transmitString_F(PSTR("File does not exist!"));
 1933               		.loc 1 194 0
 1934 0a70 80E0      		ldi r24,lo8(__c.1873)
 1935 0a72 90E0      		ldi r25,hi8(__c.1873)
 1936 0a74 00C0      		rjmp .L130
 1937               	.L99:
 197:FAT32.c       **** 		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
 1938               		.loc 1 197 0
 1939 0a76 853E      		cpi r24,lo8(-27)
 1940 0a78 01F4      		brne .+2
 1941 0a7a 00C0      		rjmp .L102
 197:FAT32.c       **** 		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
 1942               		.loc 1 197 0 is_stmt 0 discriminator 1
 1943 0a7c D801      		movw r26,r16
 1944 0a7e 8C91      		ld r24,X
 1945 0a80 8F30      		cpi r24,lo8(15)
 1946 0a82 01F4      		brne .+2
 1947 0a84 00C0      		rjmp .L102
 199:FAT32.c       ****           if((flag == GET_FILE) || (flag == DELETE))
 1948               		.loc 1 199 0 is_stmt 1
 1949 0a86 BF81      		ldd r27,Y+7
 1950 0a88 B230      		cpi r27,lo8(2)
 1951 0a8a 00F4      		brsh .L103
 1952 0a8c E885      		ldd r30,Y+8
 1953 0a8e F22D      		mov r31,r2
 1954 0a90 AA85      		ldd r26,Y+10
 1955 0a92 BB85      		ldd r27,Y+11
 1956               	.L105:
 1957               	.LVL130:
 202:FAT32.c       ****             if(dir->name[j] != fileName[j]) break;
 1958               		.loc 1 202 0
 1959 0a94 9D91      		ld r25,X+
 1960               	.LVL131:
 1961 0a96 8191      		ld r24,Z+
 1962 0a98 9813      		cpse r25,r24
 1963 0a9a 00C0      		rjmp .L102
 1964               	.LVL132:
 201:FAT32.c       ****             for(j=0; j<11; j++)
 1965               		.loc 1 201 0
 1966 0a9c A017      		cp r26,r16
 1967 0a9e B107      		cpc r27,r17
 1968 0aa0 01F4      		brne .L105
 1969 0aa2 00C0      		rjmp .L134
 1970               	.LVL133:
 1971               	.L103:
 246:FAT32.c       **** 		     TX_NEWLINE;
 1972               		.loc 1 246 0
 1973 0aa4 8DE0      		ldi r24,lo8(13)
 1974 0aa6 0E94 0000 		call transmitByte
 1975               	.LVL134:
 1976 0aaa 8AE0      		ldi r24,lo8(10)
 1977 0aac 0E94 0000 		call transmitByte
 1978               	.LVL135:
 1979 0ab0 EA85      		ldd r30,Y+10
 1980 0ab2 FB85      		ldd r31,Y+11
 1981 0ab4 FA83      		std Y+2,r31
 1982 0ab6 E983      		std Y+1,r30
 247:FAT32.c       **** 			 for(j=0; j<11; j++)
 1983               		.loc 1 247 0
 1984 0ab8 90E0      		ldi r25,0
 1985               	.LVL136:
 1986               	.L109:
 250:FAT32.c       **** 			   transmitByte (dir->name[j]);
 1987               		.loc 1 250 0
 1988 0aba A981      		ldd r26,Y+1
 1989 0abc BA81      		ldd r27,Y+2
 1990 0abe 8D91      		ld r24,X+
 1991 0ac0 BA83      		std Y+2,r27
 1992 0ac2 A983      		std Y+1,r26
 1993 0ac4 9987      		std Y+9,r25
 1994 0ac6 0E94 0000 		call transmitByte
 1995               	.LVL137:
 247:FAT32.c       **** 			 for(j=0; j<11; j++)
 1996               		.loc 1 247 0
 1997 0aca 9985      		ldd r25,Y+9
 1998 0acc 9F5F      		subi r25,lo8(-(1))
 1999               	.LVL138:
 2000 0ace 9B30      		cpi r25,lo8(11)
 2001 0ad0 01F0      		breq .L135
 249:FAT32.c       **** 			   if(j == 8) transmitByte(' ');
 2002               		.loc 1 249 0
 2003 0ad2 9830      		cpi r25,lo8(8)
 2004 0ad4 01F4      		brne .L109
 249:FAT32.c       **** 			   if(j == 8) transmitByte(' ');
 2005               		.loc 1 249 0 is_stmt 0 discriminator 1
 2006 0ad6 80E2      		ldi r24,lo8(32)
 2007 0ad8 9987      		std Y+9,r25
 2008 0ada 0E94 0000 		call transmitByte
 2009               	.LVL139:
 2010 0ade 9985      		ldd r25,Y+9
 2011 0ae0 00C0      		rjmp .L109
 2012               	.LVL140:
 2013               	.L135:
 252:FAT32.c       **** 		     transmitString_F (PSTR("   "));
 2014               		.loc 1 252 0 is_stmt 1
 2015 0ae2 80E0      		ldi r24,lo8(__c.1886)
 2016 0ae4 90E0      		ldi r25,hi8(__c.1886)
 2017 0ae6 0E94 0000 		call transmitString_F
 2018               	.LVL141:
 253:FAT32.c       **** 		     if((dir->attrib != 0x10) && (dir->attrib != 0x08))
 2019               		.loc 1 253 0
 2020 0aea F801      		movw r30,r16
 2021 0aec 8081      		ld r24,Z
 2022 0aee 8031      		cpi r24,lo8(16)
 2023 0af0 01F0      		breq .L120
 253:FAT32.c       **** 		     if((dir->attrib != 0x10) && (dir->attrib != 0x08))
 2024               		.loc 1 253 0 is_stmt 0 discriminator 1
 2025 0af2 8830      		cpi r24,lo8(8)
 2026 0af4 01F0      		breq .L121
 255:FAT32.c       **** 			     transmitString_F (PSTR("FILE" ));
 2027               		.loc 1 255 0 is_stmt 1
 2028 0af6 80E0      		ldi r24,lo8(__c.1888)
 2029 0af8 90E0      		ldi r25,hi8(__c.1888)
 2030 0afa 0E94 0000 		call transmitString_F
 2031               	.LVL142:
 256:FAT32.c       **** 		         transmitString_F (PSTR("   "));
 2032               		.loc 1 256 0
 2033 0afe 80E0      		ldi r24,lo8(__c.1890)
 2034 0b00 90E0      		ldi r25,hi8(__c.1890)
 2035 0b02 0E94 0000 		call transmitString_F
 2036               	.LVL143:
 257:FAT32.c       **** 			     displayMemory (LOW, dir->fileSize);
 2037               		.loc 1 257 0
 2038 0b06 AA85      		ldd r26,Y+10
 2039 0b08 BB85      		ldd r27,Y+11
 2040 0b0a 5C96      		adiw r26,28
 2041 0b0c 4D91      		ld r20,X+
 2042 0b0e 5D91      		ld r21,X+
 2043 0b10 6D91      		ld r22,X+
 2044 0b12 7C91      		ld r23,X
 2045 0b14 5F97      		sbiw r26,28+3
 2046 0b16 80E0      		ldi r24,0
 2047 0b18 0E94 0000 		call displayMemory
 2048               	.LVL144:
 2049 0b1c 00C0      		rjmp .L102
 2050               	.L120:
 260:FAT32.c       **** 			   transmitString_F ((dir->attrib == 0x10)? PSTR("DIR") : PSTR("ROOT"));
 2051               		.loc 1 260 0
 2052 0b1e 80E0      		ldi r24,lo8(__c.1892)
 2053 0b20 90E0      		ldi r25,hi8(__c.1892)
 2054 0b22 00C0      		rjmp .L112
 2055               	.L121:
 2056 0b24 80E0      		ldi r24,lo8(__c.1894)
 2057 0b26 90E0      		ldi r25,hi8(__c.1894)
 2058               	.L112:
 260:FAT32.c       **** 			   transmitString_F ((dir->attrib == 0x10)? PSTR("DIR") : PSTR("ROOT"));
 2059               		.loc 1 260 0 is_stmt 0 discriminator 3
 2060 0b28 0E94 0000 		call transmitString_F
 2061               	.LVL145:
 2062               	.L102:
 2063 0b2c EA85      		ldd r30,Y+10
 2064 0b2e FB85      		ldd r31,Y+11
 2065 0b30 B096      		adiw r30,32
 2066 0b32 FB87      		std Y+11,r31
 2067 0b34 EA87      		std Y+10,r30
 2068               	.LVL146:
 2069 0b36 005E      		subi r16,-32
 2070 0b38 1F4F      		sbci r17,-1
 2071 0b3a 00C0      		rjmp .L98
 2072               	.LVL147:
 2073               	.L133:
 182:FAT32.c       ****    for(sector = 0; sector < sectorPerCluster; sector++)
 2074               		.loc 1 182 0 is_stmt 1
 2075 0b3c FFEF      		ldi r31,-1
 2076 0b3e 4F1A      		sub r4,r31
 2077 0b40 5F0A      		sbc r5,r31
 2078 0b42 6F0A      		sbc r6,r31
 2079 0b44 7F0A      		sbc r7,r31
 2080               	.LVL148:
 2081 0b46 00C0      		rjmp .L97
 2082               	.LVL149:
 2083               	.L132:
 266:FAT32.c       ****    cluster = (getSetNextCluster (cluster, GET, 0));
 2084               		.loc 1 266 0
 2085 0b48 00E0      		ldi r16,0
 2086 0b4a 10E0      		ldi r17,0
 2087 0b4c 9801      		movw r18,r16
 2088 0b4e 40E0      		ldi r20,0
 2089 0b50 C701      		movw r24,r14
 2090 0b52 B601      		movw r22,r12
 2091 0b54 0E94 0000 		call getSetNextCluster
 2092               	.LVL150:
 2093 0b58 6B01      		movw r12,r22
 2094 0b5a 7C01      		movw r14,r24
 2095               	.LVL151:
 268:FAT32.c       ****    if(cluster > 0x0ffffff6)
 2096               		.loc 1 268 0
 2097 0b5c 87EF      		ldi r24,-9
 2098 0b5e C816      		cp r12,r24
 2099 0b60 8FEF      		ldi r24,-1
 2100 0b62 D806      		cpc r13,r24
 2101 0b64 E806      		cpc r14,r24
 2102 0b66 8FE0      		ldi r24,15
 2103 0b68 F806      		cpc r15,r24
 2104 0b6a 00F4      		brsh .L131
 270:FAT32.c       ****    if(cluster == 0) 
 2105               		.loc 1 270 0
 2106 0b6c C114      		cp r12,__zero_reg__
 2107 0b6e D104      		cpc r13,__zero_reg__
 2108 0b70 E104      		cpc r14,__zero_reg__
 2109 0b72 F104      		cpc r15,__zero_reg__
 2110 0b74 01F0      		breq .+2
 2111 0b76 00C0      		rjmp .L117
 271:FAT32.c       ****    {transmitString_F(PSTR("Error in getting cluster"));  return 0;}
 2112               		.loc 1 271 0
 2113 0b78 80E0      		ldi r24,lo8(__c.1902)
 2114 0b7a 90E0      		ldi r25,hi8(__c.1902)
 2115               	.LVL152:
 2116               	.L130:
 2117 0b7c 0E94 0000 		call transmitString_F
 2118               	.LVL153:
 2119               	.L131:
 2120 0b80 80E0      		ldi r24,0
 2121 0b82 90E0      		ldi r25,0
 2122 0b84 00C0      		rjmp .L128
 2123               	.LVL154:
 2124               	.L134:
 205:FAT32.c       **** 			  if(flag == GET_FILE)
 2125               		.loc 1 205 0
 2126 0b86 91E0      		ldi r25,lo8(1)
 2127 0b88 3912      		cpse r3,r25
 2128 0b8a 00C0      		rjmp .L136
 207:FAT32.c       **** 			    appendFileSector = firstSector + sector;
 2129               		.loc 1 207 0
 2130 0b8c 8092 0000 		sts appendFileSector,r8
 2131 0b90 9092 0000 		sts appendFileSector+1,r9
 2132 0b94 A092 0000 		sts appendFileSector+2,r10
 2133 0b98 B092 0000 		sts appendFileSector+3,r11
 208:FAT32.c       **** 				appendFileLocation = i;
 2134               		.loc 1 208 0
 2135 0b9c C901      		movw r24,r18
 2136 0b9e A0E0      		ldi r26,0
 2137 0ba0 B0E0      		ldi r27,0
 2138               	.LVL155:
 2139 0ba2 8093 0000 		sts appendFileLocation,r24
 2140 0ba6 9093 0000 		sts appendFileLocation+1,r25
 2141 0baa A093 0000 		sts appendFileLocation+2,r26
 2142 0bae B093 0000 		sts appendFileLocation+3,r27
 209:FAT32.c       **** 				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
 2143               		.loc 1 209 0
 2144 0bb2 EA85      		ldd r30,Y+10
 2145 0bb4 FB85      		ldd r31,Y+11
 2146 0bb6 8489      		ldd r24,Z+20
 2147 0bb8 9589      		ldd r25,Z+21
 2148 0bba A0E0      		ldi r26,0
 2149 0bbc B0E0      		ldi r27,0
 2150 0bbe DC01      		movw r26,r24
 2151 0bc0 9927      		clr r25
 2152 0bc2 8827      		clr r24
 2153 0bc4 428D      		ldd r20,Z+26
 2154 0bc6 538D      		ldd r21,Z+27
 2155 0bc8 60E0      		ldi r22,0
 2156 0bca 70E0      		ldi r23,0
 2157 0bcc 842B      		or r24,r20
 2158 0bce 952B      		or r25,r21
 2159 0bd0 A62B      		or r26,r22
 2160 0bd2 B72B      		or r27,r23
 2161 0bd4 8093 0000 		sts appendStartCluster,r24
 2162 0bd8 9093 0000 		sts appendStartCluster+1,r25
 2163 0bdc A093 0000 		sts appendStartCluster+2,r26
 2164 0be0 B093 0000 		sts appendStartCluster+3,r27
 210:FAT32.c       **** 				fileSize = dir->fileSize;
 2165               		.loc 1 210 0
 2166 0be4 848D      		ldd r24,Z+28
 2167 0be6 958D      		ldd r25,Z+29
 2168 0be8 A68D      		ldd r26,Z+30
 2169 0bea B78D      		ldd r27,Z+31
 2170 0bec 8093 0000 		sts fileSize,r24
 2171 0bf0 9093 0000 		sts fileSize+1,r25
 2172 0bf4 A093 0000 		sts fileSize+2,r26
 2173 0bf8 B093 0000 		sts fileSize+3,r27
 189:FAT32.c       **** 	    dir = (struct dir_Structure *) &buffer[i];
 2174               		.loc 1 189 0
 2175 0bfc 8A85      		ldd r24,Y+10
 2176 0bfe 9B85      		ldd r25,Y+11
 211:FAT32.c       **** 			    return (dir);
 2177               		.loc 1 211 0
 2178 0c00 00C0      		rjmp .L128
 2179               	.LVL156:
 2180               	.L136:
 215:FAT32.c       **** 			     TX_NEWLINE;
 2181               		.loc 1 215 0
 2182 0c02 8DE0      		ldi r24,lo8(13)
 2183 0c04 0E94 0000 		call transmitByte
 2184               	.LVL157:
 2185 0c08 8AE0      		ldi r24,lo8(10)
 2186 0c0a 0E94 0000 		call transmitByte
 2187               	.LVL158:
 216:FAT32.c       **** 				 transmitString_F(PSTR("Deleting.."));
 2188               		.loc 1 216 0
 2189 0c0e 80E0      		ldi r24,lo8(__c.1878)
 2190 0c10 90E0      		ldi r25,hi8(__c.1878)
 2191 0c12 0E94 0000 		call transmitString_F
 2192               	.LVL159:
 217:FAT32.c       **** 				 TX_NEWLINE;
 2193               		.loc 1 217 0
 2194 0c16 8DE0      		ldi r24,lo8(13)
 2195 0c18 0E94 0000 		call transmitByte
 2196               	.LVL160:
 2197 0c1c 8AE0      		ldi r24,lo8(10)
 2198 0c1e 0E94 0000 		call transmitByte
 2199               	.LVL161:
 218:FAT32.c       **** 				 TX_NEWLINE;
 2200               		.loc 1 218 0
 2201 0c22 8DE0      		ldi r24,lo8(13)
 2202 0c24 0E94 0000 		call transmitByte
 2203               	.LVL162:
 2204 0c28 8AE0      		ldi r24,lo8(10)
 2205 0c2a 0E94 0000 		call transmitByte
 2206               	.LVL163:
 219:FAT32.c       **** 				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
 2207               		.loc 1 219 0
 2208 0c2e AA85      		ldd r26,Y+10
 2209 0c30 BB85      		ldd r27,Y+11
 2210 0c32 5496      		adiw r26,20
 2211 0c34 CD90      		ld r12,X+
 2212 0c36 DC90      		ld r13,X
 2213 0c38 5597      		sbiw r26,20+1
 2214               	.LVL164:
 2215 0c3a E12C      		mov r14,__zero_reg__
 2216 0c3c F12C      		mov r15,__zero_reg__
 2217 0c3e 7601      		movw r14,r12
 2218 0c40 DD24      		clr r13
 2219 0c42 CC24      		clr r12
 2220 0c44 5A96      		adiw r26,26
 2221 0c46 8D91      		ld r24,X+
 2222 0c48 9C91      		ld r25,X
 2223 0c4a 5B97      		sbiw r26,26+1
 2224 0c4c A0E0      		ldi r26,0
 2225 0c4e B0E0      		ldi r27,0
 2226 0c50 C82A      		or r12,r24
 2227 0c52 D92A      		or r13,r25
 2228 0c54 EA2A      		or r14,r26
 2229 0c56 FB2A      		or r15,r27
 2230               	.LVL165:
 222:FAT32.c       **** 				 dir->name[0] = DELETED;    
 2231               		.loc 1 222 0
 2232 0c58 85EE      		ldi r24,lo8(-27)
 2233 0c5a EA85      		ldd r30,Y+10
 2234 0c5c FB85      		ldd r31,Y+11
 2235 0c5e 8083      		st Z,r24
 223:FAT32.c       **** 				 SD_writeSingleBlock (firstSector+sector);
 2236               		.loc 1 223 0
 2237 0c60 C501      		movw r24,r10
 2238 0c62 B401      		movw r22,r8
 2239 0c64 0E94 0000 		call SD_writeSingleBlock
 2240               	.LVL166:
 225:FAT32.c       **** 				 freeMemoryUpdate (ADD, dir->fileSize);
 2241               		.loc 1 225 0
 2242 0c68 AA85      		ldd r26,Y+10
 2243 0c6a BB85      		ldd r27,Y+11
 2244 0c6c 5C96      		adiw r26,28
 2245 0c6e 4D91      		ld r20,X+
 2246 0c70 5D91      		ld r21,X+
 2247 0c72 6D91      		ld r22,X+
 2248 0c74 7C91      		ld r23,X
 2249 0c76 5F97      		sbiw r26,28+3
 2250 0c78 80E0      		ldi r24,0
 2251 0c7a 0E94 0000 		call freeMemoryUpdate
 2252               	.LVL167:
 228:FAT32.c       **** 				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
 2253               		.loc 1 228 0
 2254 0c7e 20E0      		ldi r18,0
 2255 0c80 30E0      		ldi r19,0
 2256 0c82 A901      		movw r20,r18
 2257 0c84 60E0      		ldi r22,0
 2258 0c86 82E0      		ldi r24,lo8(2)
 2259 0c88 0E94 0000 		call getSetFreeCluster
 2260               	.LVL168:
 229:FAT32.c       **** 				 if(firstCluster < cluster)
 2261               		.loc 1 229 0
 2262 0c8c C616      		cp r12,r22
 2263 0c8e D706      		cpc r13,r23
 2264 0c90 E806      		cpc r14,r24
 2265 0c92 F906      		cpc r15,r25
 2266 0c94 00F4      		brsh .L108
 230:FAT32.c       **** 				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
 2267               		.loc 1 230 0
 2268 0c96 A701      		movw r20,r14
 2269 0c98 9601      		movw r18,r12
 2270 0c9a 61E0      		ldi r22,lo8(1)
 2271               	.LVL169:
 2272 0c9c 82E0      		ldi r24,lo8(2)
 2273 0c9e 0E94 0000 		call getSetFreeCluster
 2274               	.LVL170:
 2275               	.L108:
 235:FAT32.c       **** 			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
 2276               		.loc 1 235 0
 2277 0ca2 00E0      		ldi r16,0
 2278 0ca4 10E0      		ldi r17,0
 2279 0ca6 9801      		movw r18,r16
 2280 0ca8 40E0      		ldi r20,0
 2281 0caa C701      		movw r24,r14
 2282 0cac B601      		movw r22,r12
 2283 0cae 0E94 0000 		call getSetNextCluster
 2284               	.LVL171:
 2285 0cb2 4B01      		movw r8,r22
 2286 0cb4 5C01      		movw r10,r24
 2287               	.LVL172:
 236:FAT32.c       **** 					getSetNextCluster (firstCluster, SET, 0);
 2288               		.loc 1 236 0
 2289 0cb6 00E0      		ldi r16,0
 2290 0cb8 10E0      		ldi r17,0
 2291 0cba 9801      		movw r18,r16
 2292 0cbc 41E0      		ldi r20,lo8(1)
 2293 0cbe C701      		movw r24,r14
 2294 0cc0 B601      		movw r22,r12
 2295 0cc2 0E94 0000 		call getSetNextCluster
 2296               	.LVL173:
 237:FAT32.c       **** 					if(nextCluster > 0x0ffffff6) 
 2297               		.loc 1 237 0
 2298 0cc6 B7EF      		ldi r27,-9
 2299 0cc8 8B16      		cp r8,r27
 2300 0cca BFEF      		ldi r27,-1
 2301 0ccc 9B06      		cpc r9,r27
 2302 0cce AB06      		cpc r10,r27
 2303 0cd0 BFE0      		ldi r27,15
 2304 0cd2 BB06      		cpc r11,r27
 2305 0cd4 00F4      		brsh .L107
 239:FAT32.c       **** 					firstCluster = nextCluster;
 2306               		.loc 1 239 0
 2307 0cd6 7501      		movw r14,r10
 2308 0cd8 6401      		movw r12,r8
 2309               	.LVL174:
 2310 0cda 00C0      		rjmp .L108
 2311               	.LVL175:
 2312               	.L107:
 238:FAT32.c       **** 					   {transmitString_F(PSTR("File deleted!"));return 0;}
 2313               		.loc 1 238 0
 2314 0cdc 80E0      		ldi r24,lo8(__c.1880)
 2315 0cde 90E0      		ldi r25,hi8(__c.1880)
 2316 0ce0 00C0      		rjmp .L130
 2317               	.LVL176:
 2318               	.L128:
 2319               	/* epilogue start */
 274:FAT32.c       **** }
 2320               		.loc 1 274 0
 2321 0ce2 2B96      		adiw r28,11
 2322 0ce4 0FB6      		in __tmp_reg__,__SREG__
 2323 0ce6 F894      		cli
 2324 0ce8 DEBF      		out __SP_H__,r29
 2325 0cea 0FBE      		out __SREG__,__tmp_reg__
 2326 0cec CDBF      		out __SP_L__,r28
 2327 0cee DF91      		pop r29
 2328 0cf0 CF91      		pop r28
 2329 0cf2 1F91      		pop r17
 2330 0cf4 0F91      		pop r16
 2331 0cf6 FF90      		pop r15
 2332 0cf8 EF90      		pop r14
 2333 0cfa DF90      		pop r13
 2334 0cfc CF90      		pop r12
 2335 0cfe BF90      		pop r11
 2336 0d00 AF90      		pop r10
 2337 0d02 9F90      		pop r9
 2338 0d04 8F90      		pop r8
 2339 0d06 7F90      		pop r7
 2340 0d08 6F90      		pop r6
 2341 0d0a 5F90      		pop r5
 2342 0d0c 4F90      		pop r4
 2343               	.LVL177:
 2344 0d0e 3F90      		pop r3
 2345               	.LVL178:
 2346 0d10 2F90      		pop r2
 2347 0d12 0895      		ret
 2348               		.cfi_endproc
 2349               	.LFE5:
 2351               	.global	readFile
 2353               	readFile:
 2354               	.LFB6:
 285:FAT32.c       **** {
 2355               		.loc 1 285 0
 2356               		.cfi_startproc
 2357               	.LVL179:
 2358 0d14 2F92      		push r2
 2359               	.LCFI106:
 2360               		.cfi_def_cfa_offset 3
 2361               		.cfi_offset 2, -2
 2362 0d16 3F92      		push r3
 2363               	.LCFI107:
 2364               		.cfi_def_cfa_offset 4
 2365               		.cfi_offset 3, -3
 2366 0d18 4F92      		push r4
 2367               	.LCFI108:
 2368               		.cfi_def_cfa_offset 5
 2369               		.cfi_offset 4, -4
 2370 0d1a 5F92      		push r5
 2371               	.LCFI109:
 2372               		.cfi_def_cfa_offset 6
 2373               		.cfi_offset 5, -5
 2374 0d1c 6F92      		push r6
 2375               	.LCFI110:
 2376               		.cfi_def_cfa_offset 7
 2377               		.cfi_offset 6, -6
 2378 0d1e 7F92      		push r7
 2379               	.LCFI111:
 2380               		.cfi_def_cfa_offset 8
 2381               		.cfi_offset 7, -7
 2382 0d20 8F92      		push r8
 2383               	.LCFI112:
 2384               		.cfi_def_cfa_offset 9
 2385               		.cfi_offset 8, -8
 2386 0d22 9F92      		push r9
 2387               	.LCFI113:
 2388               		.cfi_def_cfa_offset 10
 2389               		.cfi_offset 9, -9
 2390 0d24 AF92      		push r10
 2391               	.LCFI114:
 2392               		.cfi_def_cfa_offset 11
 2393               		.cfi_offset 10, -10
 2394 0d26 BF92      		push r11
 2395               	.LCFI115:
 2396               		.cfi_def_cfa_offset 12
 2397               		.cfi_offset 11, -11
 2398 0d28 CF92      		push r12
 2399               	.LCFI116:
 2400               		.cfi_def_cfa_offset 13
 2401               		.cfi_offset 12, -12
 2402 0d2a DF92      		push r13
 2403               	.LCFI117:
 2404               		.cfi_def_cfa_offset 14
 2405               		.cfi_offset 13, -13
 2406 0d2c EF92      		push r14
 2407               	.LCFI118:
 2408               		.cfi_def_cfa_offset 15
 2409               		.cfi_offset 14, -14
 2410 0d2e FF92      		push r15
 2411               	.LCFI119:
 2412               		.cfi_def_cfa_offset 16
 2413               		.cfi_offset 15, -15
 2414 0d30 0F93      		push r16
 2415               	.LCFI120:
 2416               		.cfi_def_cfa_offset 17
 2417               		.cfi_offset 16, -16
 2418 0d32 1F93      		push r17
 2419               	.LCFI121:
 2420               		.cfi_def_cfa_offset 18
 2421               		.cfi_offset 17, -17
 2422 0d34 CF93      		push r28
 2423               	.LCFI122:
 2424               		.cfi_def_cfa_offset 19
 2425               		.cfi_offset 28, -18
 2426 0d36 DF93      		push r29
 2427               	.LCFI123:
 2428               		.cfi_def_cfa_offset 20
 2429               		.cfi_offset 29, -19
 2430 0d38 CDB7      		in r28,__SP_L__
 2431 0d3a DEB7      		in r29,__SP_H__
 2432               	.LCFI124:
 2433               		.cfi_def_cfa_register 28
 2434 0d3c 2897      		sbiw r28,8
 2435               	.LCFI125:
 2436               		.cfi_def_cfa_offset 28
 2437 0d3e 0FB6      		in __tmp_reg__,__SREG__
 2438 0d40 F894      		cli
 2439 0d42 DEBF      		out __SP_H__,r29
 2440 0d44 0FBE      		out __SREG__,__tmp_reg__
 2441 0d46 CDBF      		out __SP_L__,r28
 2442               	/* prologue: function */
 2443               	/* frame size = 8 */
 2444               	/* stack size = 26 */
 2445               	.L__stack_usage = 26
 2446 0d48 182F      		mov r17,r24
 2447               	.LVL180:
 291:FAT32.c       **** error = convertFileName (fileName); //convert fileName into FAT format
 2448               		.loc 1 291 0
 2449 0d4a CB01      		movw r24,r22
 2450               	.LVL181:
 2451 0d4c 6F83      		std Y+7,r22
 2452 0d4e 7887      		std Y+8,r23
 2453 0d50 0E94 0000 		call convertFileName
 2454               	.LVL182:
 292:FAT32.c       **** if(error) return 2;
 2455               		.loc 1 292 0
 2456 0d54 6F81      		ldd r22,Y+7
 2457 0d56 7885      		ldd r23,Y+8
 2458 0d58 8111      		cpse r24,__zero_reg__
 2459 0d5a 00C0      		rjmp .L147
 294:FAT32.c       **** dir = findFiles (GET_FILE, fileName); //get the file location
 2460               		.loc 1 294 0
 2461 0d5c 81E0      		ldi r24,lo8(1)
 2462               	.LVL183:
 2463 0d5e 0E94 0000 		call findFiles
 2464               	.LVL184:
 2465 0d62 FC01      		movw r30,r24
 2466               	.LVL185:
 295:FAT32.c       **** if(dir == 0) 
 2467               		.loc 1 295 0
 2468 0d64 0097      		sbiw r24,0
 2469 0d66 01F4      		brne .+2
 2470 0d68 00C0      		rjmp .L149
 298:FAT32.c       **** if(flag == VERIFY) return (1);	//specified file name is already existing
 2471               		.loc 1 298 0
 2472 0d6a 1130      		cpi r17,lo8(1)
 2473 0d6c 01F4      		brne .+2
 2474 0d6e 00C0      		rjmp .L148
 300:FAT32.c       **** cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
 2475               		.loc 1 300 0
 2476 0d70 C488      		ldd r12,Z+20
 2477 0d72 D588      		ldd r13,Z+21
 2478 0d74 E12C      		mov r14,__zero_reg__
 2479 0d76 F12C      		mov r15,__zero_reg__
 2480 0d78 7601      		movw r14,r12
 2481 0d7a DD24      		clr r13
 2482 0d7c CC24      		clr r12
 2483 0d7e 428D      		ldd r20,Z+26
 2484 0d80 538D      		ldd r21,Z+27
 2485 0d82 60E0      		ldi r22,0
 2486 0d84 70E0      		ldi r23,0
 2487 0d86 C42A      		or r12,r20
 2488 0d88 D52A      		or r13,r21
 2489 0d8a E62A      		or r14,r22
 2490 0d8c F72A      		or r15,r23
 2491               	.LVL186:
 302:FAT32.c       **** fileSize = dir->fileSize;
 2492               		.loc 1 302 0
 2493 0d8e 448C      		ldd r4,Z+28
 2494 0d90 558C      		ldd r5,Z+29
 2495 0d92 668C      		ldd r6,Z+30
 2496 0d94 778C      		ldd r7,Z+31
 2497               	.LVL187:
 304:FAT32.c       **** TX_NEWLINE;
 2498               		.loc 1 304 0
 2499 0d96 8DE0      		ldi r24,lo8(13)
 2500               	.LVL188:
 2501 0d98 0E94 0000 		call transmitByte
 2502               	.LVL189:
 2503 0d9c 8AE0      		ldi r24,lo8(10)
 2504 0d9e 0E94 0000 		call transmitByte
 2505               	.LVL190:
 305:FAT32.c       **** TX_NEWLINE;
 2506               		.loc 1 305 0
 2507 0da2 8DE0      		ldi r24,lo8(13)
 2508 0da4 0E94 0000 		call transmitByte
 2509               	.LVL191:
 2510 0da8 8AE0      		ldi r24,lo8(10)
 2511 0daa 0E94 0000 		call transmitByte
 2512               	.LVL192:
 287:FAT32.c       **** unsigned long cluster, byteCounter = 0, fileSize, firstSector;
 2513               		.loc 1 287 0
 2514 0dae 812C      		mov r8,__zero_reg__
 2515 0db0 912C      		mov r9,__zero_reg__
 2516 0db2 5401      		movw r10,r8
 2517               	.LVL193:
 2518               	.L146:
 309:FAT32.c       ****   firstSector = getFirstSector (cluster);
 2519               		.loc 1 309 0
 2520 0db4 C701      		movw r24,r14
 2521 0db6 B601      		movw r22,r12
 2522 0db8 0E94 0000 		call getFirstSector
 2523               	.LVL194:
 2524 0dbc 6983      		std Y+1,r22
 2525 0dbe 7A83      		std Y+2,r23
 2526 0dc0 8B83      		std Y+3,r24
 2527 0dc2 9C83      		std Y+4,r25
 2528               	.LVL195:
 311:FAT32.c       ****   for(j=0; j<sectorPerCluster; j++)
 2529               		.loc 1 311 0
 2530 0dc4 10E0      		ldi r17,0
 2531               	.LVL196:
 2532               	.L140:
 311:FAT32.c       ****   for(j=0; j<sectorPerCluster; j++)
 2533               		.loc 1 311 0 is_stmt 0 discriminator 1
 2534 0dc6 8091 0000 		lds r24,sectorPerCluster
 2535 0dca 9091 0000 		lds r25,sectorPerCluster+1
 2536 0dce 212F      		mov r18,r17
 2537 0dd0 30E0      		ldi r19,0
 2538 0dd2 2817      		cp r18,r24
 2539 0dd4 3907      		cpc r19,r25
 2540 0dd6 00F4      		brsh .L150
 313:FAT32.c       ****     SD_readSingleBlock(firstSector + j);
 2541               		.loc 1 313 0 is_stmt 1
 2542 0dd8 6981      		ldd r22,Y+1
 2543 0dda 7A81      		ldd r23,Y+2
 2544 0ddc 8B81      		ldd r24,Y+3
 2545 0dde 9C81      		ldd r25,Y+4
 2546 0de0 610F      		add r22,r17
 2547 0de2 711D      		adc r23,__zero_reg__
 2548 0de4 811D      		adc r24,__zero_reg__
 2549 0de6 911D      		adc r25,__zero_reg__
 2550 0de8 0E94 0000 		call SD_readSingleBlock
 2551               	.LVL197:
 2552 0dec B501      		movw r22,r10
 2553 0dee A401      		movw r20,r8
 315:FAT32.c       **** 	for(k=0; k<512; k++)
 2554               		.loc 1 315 0
 2555 0df0 212C      		mov r2,__zero_reg__
 2556 0df2 312C      		mov r3,__zero_reg__
 2557               	.LVL198:
 2558               	.L143:
 317:FAT32.c       ****       transmitByte(buffer[k]);
 2559               		.loc 1 317 0
 2560 0df4 F101      		movw r30,r2
 2561 0df6 E050      		subi r30,lo8(-(buffer))
 2562 0df8 F040      		sbci r31,hi8(-(buffer))
 2563 0dfa 8081      		ld r24,Z
 2564 0dfc 4D83      		std Y+5,r20
 2565 0dfe 5E83      		std Y+6,r21
 2566 0e00 6F83      		std Y+7,r22
 2567 0e02 7887      		std Y+8,r23
 2568 0e04 0E94 0000 		call transmitByte
 2569               	.LVL199:
 318:FAT32.c       ****       if ((byteCounter++) >= fileSize ) return 0;
 2570               		.loc 1 318 0
 2571 0e08 8FEF      		ldi r24,-1
 2572 0e0a 881A      		sub r8,r24
 2573 0e0c 980A      		sbc r9,r24
 2574 0e0e A80A      		sbc r10,r24
 2575 0e10 B80A      		sbc r11,r24
 2576               	.LVL200:
 2577 0e12 4D81      		ldd r20,Y+5
 2578 0e14 5E81      		ldd r21,Y+6
 2579 0e16 6F81      		ldd r22,Y+7
 2580 0e18 7885      		ldd r23,Y+8
 2581 0e1a 4415      		cp r20,r4
 2582 0e1c 5505      		cpc r21,r5
 2583 0e1e 6605      		cpc r22,r6
 2584 0e20 7705      		cpc r23,r7
 2585 0e22 00F4      		brsh .L149
 315:FAT32.c       **** 	for(k=0; k<512; k++)
 2586               		.loc 1 315 0
 2587 0e24 EFEF      		ldi r30,-1
 2588 0e26 2E1A      		sub r2,r30
 2589 0e28 3E0A      		sbc r3,r30
 2590               	.LVL201:
 2591 0e2a 2114      		cp r2,__zero_reg__
 2592 0e2c F2E0      		ldi r31,2
 2593 0e2e 3F06      		cpc r3,r31
 2594 0e30 01F0      		breq .L142
 318:FAT32.c       ****       if ((byteCounter++) >= fileSize ) return 0;
 2595               		.loc 1 318 0
 2596 0e32 B501      		movw r22,r10
 2597 0e34 A401      		movw r20,r8
 2598 0e36 00C0      		rjmp .L143
 2599               	.L142:
 311:FAT32.c       ****   for(j=0; j<sectorPerCluster; j++)
 2600               		.loc 1 311 0
 2601 0e38 1F5F      		subi r17,lo8(-(1))
 2602               	.LVL202:
 2603 0e3a 00C0      		rjmp .L140
 2604               	.LVL203:
 2605               	.L150:
 321:FAT32.c       ****   cluster = getSetNextCluster (cluster, GET, 0);
 2606               		.loc 1 321 0
 2607 0e3c 00E0      		ldi r16,0
 2608 0e3e 10E0      		ldi r17,0
 2609 0e40 9801      		movw r18,r16
 2610 0e42 40E0      		ldi r20,0
 2611 0e44 C701      		movw r24,r14
 2612 0e46 B601      		movw r22,r12
 2613 0e48 0E94 0000 		call getSetNextCluster
 2614               	.LVL204:
 2615 0e4c 6B01      		movw r12,r22
 2616 0e4e 7C01      		movw r14,r24
 2617               	.LVL205:
 322:FAT32.c       ****   if(cluster == 0) {transmitString_F(PSTR("Error in getting cluster")); return 0;}
 2618               		.loc 1 322 0
 2619 0e50 6115      		cp r22,__zero_reg__
 2620 0e52 7105      		cpc r23,__zero_reg__
 2621 0e54 8105      		cpc r24,__zero_reg__
 2622 0e56 9105      		cpc r25,__zero_reg__
 2623 0e58 01F0      		breq .+2
 2624 0e5a 00C0      		rjmp .L146
 322:FAT32.c       ****   if(cluster == 0) {transmitString_F(PSTR("Error in getting cluster")); return 0;}
 2625               		.loc 1 322 0 is_stmt 0 discriminator 1
 2626 0e5c 80E0      		ldi r24,lo8(__c.1923)
 2627 0e5e 90E0      		ldi r25,hi8(__c.1923)
 2628 0e60 0E94 0000 		call transmitString_F
 2629               	.LVL206:
 2630               	.L149:
 2631 0e64 80E0      		ldi r24,0
 2632 0e66 00C0      		rjmp .L138
 2633               	.LVL207:
 2634               	.L147:
 292:FAT32.c       **** if(error) return 2;
 2635               		.loc 1 292 0 is_stmt 1
 2636 0e68 82E0      		ldi r24,lo8(2)
 2637               	.LVL208:
 2638 0e6a 00C0      		rjmp .L138
 2639               	.LVL209:
 2640               	.L148:
 298:FAT32.c       **** if(flag == VERIFY) return (1);	//specified file name is already existing
 2641               		.loc 1 298 0
 2642 0e6c 81E0      		ldi r24,lo8(1)
 2643               	.LVL210:
 2644               	.L138:
 2645               	/* epilogue start */
 325:FAT32.c       **** }
 2646               		.loc 1 325 0
 2647 0e6e 2896      		adiw r28,8
 2648 0e70 0FB6      		in __tmp_reg__,__SREG__
 2649 0e72 F894      		cli
 2650 0e74 DEBF      		out __SP_H__,r29
 2651 0e76 0FBE      		out __SREG__,__tmp_reg__
 2652 0e78 CDBF      		out __SP_L__,r28
 2653 0e7a DF91      		pop r29
 2654 0e7c CF91      		pop r28
 2655 0e7e 1F91      		pop r17
 2656 0e80 0F91      		pop r16
 2657 0e82 FF90      		pop r15
 2658 0e84 EF90      		pop r14
 2659 0e86 DF90      		pop r13
 2660 0e88 CF90      		pop r12
 2661 0e8a BF90      		pop r11
 2662 0e8c AF90      		pop r10
 2663 0e8e 9F90      		pop r9
 2664 0e90 8F90      		pop r8
 2665 0e92 7F90      		pop r7
 2666 0e94 6F90      		pop r6
 2667 0e96 5F90      		pop r5
 2668 0e98 4F90      		pop r4
 2669 0e9a 3F90      		pop r3
 2670 0e9c 2F90      		pop r2
 2671 0e9e 0895      		ret
 2672               		.cfi_endproc
 2673               	.LFE6:
 2675               	.global	deleteFile
 2677               	deleteFile:
 2678               	.LFB12:
 755:FAT32.c       **** {
 2679               		.loc 1 755 0
 2680               		.cfi_startproc
 2681               	.LVL211:
 2682 0ea0 CF93      		push r28
 2683               	.LCFI126:
 2684               		.cfi_def_cfa_offset 3
 2685               		.cfi_offset 28, -2
 2686 0ea2 DF93      		push r29
 2687               	.LCFI127:
 2688               		.cfi_def_cfa_offset 4
 2689               		.cfi_offset 29, -3
 2690               	/* prologue: function */
 2691               	/* frame size = 0 */
 2692               	/* stack size = 2 */
 2693               	.L__stack_usage = 2
 2694 0ea4 EC01      		movw r28,r24
 758:FAT32.c       ****   error = convertFileName (fileName);
 2695               		.loc 1 758 0
 2696 0ea6 0E94 0000 		call convertFileName
 2697               	.LVL212:
 759:FAT32.c       ****   if(error) return;
 2698               		.loc 1 759 0
 2699 0eaa 8111      		cpse r24,__zero_reg__
 2700 0eac 00C0      		rjmp .L151
 761:FAT32.c       ****   findFiles (DELETE, fileName);
 2701               		.loc 1 761 0
 2702 0eae BE01      		movw r22,r28
 2703 0eb0 82E0      		ldi r24,lo8(2)
 2704               	.LVL213:
 2705               	/* epilogue start */
 762:FAT32.c       **** }
 2706               		.loc 1 762 0
 2707 0eb2 DF91      		pop r29
 2708 0eb4 CF91      		pop r28
 2709               	.LVL214:
 761:FAT32.c       ****   findFiles (DELETE, fileName);
 2710               		.loc 1 761 0
 2711 0eb6 0C94 0000 		jmp findFiles
 2712               	.LVL215:
 2713               	.L151:
 2714               	/* epilogue start */
 762:FAT32.c       **** }
 2715               		.loc 1 762 0
 2716 0eba DF91      		pop r29
 2717 0ebc CF91      		pop r28
 2718               	.LVL216:
 2719 0ebe 0895      		ret
 2720               		.cfi_endproc
 2721               	.LFE12:
 2723               	.global	writeFile
 2725               	writeFile:
 2726               	.LFB8:
 375:FAT32.c       **** {
 2727               		.loc 1 375 0
 2728               		.cfi_startproc
 2729               	.LVL217:
 2730 0ec0 2F92      		push r2
 2731               	.LCFI128:
 2732               		.cfi_def_cfa_offset 3
 2733               		.cfi_offset 2, -2
 2734 0ec2 3F92      		push r3
 2735               	.LCFI129:
 2736               		.cfi_def_cfa_offset 4
 2737               		.cfi_offset 3, -3
 2738 0ec4 4F92      		push r4
 2739               	.LCFI130:
 2740               		.cfi_def_cfa_offset 5
 2741               		.cfi_offset 4, -4
 2742 0ec6 5F92      		push r5
 2743               	.LCFI131:
 2744               		.cfi_def_cfa_offset 6
 2745               		.cfi_offset 5, -5
 2746 0ec8 6F92      		push r6
 2747               	.LCFI132:
 2748               		.cfi_def_cfa_offset 7
 2749               		.cfi_offset 6, -6
 2750 0eca 7F92      		push r7
 2751               	.LCFI133:
 2752               		.cfi_def_cfa_offset 8
 2753               		.cfi_offset 7, -7
 2754 0ecc 8F92      		push r8
 2755               	.LCFI134:
 2756               		.cfi_def_cfa_offset 9
 2757               		.cfi_offset 8, -8
 2758 0ece 9F92      		push r9
 2759               	.LCFI135:
 2760               		.cfi_def_cfa_offset 10
 2761               		.cfi_offset 9, -9
 2762 0ed0 AF92      		push r10
 2763               	.LCFI136:
 2764               		.cfi_def_cfa_offset 11
 2765               		.cfi_offset 10, -10
 2766 0ed2 BF92      		push r11
 2767               	.LCFI137:
 2768               		.cfi_def_cfa_offset 12
 2769               		.cfi_offset 11, -11
 2770 0ed4 CF92      		push r12
 2771               	.LCFI138:
 2772               		.cfi_def_cfa_offset 13
 2773               		.cfi_offset 12, -12
 2774 0ed6 DF92      		push r13
 2775               	.LCFI139:
 2776               		.cfi_def_cfa_offset 14
 2777               		.cfi_offset 13, -13
 2778 0ed8 EF92      		push r14
 2779               	.LCFI140:
 2780               		.cfi_def_cfa_offset 15
 2781               		.cfi_offset 14, -14
 2782 0eda FF92      		push r15
 2783               	.LCFI141:
 2784               		.cfi_def_cfa_offset 16
 2785               		.cfi_offset 15, -15
 2786 0edc 0F93      		push r16
 2787               	.LCFI142:
 2788               		.cfi_def_cfa_offset 17
 2789               		.cfi_offset 16, -16
 2790 0ede 1F93      		push r17
 2791               	.LCFI143:
 2792               		.cfi_def_cfa_offset 18
 2793               		.cfi_offset 17, -17
 2794 0ee0 CF93      		push r28
 2795               	.LCFI144:
 2796               		.cfi_def_cfa_offset 19
 2797               		.cfi_offset 28, -18
 2798 0ee2 DF93      		push r29
 2799               	.LCFI145:
 2800               		.cfi_def_cfa_offset 20
 2801               		.cfi_offset 29, -19
 2802 0ee4 CDB7      		in r28,__SP_L__
 2803 0ee6 DEB7      		in r29,__SP_H__
 2804               	.LCFI146:
 2805               		.cfi_def_cfa_register 28
 2806 0ee8 2897      		sbiw r28,8
 2807               	.LCFI147:
 2808               		.cfi_def_cfa_offset 28
 2809 0eea 0FB6      		in __tmp_reg__,__SREG__
 2810 0eec F894      		cli
 2811 0eee DEBF      		out __SP_H__,r29
 2812 0ef0 0FBE      		out __SREG__,__tmp_reg__
 2813 0ef2 CDBF      		out __SP_L__,r28
 2814               	/* prologue: function */
 2815               	/* frame size = 8 */
 2816               	/* stack size = 26 */
 2817               	.L__stack_usage = 26
 2818 0ef4 8D83      		std Y+5,r24
 2819 0ef6 9E83      		std Y+6,r25
 2820               	.LVL218:
 381:FAT32.c       **** j = readFile (VERIFY, fileName);
 2821               		.loc 1 381 0
 2822 0ef8 BC01      		movw r22,r24
 2823 0efa 81E0      		ldi r24,lo8(1)
 2824               	.LVL219:
 2825 0efc 0E94 0000 		call readFile
 2826               	.LVL220:
 383:FAT32.c       **** if(j == 1) 
 2827               		.loc 1 383 0
 2828 0f00 8130      		cpi r24,lo8(1)
 2829 0f02 01F0      		breq .+2
 2830 0f04 00C0      		rjmp .L154
 385:FAT32.c       ****   transmitString_F(PSTR(" File already exists, appending data..")); 
 2831               		.loc 1 385 0
 2832 0f06 80E0      		ldi r24,lo8(__c.1976)
 2833 0f08 90E0      		ldi r25,hi8(__c.1976)
 2834               	.LVL221:
 2835 0f0a 0E94 0000 		call transmitString_F
 2836               	.LVL222:
 387:FAT32.c       ****   cluster = appendStartCluster;
 2837               		.loc 1 387 0
 2838 0f0e C090 0000 		lds r12,appendStartCluster
 2839 0f12 D090 0000 		lds r13,appendStartCluster+1
 2840 0f16 E090 0000 		lds r14,appendStartCluster+2
 2841 0f1a F090 0000 		lds r15,appendStartCluster+3
 2842               	.LVL223:
 388:FAT32.c       ****   clusterCount=0;
 2843               		.loc 1 388 0
 2844 0f1e 812C      		mov r8,__zero_reg__
 2845 0f20 912C      		mov r9,__zero_reg__
 2846 0f22 5401      		movw r10,r8
 2847               	.LVL224:
 2848               	.L156:
 391:FAT32.c       ****     nextCluster = getSetNextCluster (cluster, GET, 0);
 2849               		.loc 1 391 0
 2850 0f24 00E0      		ldi r16,0
 2851 0f26 10E0      		ldi r17,0
 2852 0f28 9801      		movw r18,r16
 2853 0f2a 40E0      		ldi r20,0
 2854 0f2c C701      		movw r24,r14
 2855 0f2e B601      		movw r22,r12
 2856 0f30 0E94 0000 		call getSetNextCluster
 2857               	.LVL225:
 392:FAT32.c       ****     if(nextCluster == EOF) break;
 2858               		.loc 1 392 0
 2859 0f34 6F3F      		cpi r22,-1
 2860 0f36 2FEF      		ldi r18,-1
 2861 0f38 7207      		cpc r23,r18
 2862 0f3a 8207      		cpc r24,r18
 2863 0f3c 2FE0      		ldi r18,15
 2864 0f3e 9207      		cpc r25,r18
 2865 0f40 01F0      		breq .L155
 2866               	.LVL226:
 394:FAT32.c       **** 	clusterCount++;
 2867               		.loc 1 394 0
 2868 0f42 4FEF      		ldi r20,-1
 2869 0f44 841A      		sub r8,r20
 2870 0f46 940A      		sbc r9,r20
 2871 0f48 A40A      		sbc r10,r20
 2872 0f4a B40A      		sbc r11,r20
 2873               	.LVL227:
 393:FAT32.c       **** 	cluster = nextCluster;
 2874               		.loc 1 393 0
 2875 0f4c 6B01      		movw r12,r22
 2876 0f4e 7C01      		movw r14,r24
 395:FAT32.c       ****   }
 2877               		.loc 1 395 0
 2878 0f50 00C0      		rjmp .L156
 2879               	.LVL228:
 2880               	.L155:
 397:FAT32.c       ****   sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last
 2881               		.loc 1 397 0
 2882 0f52 A091 0000 		lds r26,sectorPerCluster
 2883 0f56 B091 0000 		lds r27,sectorPerCluster+1
 2884 0f5a 2091 0000 		lds r18,bytesPerSector
 2885 0f5e 3091 0000 		lds r19,bytesPerSector+1
 2886 0f62 E091 0000 		lds r30,bytesPerSector
 2887 0f66 F091 0000 		lds r31,bytesPerSector+1
 2888 0f6a 0E94 0000 		call __umulhisi3
 2889               	.LVL229:
 2890 0f6e 9B01      		movw r18,r22
 2891 0f70 AC01      		movw r20,r24
 2892 0f72 C501      		movw r24,r10
 2893 0f74 B401      		movw r22,r8
 2894 0f76 0E94 0000 		call __mulsi3
 2895 0f7a 8B01      		movw r16,r22
 2896 0f7c 9C01      		movw r18,r24
 2897 0f7e 6091 0000 		lds r22,fileSize
 2898 0f82 7091 0000 		lds r23,fileSize+1
 2899 0f86 8091 0000 		lds r24,fileSize+2
 2900 0f8a 9091 0000 		lds r25,fileSize+3
 2901 0f8e 601B      		sub r22,r16
 2902 0f90 710B      		sbc r23,r17
 2903 0f92 820B      		sbc r24,r18
 2904 0f94 930B      		sbc r25,r19
 2905 0f96 9F01      		movw r18,r30
 2906 0f98 40E0      		ldi r20,0
 2907 0f9a 50E0      		ldi r21,0
 2908 0f9c 0E94 0000 		call __udivmodsi4
 2909 0fa0 A22E      		mov r10,r18
 2910               	.LVL230:
 377:FAT32.c       **** unsigned int i, firstClusterHigh=0, firstClusterLow=0;  //value 0 is assigned just to avoid warning
 2911               		.loc 1 377 0
 2912 0fa2 1C82      		std Y+4,__zero_reg__
 2913 0fa4 1B82      		std Y+3,__zero_reg__
 2914 0fa6 212C      		mov r2,__zero_reg__
 2915 0fa8 312C      		mov r3,__zero_reg__
 398:FAT32.c       ****   start = 1;
 2916               		.loc 1 398 0
 2917 0faa 8824      		clr r8
 2918 0fac 8394      		inc r8
 2919               	.LVL231:
 2920 0fae 00C0      		rjmp .L157
 2921               	.LVL232:
 2922               	.L154:
 402:FAT32.c       **** else if(j == 2) 
 2923               		.loc 1 402 0
 2924 0fb0 8230      		cpi r24,lo8(2)
 2925 0fb2 01F4      		brne .+2
 2926 0fb4 00C0      		rjmp .L153
 408:FAT32.c       ****   TX_NEWLINE;
 2927               		.loc 1 408 0
 2928 0fb6 8DE0      		ldi r24,lo8(13)
 2929               	.LVL233:
 2930 0fb8 0E94 0000 		call transmitByte
 2931               	.LVL234:
 2932 0fbc 8AE0      		ldi r24,lo8(10)
 2933 0fbe 0E94 0000 		call transmitByte
 2934               	.LVL235:
 409:FAT32.c       ****   transmitString_F(PSTR(" Creating File.."));
 2935               		.loc 1 409 0
 2936 0fc2 80E0      		ldi r24,lo8(__c.1980)
 2937 0fc4 90E0      		ldi r25,hi8(__c.1980)
 2938 0fc6 0E94 0000 		call transmitString_F
 2939               	.LVL236:
 411:FAT32.c       ****   cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
 2940               		.loc 1 411 0
 2941 0fca 20E0      		ldi r18,0
 2942 0fcc 30E0      		ldi r19,0
 2943 0fce A901      		movw r20,r18
 2944 0fd0 60E0      		ldi r22,0
 2945 0fd2 82E0      		ldi r24,lo8(2)
 2946 0fd4 0E94 0000 		call getSetFreeCluster
 2947               	.LVL237:
 412:FAT32.c       ****   if(cluster > totalClusters)
 2948               		.loc 1 412 0
 2949 0fd8 0091 0000 		lds r16,totalClusters
 2950 0fdc 1091 0000 		lds r17,totalClusters+1
 2951 0fe0 2091 0000 		lds r18,totalClusters+2
 2952 0fe4 3091 0000 		lds r19,totalClusters+3
 2953 0fe8 0617      		cp r16,r22
 2954 0fea 1707      		cpc r17,r23
 2955 0fec 2807      		cpc r18,r24
 2956 0fee 3907      		cpc r19,r25
 2957 0ff0 00F4      		brsh .L160
 413:FAT32.c       ****      cluster = rootCluster;
 2958               		.loc 1 413 0
 2959 0ff2 6091 0000 		lds r22,rootCluster
 2960 0ff6 7091 0000 		lds r23,rootCluster+1
 2961 0ffa 8091 0000 		lds r24,rootCluster+2
 2962 0ffe 9091 0000 		lds r25,rootCluster+3
 2963               	.LVL238:
 2964               	.L160:
 415:FAT32.c       ****   cluster = searchNextFreeCluster(cluster);
 2965               		.loc 1 415 0
 2966 1002 0E94 0000 		call searchNextFreeCluster
 2967               	.LVL239:
 2968 1006 6B01      		movw r12,r22
 2969 1008 7C01      		movw r14,r24
 2970               	.LVL240:
 416:FAT32.c       ****    if(cluster == 0)
 2971               		.loc 1 416 0
 2972 100a 6115      		cp r22,__zero_reg__
 2973 100c 7105      		cpc r23,__zero_reg__
 2974 100e 8105      		cpc r24,__zero_reg__
 2975 1010 9105      		cpc r25,__zero_reg__
 2976 1012 01F4      		brne .L161
 418:FAT32.c       ****       TX_NEWLINE;
 2977               		.loc 1 418 0
 2978 1014 8DE0      		ldi r24,lo8(13)
 2979 1016 0E94 0000 		call transmitByte
 2980               	.LVL241:
 2981 101a 8AE0      		ldi r24,lo8(10)
 2982 101c 0E94 0000 		call transmitByte
 2983               	.LVL242:
 419:FAT32.c       ****       transmitString_F(PSTR(" No free cluster!"));
 2984               		.loc 1 419 0
 2985 1020 80E0      		ldi r24,lo8(__c.1982)
 2986 1022 90E0      		ldi r25,hi8(__c.1982)
 2987 1024 00C0      		rjmp .L203
 2988               	.L161:
 422:FAT32.c       ****   getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
 2989               		.loc 1 422 0
 2990 1026 0FEF      		ldi r16,lo8(-1)
 2991 1028 1FEF      		ldi r17,lo8(-1)
 2992 102a 2FEF      		ldi r18,lo8(-1)
 2993 102c 3FE0      		ldi r19,lo8(15)
 2994 102e 41E0      		ldi r20,lo8(1)
 2995 1030 0E94 0000 		call getSetNextCluster
 2996               	.LVL243:
 424:FAT32.c       ****   firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
 2997               		.loc 1 424 0
 2998 1034 1701      		movw r2,r14
 2999               	.LVL244:
 425:FAT32.c       ****   firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
 3000               		.loc 1 425 0
 3001 1036 DC82      		std Y+4,r13
 3002 1038 CB82      		std Y+3,r12
 3003               	.LVL245:
 426:FAT32.c       ****   fileSize = 0;
 3004               		.loc 1 426 0
 3005 103a 1092 0000 		sts fileSize,__zero_reg__
 3006 103e 1092 0000 		sts fileSize+1,__zero_reg__
 3007 1042 1092 0000 		sts fileSize+2,__zero_reg__
 3008 1046 1092 0000 		sts fileSize+3,__zero_reg__
 376:FAT32.c       **** unsigned char j, data, error, fileCreatedFlag = 0, start = 0, appendFile = 0, sectorEndFlag = 0, se
 3009               		.loc 1 376 0
 3010 104a A12C      		mov r10,__zero_reg__
 3011 104c 812C      		mov r8,__zero_reg__
 3012               	.LVL246:
 3013               	.L157:
 3014 104e B12C      		mov r11,__zero_reg__
 436:FAT32.c       **** 	  startBlock = getFirstSector (cluster) + sector;
 3015               		.loc 1 436 0
 3016 1050 4A2C      		mov r4,r10
 3017 1052 512C      		mov r5,__zero_reg__
 3018 1054 612C      		mov r6,__zero_reg__
 3019 1056 712C      		mov r7,__zero_reg__
 3020               	.LVL247:
 433:FAT32.c       ****    if(start)
 3021               		.loc 1 433 0
 3022 1058 8820      		tst r8
 3023 105a 01F0      		breq .L162
 3024               	.LVL248:
 436:FAT32.c       **** 	  startBlock = getFirstSector (cluster) + sector;
 3025               		.loc 1 436 0
 3026 105c C701      		movw r24,r14
 3027 105e B601      		movw r22,r12
 3028 1060 0E94 0000 		call getFirstSector
 3029               	.LVL249:
 3030 1064 640D      		add r22,r4
 3031 1066 751D      		adc r23,r5
 3032 1068 861D      		adc r24,r6
 3033 106a 971D      		adc r25,r7
 3034 106c 6093 0000 		sts startBlock,r22
 3035 1070 7093 0000 		sts startBlock+1,r23
 3036 1074 8093 0000 		sts startBlock+2,r24
 3037 1078 9093 0000 		sts startBlock+3,r25
 437:FAT32.c       **** 	  SD_readSingleBlock (startBlock);
 3038               		.loc 1 437 0
 3039 107c 6091 0000 		lds r22,startBlock
 3040 1080 7091 0000 		lds r23,startBlock+1
 3041 1084 8091 0000 		lds r24,startBlock+2
 3042 1088 9091 0000 		lds r25,startBlock+3
 3043 108c 0E94 0000 		call SD_readSingleBlock
 3044               	.LVL250:
 438:FAT32.c       **** 	  i = fileSize % bytesPerSector;
 3045               		.loc 1 438 0
 3046 1090 2091 0000 		lds r18,bytesPerSector
 3047 1094 3091 0000 		lds r19,bytesPerSector+1
 3048 1098 40E0      		ldi r20,0
 3049 109a 50E0      		ldi r21,0
 3050 109c 6091 0000 		lds r22,fileSize
 3051 10a0 7091 0000 		lds r23,fileSize+1
 3052 10a4 8091 0000 		lds r24,fileSize+2
 3053 10a8 9091 0000 		lds r25,fileSize+3
 3054 10ac 0E94 0000 		call __udivmodsi4
 3055 10b0 3B01      		movw r6,r22
 3056               	.LVL251:
 3057 10b2 00C0      		rjmp .L163
 3058               	.LVL252:
 3059               	.L179:
 523:FAT32.c       ****    getSetNextCluster(prevCluster, SET, cluster);
 3060               		.loc 1 523 0
 3061 10b4 8B01      		movw r16,r22
 3062 10b6 9C01      		movw r18,r24
 3063 10b8 41E0      		ldi r20,lo8(1)
 3064 10ba C701      		movw r24,r14
 3065 10bc B601      		movw r22,r12
 3066 10be 0E94 0000 		call getSetNextCluster
 3067               	.LVL253:
 524:FAT32.c       ****    getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
 3068               		.loc 1 524 0
 3069 10c2 0FEF      		ldi r16,lo8(-1)
 3070 10c4 1FEF      		ldi r17,lo8(-1)
 3071 10c6 2FEF      		ldi r18,lo8(-1)
 3072 10c8 3FE0      		ldi r19,lo8(15)
 3073 10ca 41E0      		ldi r20,lo8(1)
 3074 10cc C301      		movw r24,r6
 3075 10ce B201      		movw r22,r4
 3076 10d0 0E94 0000 		call getSetNextCluster
 3077               	.LVL254:
 525:FAT32.c       **** }        
 3078               		.loc 1 525 0
 3079 10d4 7301      		movw r14,r6
 3080 10d6 6201      		movw r12,r4
 3081               	.LVL255:
 3082               	.L162:
 443:FAT32.c       ****       startBlock = getFirstSector (cluster);
 3083               		.loc 1 443 0
 3084 10d8 C701      		movw r24,r14
 3085 10da B601      		movw r22,r12
 3086 10dc 0E94 0000 		call getFirstSector
 3087               	.LVL256:
 3088 10e0 6093 0000 		sts startBlock,r22
 3089 10e4 7093 0000 		sts startBlock+1,r23
 3090 10e8 8093 0000 		sts startBlock+2,r24
 3091 10ec 9093 0000 		sts startBlock+3,r25
 3092               	.LVL257:
 444:FAT32.c       **** 	  i=0;
 3093               		.loc 1 444 0
 3094 10f0 612C      		mov r6,__zero_reg__
 3095 10f2 712C      		mov r7,__zero_reg__
 445:FAT32.c       **** 	  j=0;
 3096               		.loc 1 445 0
 3097 10f4 A12C      		mov r10,__zero_reg__
 3098               	.LVL258:
 3099               	.L163:
 449:FAT32.c       ****    TX_NEWLINE;
 3100               		.loc 1 449 0
 3101 10f6 8DE0      		ldi r24,lo8(13)
 3102 10f8 0E94 0000 		call transmitByte
 3103               	.LVL259:
 3104 10fc 8AE0      		ldi r24,lo8(10)
 3105 10fe 0E94 0000 		call transmitByte
 3106               	.LVL260:
 450:FAT32.c       ****    transmitString_F(PSTR(" Enter text (end with ~):"));
 3107               		.loc 1 450 0
 3108 1102 80E0      		ldi r24,lo8(__c.1984)
 3109 1104 90E0      		ldi r25,hi8(__c.1984)
 3110 1106 0E94 0000 		call transmitString_F
 3111               	.LVL261:
 3112               	.L164:
 454:FAT32.c       ****      if(sectorEndFlag == 1) //special case when the last character in previous sector was '\r'
 3113               		.loc 1 454 0
 3114 110a 81E0      		ldi r24,lo8(1)
 3115 110c B812      		cpse r11,r24
 3116 110e 00C0      		rjmp .L165
 456:FAT32.c       **** 	 	transmitByte ('\n');
 3117               		.loc 1 456 0
 3118 1110 8AE0      		ldi r24,lo8(10)
 3119 1112 0E94 0000 		call transmitByte
 3120               	.LVL262:
 457:FAT32.c       ****         buffer[i++] = '\n'; //appending 'Line Feed (LF)' character
 3121               		.loc 1 457 0
 3122 1116 F301      		movw r30,r6
 3123 1118 E050      		subi r30,lo8(-(buffer))
 3124 111a F040      		sbci r31,hi8(-(buffer))
 3125 111c 8AE0      		ldi r24,lo8(10)
 3126 111e 8083      		st Z,r24
 458:FAT32.c       **** 		fileSize++;
 3127               		.loc 1 458 0
 3128 1120 8091 0000 		lds r24,fileSize
 3129 1124 9091 0000 		lds r25,fileSize+1
 3130 1128 A091 0000 		lds r26,fileSize+2
 3131 112c B091 0000 		lds r27,fileSize+3
 3132 1130 0196      		adiw r24,1
 3133 1132 A11D      		adc r26,__zero_reg__
 3134 1134 B11D      		adc r27,__zero_reg__
 3135 1136 8093 0000 		sts fileSize,r24
 3136 113a 9093 0000 		sts fileSize+1,r25
 3137 113e A093 0000 		sts fileSize+2,r26
 3138 1142 B093 0000 		sts fileSize+3,r27
 457:FAT32.c       ****         buffer[i++] = '\n'; //appending 'Line Feed (LF)' character
 3139               		.loc 1 457 0
 3140 1146 D301      		movw r26,r6
 3141 1148 1196      		adiw r26,1
 3142               	.LVL263:
 3143 114a 3D01      		movw r6,r26
 3144               	.LVL264:
 3145               	.L165:
 463:FAT32.c       **** 	 data = receiveByte();
 3146               		.loc 1 463 0
 3147 114c 0E94 0000 		call receiveByte
 3148               	.LVL265:
 3149 1150 982E      		mov r9,r24
 3150               	.LVL266:
 464:FAT32.c       **** 	 if(data == 0x08)	//'Back Space' key pressed
 3151               		.loc 1 464 0
 3152 1152 B8E0      		ldi r27,lo8(8)
 3153 1154 8B13      		cpse r24,r27
 3154 1156 00C0      		rjmp .L166
 466:FAT32.c       **** 	   if(i != 0)
 3155               		.loc 1 466 0
 3156 1158 6114      		cp r6,__zero_reg__
 3157 115a 7104      		cpc r7,__zero_reg__
 3158 115c 01F4      		brne .+2
 3159 115e 00C0      		rjmp .L167
 468:FAT32.c       **** 	     transmitByte(data);
 3160               		.loc 1 468 0
 3161 1160 88E0      		ldi r24,lo8(8)
 3162 1162 0E94 0000 		call transmitByte
 3163               	.LVL267:
 469:FAT32.c       **** 		 transmitByte(' '); 
 3164               		.loc 1 469 0
 3165 1166 80E2      		ldi r24,lo8(32)
 3166 1168 0E94 0000 		call transmitByte
 3167               	.LVL268:
 470:FAT32.c       **** 	     transmitByte(data); 
 3168               		.loc 1 470 0
 3169 116c 88E0      		ldi r24,lo8(8)
 3170 116e 0E94 0000 		call transmitByte
 3171               	.LVL269:
 471:FAT32.c       **** 	     i--; 
 3172               		.loc 1 471 0
 3173 1172 E1E0      		ldi r30,1
 3174 1174 6E1A      		sub r6,r30
 3175 1176 7108      		sbc r7,__zero_reg__
 3176               	.LVL270:
 472:FAT32.c       **** 		 fileSize--;
 3177               		.loc 1 472 0
 3178 1178 8091 0000 		lds r24,fileSize
 3179 117c 9091 0000 		lds r25,fileSize+1
 3180 1180 A091 0000 		lds r26,fileSize+2
 3181 1184 B091 0000 		lds r27,fileSize+3
 3182 1188 0197      		sbiw r24,1
 3183 118a A109      		sbc r26,__zero_reg__
 3184 118c B109      		sbc r27,__zero_reg__
 3185 118e 8093 0000 		sts fileSize,r24
 3186 1192 9093 0000 		sts fileSize+1,r25
 3187 1196 A093 0000 		sts fileSize+2,r26
 3188 119a B093 0000 		sts fileSize+3,r27
 3189 119e 00C0      		rjmp .L167
 3190               	.L166:
 476:FAT32.c       **** 	 transmitByte(data);
 3191               		.loc 1 476 0
 3192 11a0 0E94 0000 		call transmitByte
 3193               	.LVL271:
 477:FAT32.c       ****      buffer[i++] = data;
 3194               		.loc 1 477 0
 3195 11a4 8301      		movw r16,r6
 3196 11a6 0F5F      		subi r16,-1
 3197 11a8 1F4F      		sbci r17,-1
 3198               	.LVL272:
 3199 11aa F301      		movw r30,r6
 3200 11ac E050      		subi r30,lo8(-(buffer))
 3201 11ae F040      		sbci r31,hi8(-(buffer))
 3202 11b0 9082      		st Z,r9
 478:FAT32.c       **** 	 fileSize++;
 3203               		.loc 1 478 0
 3204 11b2 8091 0000 		lds r24,fileSize
 3205 11b6 9091 0000 		lds r25,fileSize+1
 3206 11ba A091 0000 		lds r26,fileSize+2
 3207 11be B091 0000 		lds r27,fileSize+3
 3208 11c2 0196      		adiw r24,1
 3209 11c4 A11D      		adc r26,__zero_reg__
 3210 11c6 B11D      		adc r27,__zero_reg__
 3211 11c8 8093 0000 		sts fileSize,r24
 3212 11cc 9093 0000 		sts fileSize+1,r25
 3213 11d0 A093 0000 		sts fileSize+2,r26
 3214 11d4 B093 0000 		sts fileSize+3,r27
 479:FAT32.c       ****      if(data == '\r')  //'Carriege Return (CR)' character
 3215               		.loc 1 479 0
 3216 11d8 FDE0      		ldi r31,lo8(13)
 3217 11da 9F12      		cpse r9,r31
 3218 11dc 00C0      		rjmp .L168
 481:FAT32.c       ****         if(i == 512)
 3219               		.loc 1 481 0
 3220 11de 0115      		cp r16,__zero_reg__
 3221 11e0 22E0      		ldi r18,2
 3222 11e2 1207      		cpc r17,r18
 3223 11e4 01F0      		breq .L195
 485:FAT32.c       **** 		   transmitByte ('\n');
 3224               		.loc 1 485 0
 3225 11e6 8AE0      		ldi r24,lo8(10)
 3226 11e8 0E94 0000 		call transmitByte
 3227               	.LVL273:
 486:FAT32.c       ****            buffer[i++] = '\n'; //appending 'Line Feed (LF)' character
 3228               		.loc 1 486 0
 3229 11ec F801      		movw r30,r16
 3230 11ee E050      		subi r30,lo8(-(buffer))
 3231 11f0 F040      		sbci r31,hi8(-(buffer))
 3232 11f2 8AE0      		ldi r24,lo8(10)
 3233 11f4 8083      		st Z,r24
 487:FAT32.c       **** 		   fileSize++;
 3234               		.loc 1 487 0
 3235 11f6 8091 0000 		lds r24,fileSize
 3236 11fa 9091 0000 		lds r25,fileSize+1
 3237 11fe A091 0000 		lds r26,fileSize+2
 3238 1202 B091 0000 		lds r27,fileSize+3
 3239 1206 0196      		adiw r24,1
 3240 1208 A11D      		adc r26,__zero_reg__
 3241 120a B11D      		adc r27,__zero_reg__
 3242 120c 8093 0000 		sts fileSize,r24
 3243 1210 9093 0000 		sts fileSize+1,r25
 3244 1214 A093 0000 		sts fileSize+2,r26
 3245 1218 B093 0000 		sts fileSize+3,r27
 486:FAT32.c       ****            buffer[i++] = '\n'; //appending 'Line Feed (LF)' character
 3246               		.loc 1 486 0
 3247 121c 8301      		movw r16,r6
 3248 121e 0E5F      		subi r16,-2
 3249 1220 1F4F      		sbci r17,-1
 3250               	.LVL274:
 3251               	.L168:
 3252 1222 B12C      		mov r11,__zero_reg__
 491:FAT32.c       ****      if(i >= 512)   //though 'i' will never become greater than 512, it's kept here to avoid 
 3253               		.loc 1 491 0
 3254 1224 0115      		cp r16,__zero_reg__
 3255 1226 42E0      		ldi r20,2
 3256 1228 1407      		cpc r17,r20
 3257 122a 00F0      		brlo .L170
 3258 122c 00C0      		rjmp .L169
 3259               	.L195:
 482:FAT32.c       **** 		   sectorEndFlag = 1;  //flag to indicate that the appended '\n' char should be put in the next s
 3260               		.loc 1 482 0
 3261 122e BB24      		clr r11
 3262 1230 B394      		inc r11
 3263               	.L169:
 3264               	.LVL275:
 494:FAT32.c       **** 	   error = SD_writeSingleBlock (startBlock);
 3265               		.loc 1 494 0
 3266 1232 6091 0000 		lds r22,startBlock
 3267 1236 7091 0000 		lds r23,startBlock+1
 3268 123a 8091 0000 		lds r24,startBlock+2
 3269 123e 9091 0000 		lds r25,startBlock+3
 3270 1242 0E94 0000 		call SD_writeSingleBlock
 3271               	.LVL276:
 495:FAT32.c       ****        j++;
 3272               		.loc 1 495 0
 3273 1246 A394      		inc r10
 3274               	.LVL277:
 496:FAT32.c       **** 	   if(j == sectorPerCluster) {j = 0; break;}
 3275               		.loc 1 496 0
 3276 1248 4091 0000 		lds r20,sectorPerCluster
 3277 124c 5091 0000 		lds r21,sectorPerCluster+1
 3278 1250 2A2D      		mov r18,r10
 3279 1252 30E0      		ldi r19,0
 3280 1254 2417      		cp r18,r20
 3281 1256 3507      		cpc r19,r21
 3282 1258 01F0      		breq .L171
 497:FAT32.c       **** 	   startBlock++; 
 3283               		.loc 1 497 0
 3284 125a 8091 0000 		lds r24,startBlock
 3285 125e 9091 0000 		lds r25,startBlock+1
 3286 1262 A091 0000 		lds r26,startBlock+2
 3287 1266 B091 0000 		lds r27,startBlock+3
 3288 126a 0196      		adiw r24,1
 3289 126c A11D      		adc r26,__zero_reg__
 3290 126e B11D      		adc r27,__zero_reg__
 3291 1270 8093 0000 		sts startBlock,r24
 3292 1274 9093 0000 		sts startBlock+1,r25
 3293 1278 A093 0000 		sts startBlock+2,r26
 3294 127c B093 0000 		sts startBlock+3,r27
 493:FAT32.c       **** 	   i=0;
 3295               		.loc 1 493 0
 3296 1280 00E0      		ldi r16,0
 3297 1282 10E0      		ldi r17,0
 3298               	.LVL278:
 3299               	.L170:
 499:FAT32.c       **** 	}while (data != '~');
 3300               		.loc 1 499 0
 3301 1284 8EE7      		ldi r24,lo8(126)
 3302 1286 9816      		cp r9,r24
 3303 1288 01F0      		breq .L173
 3304               	.LVL279:
 3305               	.L172:
 445:FAT32.c       **** 	  j=0;
 3306               		.loc 1 445 0
 3307 128a 3801      		movw r6,r16
 3308 128c 00C0      		rjmp .L164
 3309               	.LVL280:
 3310               	.L171:
 501:FAT32.c       ****    if(data == '~') 
 3311               		.loc 1 501 0
 3312 128e 9EE7      		ldi r25,lo8(126)
 3313 1290 9912      		cpse r9,r25
 3314 1292 00C0      		rjmp .L174
 493:FAT32.c       **** 	   i=0;
 3315               		.loc 1 493 0
 3316 1294 00E0      		ldi r16,0
 3317 1296 10E0      		ldi r17,0
 3318               	.LVL281:
 3319               	.L173:
 503:FAT32.c       ****       fileSize--;	//to remove the last entered '~' character
 3320               		.loc 1 503 0
 3321 1298 8091 0000 		lds r24,fileSize
 3322 129c 9091 0000 		lds r25,fileSize+1
 3323 12a0 A091 0000 		lds r26,fileSize+2
 3324 12a4 B091 0000 		lds r27,fileSize+3
 3325 12a8 0197      		sbiw r24,1
 3326 12aa A109      		sbc r26,__zero_reg__
 3327 12ac B109      		sbc r27,__zero_reg__
 3328 12ae 8093 0000 		sts fileSize,r24
 3329 12b2 9093 0000 		sts fileSize+1,r25
 3330 12b6 A093 0000 		sts fileSize+2,r26
 3331 12ba B093 0000 		sts fileSize+3,r27
 504:FAT32.c       **** 	  i--;
 3332               		.loc 1 504 0
 3333 12be 0150      		subi r16,1
 3334 12c0 1109      		sbc r17,__zero_reg__
 3335               	.LVL282:
 3336               	.L175:
 505:FAT32.c       **** 	  for(;i<512;i++)  //fill the rest of the buffer with 0x00
 3337               		.loc 1 505 0 discriminator 1
 3338 12c2 0115      		cp r16,__zero_reg__
 3339 12c4 A2E0      		ldi r26,2
 3340 12c6 1A07      		cpc r17,r26
 3341 12c8 00F4      		brsh .L204
 506:FAT32.c       ****         buffer[i]= 0x00;
 3342               		.loc 1 506 0 discriminator 2
 3343 12ca F801      		movw r30,r16
 3344 12cc E050      		subi r30,lo8(-(buffer))
 3345 12ce F040      		sbci r31,hi8(-(buffer))
 3346 12d0 1082      		st Z,__zero_reg__
 505:FAT32.c       **** 	  for(;i<512;i++)  //fill the rest of the buffer with 0x00
 3347               		.loc 1 505 0 discriminator 2
 3348 12d2 0F5F      		subi r16,-1
 3349 12d4 1F4F      		sbci r17,-1
 3350               	.LVL283:
 3351 12d6 00C0      		rjmp .L175
 3352               	.L204:
 507:FAT32.c       ****    	  error = SD_writeSingleBlock (startBlock);
 3353               		.loc 1 507 0
 3354 12d8 6091 0000 		lds r22,startBlock
 3355 12dc 7091 0000 		lds r23,startBlock+1
 3356 12e0 8091 0000 		lds r24,startBlock+2
 3357 12e4 9091 0000 		lds r25,startBlock+3
 3358 12e8 0E94 0000 		call SD_writeSingleBlock
 3359               	.LVL284:
 527:FAT32.c       **** getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
 3360               		.loc 1 527 0
 3361 12ec A701      		movw r20,r14
 3362 12ee 9601      		movw r18,r12
 3363 12f0 61E0      		ldi r22,lo8(1)
 3364 12f2 82E0      		ldi r24,lo8(2)
 3365 12f4 0E94 0000 		call getSetFreeCluster
 3366               	.LVL285:
 529:FAT32.c       **** error = getDateTime_FAT();    //get current date & time from the RTC
 3367               		.loc 1 529 0
 3368 12f8 0E94 0000 		call getDateTime_FAT
 3369               	.LVL286:
 530:FAT32.c       **** if(error) { dateFAT = 0; timeFAT = 0;}
 3370               		.loc 1 530 0
 3371 12fc 8823      		tst r24
 3372 12fe 01F0      		breq .L178
 530:FAT32.c       **** if(error) { dateFAT = 0; timeFAT = 0;}
 3373               		.loc 1 530 0 is_stmt 0 discriminator 1
 3374 1300 1092 0000 		sts dateFAT+1,__zero_reg__
 3375 1304 1092 0000 		sts dateFAT,__zero_reg__
 3376 1308 1092 0000 		sts timeFAT+1,__zero_reg__
 3377 130c 1092 0000 		sts timeFAT,__zero_reg__
 3378 1310 00C0      		rjmp .L178
 3379               	.LVL287:
 3380               	.L174:
 514:FAT32.c       ****    cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the curren
 3381               		.loc 1 514 0 is_stmt 1
 3382 1312 C701      		movw r24,r14
 3383 1314 B601      		movw r22,r12
 3384 1316 0E94 0000 		call searchNextFreeCluster
 3385               	.LVL288:
 3386 131a 2B01      		movw r4,r22
 3387 131c 3C01      		movw r6,r24
 3388               	.LVL289:
 516:FAT32.c       ****    if(cluster == 0)
 3389               		.loc 1 516 0
 3390 131e 6115      		cp r22,__zero_reg__
 3391 1320 7105      		cpc r23,__zero_reg__
 3392 1322 8105      		cpc r24,__zero_reg__
 3393 1324 9105      		cpc r25,__zero_reg__
 3394 1326 01F0      		breq .+2
 3395 1328 00C0      		rjmp .L179
 518:FAT32.c       ****       TX_NEWLINE;
 3396               		.loc 1 518 0
 3397 132a 8DE0      		ldi r24,lo8(13)
 3398 132c 0E94 0000 		call transmitByte
 3399               	.LVL290:
 3400 1330 8AE0      		ldi r24,lo8(10)
 3401 1332 0E94 0000 		call transmitByte
 3402               	.LVL291:
 519:FAT32.c       ****       transmitString_F(PSTR(" No free cluster!"));
 3403               		.loc 1 519 0
 3404 1336 80E0      		ldi r24,lo8(__c.1993)
 3405 1338 90E0      		ldi r25,hi8(__c.1993)
 3406 133a 00C0      		rjmp .L203
 3407               	.LVL292:
 3408               	.L178:
 532:FAT32.c       **** if(appendFile)  //executes this loop if file is to be appended
 3409               		.loc 1 532 0
 3410 133c 8820      		tst r8
 3411 133e 01F4      		brne .+2
 3412 1340 00C0      		rjmp .L181
 534:FAT32.c       ****   SD_readSingleBlock (appendFileSector);    
 3413               		.loc 1 534 0
 3414 1342 6091 0000 		lds r22,appendFileSector
 3415 1346 7091 0000 		lds r23,appendFileSector+1
 3416 134a 8091 0000 		lds r24,appendFileSector+2
 3417 134e 9091 0000 		lds r25,appendFileSector+3
 3418 1352 0E94 0000 		call SD_readSingleBlock
 3419               	.LVL293:
 535:FAT32.c       ****   dir = (struct dir_Structure *) &buffer[appendFileLocation]; 
 3420               		.loc 1 535 0
 3421 1356 E091 0000 		lds r30,appendFileLocation
 3422 135a F091 0000 		lds r31,appendFileLocation+1
 3423 135e E050      		subi r30,lo8(-(buffer))
 3424 1360 F040      		sbci r31,hi8(-(buffer))
 3425               	.LVL294:
 537:FAT32.c       ****   dir->lastAccessDate = 0;   //date of last access ignored
 3426               		.loc 1 537 0
 3427 1362 138A      		std Z+19,__zero_reg__
 3428 1364 128A      		std Z+18,__zero_reg__
 538:FAT32.c       ****   dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
 3429               		.loc 1 538 0
 3430 1366 8091 0000 		lds r24,timeFAT
 3431 136a 9091 0000 		lds r25,timeFAT+1
 3432 136e 978B      		std Z+23,r25
 3433 1370 868B      		std Z+22,r24
 539:FAT32.c       ****   dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
 3434               		.loc 1 539 0
 3435 1372 8091 0000 		lds r24,dateFAT
 3436 1376 9091 0000 		lds r25,dateFAT+1
 3437 137a 918F      		std Z+25,r25
 3438 137c 808F      		std Z+24,r24
 540:FAT32.c       ****   extraMemory = fileSize - dir->fileSize;
 3439               		.loc 1 540 0
 3440 137e 8091 0000 		lds r24,fileSize
 3441 1382 9091 0000 		lds r25,fileSize+1
 3442 1386 A091 0000 		lds r26,fileSize+2
 3443 138a B091 0000 		lds r27,fileSize+3
 3444 138e 448D      		ldd r20,Z+28
 3445 1390 558D      		ldd r21,Z+29
 3446 1392 668D      		ldd r22,Z+30
 3447 1394 778D      		ldd r23,Z+31
 3448 1396 6C01      		movw r12,r24
 3449 1398 7D01      		movw r14,r26
 3450               	.LVL295:
 3451 139a C41A      		sub r12,r20
 3452 139c D50A      		sbc r13,r21
 3453 139e E60A      		sbc r14,r22
 3454 13a0 F70A      		sbc r15,r23
 3455               	.LVL296:
 541:FAT32.c       ****   dir->fileSize = fileSize;
 3456               		.loc 1 541 0
 3457 13a2 848F      		std Z+28,r24
 3458 13a4 958F      		std Z+29,r25
 3459 13a6 A68F      		std Z+30,r26
 3460 13a8 B78F      		std Z+31,r27
 542:FAT32.c       ****   SD_writeSingleBlock (appendFileSector);
 3461               		.loc 1 542 0
 3462 13aa 6091 0000 		lds r22,appendFileSector
 3463 13ae 7091 0000 		lds r23,appendFileSector+1
 3464 13b2 8091 0000 		lds r24,appendFileSector+2
 3465 13b6 9091 0000 		lds r25,appendFileSector+3
 3466 13ba 0E94 0000 		call SD_writeSingleBlock
 3467               	.LVL297:
 543:FAT32.c       ****   freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
 3468               		.loc 1 543 0
 3469 13be B701      		movw r22,r14
 3470 13c0 A601      		movw r20,r12
 3471 13c2 81E0      		ldi r24,lo8(1)
 3472 13c4 0E94 0000 		call freeMemoryUpdate
 3473               	.LVL298:
 546:FAT32.c       ****   TX_NEWLINE;
 3474               		.loc 1 546 0
 3475 13c8 8DE0      		ldi r24,lo8(13)
 3476 13ca 0E94 0000 		call transmitByte
 3477               	.LVL299:
 3478 13ce 8AE0      		ldi r24,lo8(10)
 3479 13d0 0E94 0000 		call transmitByte
 3480               	.LVL300:
 547:FAT32.c       ****   transmitString_F(PSTR(" File appended!"));
 3481               		.loc 1 547 0
 3482 13d4 80E0      		ldi r24,lo8(__c.1996)
 3483 13d6 90E0      		ldi r25,hi8(__c.1996)
 3484 13d8 0E94 0000 		call transmitString_F
 3485               	.LVL301:
 548:FAT32.c       ****   TX_NEWLINE;
 3486               		.loc 1 548 0
 3487 13dc 8DE0      		ldi r24,lo8(13)
 3488 13de 0E94 0000 		call transmitByte
 3489               	.LVL302:
 3490 13e2 8AE0      		ldi r24,lo8(10)
 3491               	/* epilogue start */
 629:FAT32.c       **** }
 3492               		.loc 1 629 0
 3493 13e4 2896      		adiw r28,8
 3494 13e6 0FB6      		in __tmp_reg__,__SREG__
 3495 13e8 F894      		cli
 3496 13ea DEBF      		out __SP_H__,r29
 3497 13ec 0FBE      		out __SREG__,__tmp_reg__
 3498 13ee CDBF      		out __SP_L__,r28
 3499 13f0 DF91      		pop r29
 3500 13f2 CF91      		pop r28
 3501 13f4 1F91      		pop r17
 3502 13f6 0F91      		pop r16
 3503               	.LVL303:
 3504 13f8 FF90      		pop r15
 3505 13fa EF90      		pop r14
 3506 13fc DF90      		pop r13
 3507 13fe CF90      		pop r12
 3508               	.LVL304:
 3509 1400 BF90      		pop r11
 3510 1402 AF90      		pop r10
 3511               	.LVL305:
 3512 1404 9F90      		pop r9
 3513               	.LVL306:
 3514 1406 8F90      		pop r8
 3515               	.LVL307:
 3516 1408 7F90      		pop r7
 3517 140a 6F90      		pop r6
 3518 140c 5F90      		pop r5
 3519 140e 4F90      		pop r4
 3520 1410 3F90      		pop r3
 3521 1412 2F90      		pop r2
 3522               	.LVL308:
 548:FAT32.c       ****   TX_NEWLINE;
 3523               		.loc 1 548 0
 3524 1414 0C94 0000 		jmp transmitByte
 3525               	.LVL309:
 3526               	.L181:
 555:FAT32.c       **** prevCluster = rootCluster; //root cluster
 3527               		.loc 1 555 0
 3528 1418 C090 0000 		lds r12,rootCluster
 3529 141c D090 0000 		lds r13,rootCluster+1
 3530 1420 E090 0000 		lds r14,rootCluster+2
 3531 1424 F090 0000 		lds r15,rootCluster+3
 3532               	.LVL310:
 376:FAT32.c       **** unsigned char j, data, error, fileCreatedFlag = 0, start = 0, appendFile = 0, sectorEndFlag = 0, se
 3533               		.loc 1 376 0
 3534 1428 1A82      		std Y+2,__zero_reg__
 3535               	.LVL311:
 3536               	.L194:
 559:FAT32.c       ****    firstSector = getFirstSector (prevCluster);
 3537               		.loc 1 559 0
 3538 142a C701      		movw r24,r14
 3539 142c B601      		movw r22,r12
 3540 142e 0E94 0000 		call getFirstSector
 3541               	.LVL312:
 3542 1432 2B01      		movw r4,r22
 3543 1434 3C01      		movw r6,r24
 3544               	.LVL313:
 561:FAT32.c       ****    for(sector = 0; sector < sectorPerCluster; sector++)
 3545               		.loc 1 561 0
 3546 1436 1982      		std Y+1,__zero_reg__
 3547               	.LVL314:
 3548               	.L182:
 561:FAT32.c       ****    for(sector = 0; sector < sectorPerCluster; sector++)
 3549               		.loc 1 561 0 is_stmt 0 discriminator 1
 3550 1438 8091 0000 		lds r24,sectorPerCluster
 3551 143c 9091 0000 		lds r25,sectorPerCluster+1
 3552 1440 4981      		ldd r20,Y+1
 3553 1442 242F      		mov r18,r20
 3554 1444 30E0      		ldi r19,0
 3555 1446 2817      		cp r18,r24
 3556 1448 3907      		cpc r19,r25
 3557 144a 00F0      		brlo .+2
 3558 144c 00C0      		rjmp .L205
 563:FAT32.c       ****      SD_readSingleBlock (firstSector + sector);
 3559               		.loc 1 563 0 is_stmt 1
 3560 144e 5301      		movw r10,r6
 3561 1450 4201      		movw r8,r4
 3562 1452 2981      		ldd r18,Y+1
 3563 1454 820E      		add r8,r18
 3564 1456 911C      		adc r9,__zero_reg__
 3565 1458 A11C      		adc r10,__zero_reg__
 3566 145a B11C      		adc r11,__zero_reg__
 3567 145c C501      		movw r24,r10
 3568 145e B401      		movw r22,r8
 3569 1460 0E94 0000 		call SD_readSingleBlock
 3570               	.LVL315:
 3571 1464 80E0      		ldi r24,lo8(buffer)
 3572 1466 90E0      		ldi r25,hi8(buffer)
 3573 1468 9887      		std Y+8,r25
 3574 146a 8F83      		std Y+7,r24
 566:FAT32.c       ****      for(i=0; i<bytesPerSector; i+=32)
 3575               		.loc 1 566 0
 3576 146c 00E0      		ldi r16,0
 3577 146e 10E0      		ldi r17,0
 3578               	.LVL316:
 3579               	.L183:
 566:FAT32.c       ****      for(i=0; i<bytesPerSector; i+=32)
 3580               		.loc 1 566 0 is_stmt 0 discriminator 1
 3581 1470 8091 0000 		lds r24,bytesPerSector
 3582 1474 9091 0000 		lds r25,bytesPerSector+1
 3583 1478 0817      		cp r16,r24
 3584 147a 1907      		cpc r17,r25
 3585 147c 00F0      		brlo .+2
 3586 147e 00C0      		rjmp .L206
 3587               	.LVL317:
 570:FAT32.c       **** 		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
 3588               		.loc 1 570 0 is_stmt 1
 3589 1480 9A81      		ldd r25,Y+2
 3590 1482 9111      		cpse r25,__zero_reg__
 3591 1484 00C0      		rjmp .L153
 577:FAT32.c       ****         if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to en
 3592               		.loc 1 577 0
 3593 1486 AF81      		ldd r26,Y+7
 3594 1488 B885      		ldd r27,Y+8
 3595 148a 8C91      		ld r24,X
 3596 148c 8823      		tst r24
 3597 148e 01F0      		breq .L185
 577:FAT32.c       ****         if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to en
 3598               		.loc 1 577 0 is_stmt 0 discriminator 1
 3599 1490 853E      		cpi r24,lo8(-27)
 3600 1492 01F0      		breq .+2
 3601 1494 00C0      		rjmp .L186
 3602               	.L185:
 3603 1496 ED81      		ldd r30,Y+5
 3604 1498 FE81      		ldd r31,Y+6
 625:FAT32.c       ****    prevCluster = cluster;
 3605               		.loc 1 625 0 is_stmt 1 discriminator 2
 3606 149a AF81      		ldd r26,Y+7
 3607 149c B885      		ldd r27,Y+8
 3608 149e 8BE0      		ldi r24,lo8(11)
 3609               	.L188:
 3610               	.LVL318:
 580:FAT32.c       ****   			dir->name[j] = fileName[j];
 3611               		.loc 1 580 0 discriminator 2
 3612 14a0 9191      		ld r25,Z+
 3613               	.LVL319:
 3614 14a2 9D93      		st X+,r25
 3615               	.LVL320:
 3616 14a4 8150      		subi r24,lo8(-(-1))
 579:FAT32.c       **** 		  for(j=0; j<11; j++)
 3617               		.loc 1 579 0 discriminator 2
 3618 14a6 01F4      		brne .L188
 3619 14a8 F801      		movw r30,r16
 3620               	.LVL321:
 3621 14aa E050      		subi r30,lo8(-(buffer))
 3622 14ac F040      		sbci r31,hi8(-(buffer))
 581:FAT32.c       **** 		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
 3623               		.loc 1 581 0
 3624 14ae B0E2      		ldi r27,lo8(32)
 3625 14b0 B387      		std Z+11,r27
 582:FAT32.c       **** 		  dir->NTreserved = 0;			//always set to 0
 3626               		.loc 1 582 0
 3627 14b2 1486      		std Z+12,__zero_reg__
 583:FAT32.c       **** 		  dir->timeTenth = 0;			//always set to 0
 3628               		.loc 1 583 0
 3629 14b4 1586      		std Z+13,__zero_reg__
 584:FAT32.c       **** 		  dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
 3630               		.loc 1 584 0
 3631 14b6 8091 0000 		lds r24,timeFAT
 3632 14ba 9091 0000 		lds r25,timeFAT+1
 3633 14be EF81      		ldd r30,Y+7
 3634 14c0 F885      		ldd r31,Y+8
 3635 14c2 9787      		std Z+15,r25
 3636 14c4 8687      		std Z+14,r24
 585:FAT32.c       **** 		  dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
 3637               		.loc 1 585 0
 3638 14c6 2091 0000 		lds r18,dateFAT
 3639 14ca 3091 0000 		lds r19,dateFAT+1
 3640 14ce 318B      		std Z+17,r19
 3641 14d0 208B      		std Z+16,r18
 586:FAT32.c       **** 		  dir->lastAccessDate = 0;   	//date of last access ignored
 3642               		.loc 1 586 0
 3643 14d2 138A      		std Z+19,__zero_reg__
 3644 14d4 128A      		std Z+18,__zero_reg__
 587:FAT32.c       **** 		  dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
 3645               		.loc 1 587 0
 3646 14d6 978B      		std Z+23,r25
 3647 14d8 868B      		std Z+22,r24
 588:FAT32.c       **** 		  dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
 3648               		.loc 1 588 0
 3649 14da 318F      		std Z+25,r19
 3650 14dc 208F      		std Z+24,r18
 589:FAT32.c       **** 		  dir->firstClusterHI = firstClusterHigh;
 3651               		.loc 1 589 0
 3652 14de 358A      		std Z+21,r3
 3653 14e0 248A      		std Z+20,r2
 590:FAT32.c       **** 		  dir->firstClusterLO = firstClusterLow;
 3654               		.loc 1 590 0
 3655 14e2 8B81      		ldd r24,Y+3
 3656 14e4 9C81      		ldd r25,Y+4
 3657 14e6 938F      		std Z+27,r25
 3658 14e8 828F      		std Z+26,r24
 591:FAT32.c       **** 		  dir->fileSize = fileSize;
 3659               		.loc 1 591 0
 3660 14ea 8091 0000 		lds r24,fileSize
 3661 14ee 9091 0000 		lds r25,fileSize+1
 3662 14f2 A091 0000 		lds r26,fileSize+2
 3663 14f6 B091 0000 		lds r27,fileSize+3
 3664 14fa 848F      		std Z+28,r24
 3665 14fc 958F      		std Z+29,r25
 3666 14fe A68F      		std Z+30,r26
 3667 1500 B78F      		std Z+31,r27
 593:FAT32.c       **** 		  SD_writeSingleBlock (firstSector + sector);
 3668               		.loc 1 593 0
 3669 1502 C501      		movw r24,r10
 3670 1504 B401      		movw r22,r8
 3671 1506 0E94 0000 		call SD_writeSingleBlock
 3672               	.LVL322:
 596:FAT32.c       **** 		  TX_NEWLINE;
 3673               		.loc 1 596 0
 3674 150a 8DE0      		ldi r24,lo8(13)
 3675 150c 0E94 0000 		call transmitByte
 3676               	.LVL323:
 3677 1510 8AE0      		ldi r24,lo8(10)
 3678 1512 0E94 0000 		call transmitByte
 3679               	.LVL324:
 597:FAT32.c       **** 		  TX_NEWLINE;
 3680               		.loc 1 597 0
 3681 1516 8DE0      		ldi r24,lo8(13)
 3682 1518 0E94 0000 		call transmitByte
 3683               	.LVL325:
 3684 151c 8AE0      		ldi r24,lo8(10)
 3685 151e 0E94 0000 		call transmitByte
 3686               	.LVL326:
 598:FAT32.c       **** 		  transmitString_F(PSTR(" File Created! "));
 3687               		.loc 1 598 0
 3688 1522 80E0      		ldi r24,lo8(__c.2001)
 3689 1524 90E0      		ldi r25,hi8(__c.2001)
 3690 1526 0E94 0000 		call transmitString_F
 3691               	.LVL327:
 600:FAT32.c       **** 		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
 3692               		.loc 1 600 0
 3693 152a 4091 0000 		lds r20,fileSize
 3694 152e 5091 0000 		lds r21,fileSize+1
 3695 1532 6091 0000 		lds r22,fileSize+2
 3696 1536 7091 0000 		lds r23,fileSize+3
 3697 153a 81E0      		ldi r24,lo8(1)
 3698 153c 0E94 0000 		call freeMemoryUpdate
 3699               	.LVL328:
 594:FAT32.c       **** 		  fileCreatedFlag = 1;
 3700               		.loc 1 594 0
 3701 1540 F1E0      		ldi r31,lo8(1)
 3702 1542 FA83      		std Y+2,r31
 3703               	.LVL329:
 3704               	.L186:
 566:FAT32.c       ****      for(i=0; i<bytesPerSector; i+=32)
 3705               		.loc 1 566 0
 3706 1544 005E      		subi r16,-32
 3707 1546 1F4F      		sbci r17,-1
 3708               	.LVL330:
 3709 1548 8F81      		ldd r24,Y+7
 3710 154a 9885      		ldd r25,Y+8
 3711 154c 8096      		adiw r24,32
 3712 154e 9887      		std Y+8,r25
 3713 1550 8F83      		std Y+7,r24
 3714 1552 00C0      		rjmp .L183
 3715               	.LVL331:
 3716               	.L206:
 561:FAT32.c       ****    for(sector = 0; sector < sectorPerCluster; sector++)
 3717               		.loc 1 561 0
 3718 1554 2981      		ldd r18,Y+1
 3719 1556 2F5F      		subi r18,lo8(-(1))
 3720 1558 2983      		std Y+1,r18
 3721               	.LVL332:
 3722 155a 00C0      		rjmp .L182
 3723               	.LVL333:
 3724               	.L205:
 606:FAT32.c       ****    cluster = getSetNextCluster (prevCluster, GET, 0);
 3725               		.loc 1 606 0
 3726 155c 00E0      		ldi r16,0
 3727 155e 10E0      		ldi r17,0
 3728 1560 9801      		movw r18,r16
 3729 1562 40E0      		ldi r20,0
 3730 1564 C701      		movw r24,r14
 3731 1566 B601      		movw r22,r12
 3732 1568 0E94 0000 		call getSetNextCluster
 3733               	.LVL334:
 3734 156c 4B01      		movw r8,r22
 3735 156e 5C01      		movw r10,r24
 3736               	.LVL335:
 608:FAT32.c       ****    if(cluster > 0x0ffffff6)
 3737               		.loc 1 608 0
 3738 1570 87EF      		ldi r24,-9
 3739 1572 8816      		cp r8,r24
 3740 1574 8FEF      		ldi r24,-1
 3741 1576 9806      		cpc r9,r24
 3742 1578 A806      		cpc r10,r24
 3743 157a 8FE0      		ldi r24,15
 3744 157c B806      		cpc r11,r24
 3745 157e 00F0      		brlo .L191
 610:FAT32.c       ****       if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*s
 3746               		.loc 1 610 0
 3747 1580 9FEF      		ldi r25,-1
 3748 1582 8916      		cp r8,r25
 3749 1584 9906      		cpc r9,r25
 3750 1586 A906      		cpc r10,r25
 3751 1588 9FE0      		ldi r25,15
 3752 158a B906      		cpc r11,r25
 3753 158c 01F4      		brne .L192
 612:FAT32.c       **** 		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
 3754               		.loc 1 612 0
 3755 158e C701      		movw r24,r14
 3756 1590 B601      		movw r22,r12
 3757 1592 0E94 0000 		call searchNextFreeCluster
 3758               	.LVL336:
 3759 1596 4B01      		movw r8,r22
 3760 1598 5C01      		movw r10,r24
 3761               	.LVL337:
 613:FAT32.c       **** 		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous clus
 3762               		.loc 1 613 0
 3763 159a 8B01      		movw r16,r22
 3764 159c 9C01      		movw r18,r24
 3765 159e 41E0      		ldi r20,lo8(1)
 3766 15a0 C701      		movw r24,r14
 3767 15a2 B601      		movw r22,r12
 3768 15a4 0E94 0000 		call getSetNextCluster
 3769               	.LVL338:
 614:FAT32.c       **** 		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
 3770               		.loc 1 614 0
 3771 15a8 0FEF      		ldi r16,lo8(-1)
 3772 15aa 1FEF      		ldi r17,lo8(-1)
 3773 15ac 2FEF      		ldi r18,lo8(-1)
 3774 15ae 3FE0      		ldi r19,lo8(15)
 3775 15b0 41E0      		ldi r20,lo8(1)
 3776 15b2 C501      		movw r24,r10
 3777 15b4 B401      		movw r22,r8
 3778 15b6 0E94 0000 		call getSetNextCluster
 3779               	.LVL339:
 3780 15ba 00C0      		rjmp .L191
 3781               	.L192:
 619:FAT32.c       **** 	    transmitString_F(PSTR("End of Cluster Chain")); 
 3782               		.loc 1 619 0
 3783 15bc 80E0      		ldi r24,lo8(__c.2009)
 3784 15be 90E0      		ldi r25,hi8(__c.2009)
 3785 15c0 00C0      		rjmp .L203
 3786               	.L191:
 623:FAT32.c       ****    if(cluster == 0) {transmitString_F(PSTR("Error in getting cluster")); return;}
 3787               		.loc 1 623 0
 3788 15c2 8114      		cp r8,__zero_reg__
 3789 15c4 9104      		cpc r9,__zero_reg__
 3790 15c6 A104      		cpc r10,__zero_reg__
 3791 15c8 B104      		cpc r11,__zero_reg__
 3792 15ca 01F0      		breq .L193
 625:FAT32.c       ****    prevCluster = cluster;
 3793               		.loc 1 625 0
 3794 15cc 7501      		movw r14,r10
 3795 15ce 6401      		movw r12,r8
 3796               	.LVL340:
 3797 15d0 00C0      		rjmp .L194
 3798               	.LVL341:
 3799               	.L193:
 623:FAT32.c       ****    if(cluster == 0) {transmitString_F(PSTR("Error in getting cluster")); return;}
 3800               		.loc 1 623 0 discriminator 1
 3801 15d2 80E0      		ldi r24,lo8(__c.2011)
 3802 15d4 90E0      		ldi r25,hi8(__c.2011)
 3803               	.LVL342:
 3804               	.L203:
 3805               	/* epilogue start */
 629:FAT32.c       **** }
 3806               		.loc 1 629 0 discriminator 1
 3807 15d6 2896      		adiw r28,8
 3808 15d8 0FB6      		in __tmp_reg__,__SREG__
 3809 15da F894      		cli
 3810 15dc DEBF      		out __SP_H__,r29
 3811 15de 0FBE      		out __SREG__,__tmp_reg__
 3812 15e0 CDBF      		out __SP_L__,r28
 3813 15e2 DF91      		pop r29
 3814 15e4 CF91      		pop r28
 3815 15e6 1F91      		pop r17
 3816 15e8 0F91      		pop r16
 3817 15ea FF90      		pop r15
 3818 15ec EF90      		pop r14
 3819 15ee DF90      		pop r13
 3820 15f0 CF90      		pop r12
 3821 15f2 BF90      		pop r11
 3822 15f4 AF90      		pop r10
 3823 15f6 9F90      		pop r9
 3824 15f8 8F90      		pop r8
 3825 15fa 7F90      		pop r7
 3826 15fc 6F90      		pop r6
 3827 15fe 5F90      		pop r5
 3828 1600 4F90      		pop r4
 3829 1602 3F90      		pop r3
 3830 1604 2F90      		pop r2
 623:FAT32.c       ****    if(cluster == 0) {transmitString_F(PSTR("Error in getting cluster")); return;}
 3831               		.loc 1 623 0 discriminator 1
 3832 1606 0C94 0000 		jmp transmitString_F
 3833               	.LVL343:
 3834               	.L167:
 445:FAT32.c       **** 	  j=0;
 3835               		.loc 1 445 0
 3836 160a 8301      		movw r16,r6
 3837 160c B12C      		mov r11,__zero_reg__
 3838 160e 00C0      		rjmp .L172
 3839               	.LVL344:
 3840               	.L153:
 3841               	/* epilogue start */
 629:FAT32.c       **** }
 3842               		.loc 1 629 0
 3843 1610 2896      		adiw r28,8
 3844 1612 0FB6      		in __tmp_reg__,__SREG__
 3845 1614 F894      		cli
 3846 1616 DEBF      		out __SP_H__,r29
 3847 1618 0FBE      		out __SREG__,__tmp_reg__
 3848 161a CDBF      		out __SP_L__,r28
 3849 161c DF91      		pop r29
 3850 161e CF91      		pop r28
 3851 1620 1F91      		pop r17
 3852 1622 0F91      		pop r16
 3853 1624 FF90      		pop r15
 3854 1626 EF90      		pop r14
 3855 1628 DF90      		pop r13
 3856 162a CF90      		pop r12
 3857 162c BF90      		pop r11
 3858 162e AF90      		pop r10
 3859 1630 9F90      		pop r9
 3860 1632 8F90      		pop r8
 3861 1634 7F90      		pop r7
 3862 1636 6F90      		pop r6
 3863 1638 5F90      		pop r5
 3864 163a 4F90      		pop r4
 3865 163c 3F90      		pop r3
 3866 163e 2F90      		pop r2
 3867 1640 0895      		ret
 3868               		.cfi_endproc
 3869               	.LFE8:
 3871               		.section	.progmem.data,"a",@progbits
 3874               	__c.2045:
 3875 0000 2046 7265 		.string	" Free Memory: "
 3875      6520 4D65 
 3875      6D6F 7279 
 3875      3A20 00
 3878               	__c.2038:
 3879 000f 546F 7461 		.string	"Total Memory: "
 3879      6C20 4D65 
 3879      6D6F 7279 
 3879      3A20 00
 3882               	__c.2011:
 3883 001e 4572 726F 		.string	"Error in getting cluster"
 3883      7220 696E 
 3883      2067 6574 
 3883      7469 6E67 
 3883      2063 6C75 
 3886               	__c.2009:
 3887 0037 456E 6420 		.string	"End of Cluster Chain"
 3887      6F66 2043 
 3887      6C75 7374 
 3887      6572 2043 
 3887      6861 696E 
 3890               	__c.2001:
 3891 004c 2046 696C 		.string	" File Created! "
 3891      6520 4372 
 3891      6561 7465 
 3891      6421 2000 
 3894               	__c.1996:
 3895 005c 2046 696C 		.string	" File appended!"
 3895      6520 6170 
 3895      7065 6E64 
 3895      6564 2100 
 3898               	__c.1993:
 3899 006c 204E 6F20 		.string	" No free cluster!"
 3899      6672 6565 
 3899      2063 6C75 
 3899      7374 6572 
 3899      2100 
 3902               	__c.1984:
 3903 007e 2045 6E74 		.string	" Enter text (end with ~):"
 3903      6572 2074 
 3903      6578 7420 
 3903      2865 6E64 
 3903      2077 6974 
 3906               	__c.1982:
 3907 0098 204E 6F20 		.string	" No free cluster!"
 3907      6672 6565 
 3907      2063 6C75 
 3907      7374 6572 
 3907      2100 
 3910               	__c.1980:
 3911 00aa 2043 7265 		.string	" Creating File.."
 3911      6174 696E 
 3911      6720 4669 
 3911      6C65 2E2E 
 3911      00
 3914               	__c.1976:
 3915 00bb 2046 696C 		.string	" File already exists, appending data.."
 3915      6520 616C 
 3915      7265 6164 
 3915      7920 6578 
 3915      6973 7473 
 3918               	__c.1935:
 3919 00e2 496E 7661 		.string	"Invalid fileName.."
 3919      6C69 6420 
 3919      6669 6C65 
 3919      4E61 6D65 
 3919      2E2E 00
 3922               	__c.1923:
 3923 00f5 4572 726F 		.string	"Error in getting cluster"
 3923      7220 696E 
 3923      2067 6574 
 3923      7469 6E67 
 3923      2063 6C75 
 3926               	__c.1902:
 3927 010e 4572 726F 		.string	"Error in getting cluster"
 3927      7220 696E 
 3927      2067 6574 
 3927      7469 6E67 
 3927      2063 6C75 
 3930               	__c.1894:
 3931 0127 524F 4F54 		.string	"ROOT"
 3931      00
 3934               	__c.1892:
 3935 012c 4449 5200 		.string	"DIR"
 3938               	__c.1890:
 3939 0130 2020 2000 		.string	"   "
 3942               	__c.1888:
 3943 0134 4649 4C45 		.string	"FILE"
 3943      00
 3946               	__c.1886:
 3947 0139 2020 2000 		.string	"   "
 3950               	__c.1880:
 3951 013d 4669 6C65 		.string	"File deleted!"
 3951      2064 656C 
 3951      6574 6564 
 3951      2100 
 3954               	__c.1878:
 3955 014b 4465 6C65 		.string	"Deleting.."
 3955      7469 6E67 
 3955      2E2E 00
 3958               	__c.1873:
 3959 0156 4669 6C65 		.string	"File does not exist!"
 3959      2064 6F65 
 3959      7320 6E6F 
 3959      7420 6578 
 3959      6973 7421 
 3960               		.comm	rtc_register,7,1
 3961               		.comm	timeFAT,2,1
 3962               		.comm	dateFAT,2,1
 3963               		.comm	buffer,512,1
 3964               		.comm	cardType,1,1
 3965               		.comm	SDHC_flag,1,1
 3966               		.comm	totalBlocks,4,1
 3967               		.comm	startBlock,4,1
 3968               		.comm	freeClusterCountUpdated,1,1
 3969               		.comm	appendStartCluster,4,1
 3970               		.comm	fileSize,4,1
 3971               		.comm	appendFileLocation,4,1
 3972               		.comm	appendFileSector,4,1
 3973               		.comm	unusedSectors,4,1
 3974               		.comm	reservedSectorCount,2,1
 3975               		.comm	sectorPerCluster,2,1
 3976               		.comm	bytesPerSector,2,1
 3977               		.comm	totalClusters,4,1
 3978               		.comm	rootCluster,4,1
 3979               		.comm	firstDataSector,4,1
 3980               		.text
 3981               	.Letext0:
 3982               		.file 2 "FAT32.h"
 3983               		.file 3 "SD_routines.h"
 3984               		.file 4 "RTC_routines.h"
 3985               		.file 5 "UART_routines.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 FAT32.c
     /tmp/ccQ54FTa.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccQ54FTa.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccQ54FTa.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccQ54FTa.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccQ54FTa.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccQ54FTa.s:12     .text:0000000000000000 getFirstSector
                            *COM*:0000000000000002 sectorPerCluster
                            *COM*:0000000000000004 firstDataSector
     /tmp/ccQ54FTa.s:69     .text:0000000000000042 getSetNextCluster
                            *COM*:0000000000000002 reservedSectorCount
                            *COM*:0000000000000002 bytesPerSector
                            *COM*:0000000000000004 unusedSectors
                            *COM*:0000000000000200 buffer
     /tmp/ccQ54FTa.s:269    .text:000000000000012e getSetFreeCluster
     /tmp/ccQ54FTa.s:461    .text:0000000000000266 getBootSectorData
                            *COM*:0000000000000004 rootCluster
                            *COM*:0000000000000004 totalClusters
                            *COM*:0000000000000001 freeClusterCountUpdated
     /tmp/ccQ54FTa.s:653    .text:00000000000003fc convertFileName
     /tmp/ccQ54FTa.s:3918   .progmem.data:00000000000000e2 __c.1935
     /tmp/ccQ54FTa.s:842    .text:00000000000004d2 searchNextFreeCluster
     /tmp/ccQ54FTa.s:1032   .text:00000000000005c4 displayMemory
     /tmp/ccQ54FTa.s:1210   .text:0000000000000688 memoryStatistics
     /tmp/ccQ54FTa.s:3878   .progmem.data:000000000000000f __c.2038
     /tmp/ccQ54FTa.s:3874   .progmem.data:0000000000000000 __c.2045
     /tmp/ccQ54FTa.s:1587   .text:00000000000008e2 freeMemoryUpdate
     /tmp/ccQ54FTa.s:1750   .text:00000000000009a2 findFiles
     /tmp/ccQ54FTa.s:3958   .progmem.data:0000000000000156 __c.1873
     /tmp/ccQ54FTa.s:3946   .progmem.data:0000000000000139 __c.1886
     /tmp/ccQ54FTa.s:3942   .progmem.data:0000000000000134 __c.1888
     /tmp/ccQ54FTa.s:3938   .progmem.data:0000000000000130 __c.1890
     /tmp/ccQ54FTa.s:3934   .progmem.data:000000000000012c __c.1892
     /tmp/ccQ54FTa.s:3930   .progmem.data:0000000000000127 __c.1894
     /tmp/ccQ54FTa.s:3926   .progmem.data:000000000000010e __c.1902
                            *COM*:0000000000000004 appendFileSector
                            *COM*:0000000000000004 appendFileLocation
                            *COM*:0000000000000004 appendStartCluster
                            *COM*:0000000000000004 fileSize
     /tmp/ccQ54FTa.s:3954   .progmem.data:000000000000014b __c.1878
     /tmp/ccQ54FTa.s:3950   .progmem.data:000000000000013d __c.1880
     /tmp/ccQ54FTa.s:2353   .text:0000000000000d14 readFile
     /tmp/ccQ54FTa.s:3922   .progmem.data:00000000000000f5 __c.1923
     /tmp/ccQ54FTa.s:2677   .text:0000000000000ea0 deleteFile
     /tmp/ccQ54FTa.s:2725   .text:0000000000000ec0 writeFile
     /tmp/ccQ54FTa.s:3914   .progmem.data:00000000000000bb __c.1976
     /tmp/ccQ54FTa.s:3910   .progmem.data:00000000000000aa __c.1980
     /tmp/ccQ54FTa.s:3906   .progmem.data:0000000000000098 __c.1982
                            *COM*:0000000000000004 startBlock
     /tmp/ccQ54FTa.s:3902   .progmem.data:000000000000007e __c.1984
                            *COM*:0000000000000002 dateFAT
                            *COM*:0000000000000002 timeFAT
     /tmp/ccQ54FTa.s:3898   .progmem.data:000000000000006c __c.1993
     /tmp/ccQ54FTa.s:3894   .progmem.data:000000000000005c __c.1996
     /tmp/ccQ54FTa.s:3890   .progmem.data:000000000000004c __c.2001
     /tmp/ccQ54FTa.s:3886   .progmem.data:0000000000000037 __c.2009
     /tmp/ccQ54FTa.s:3882   .progmem.data:000000000000001e __c.2011
                            *COM*:0000000000000007 rtc_register
                            *COM*:0000000000000001 cardType
                            *COM*:0000000000000001 SDHC_flag
                            *COM*:0000000000000004 totalBlocks

UNDEFINED SYMBOLS
__muluhisi3
__udivmodsi4
SD_readSingleBlock
SD_writeSingleBlock
transmitString_F
transmitString
transmitByte
__umulhisi3
__mulsi3
receiveByte
getDateTime_FAT
__do_copy_data
__do_clear_bss
