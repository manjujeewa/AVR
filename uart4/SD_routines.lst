   1               		.file	"SD_routines.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	SD_sendCommand
  12               	SD_sendCommand:
  13               	.LFB2:
  14               		.file 1 "SD_routines.c"
   1:SD_routines.c **** //**************************************************************
   2:SD_routines.c **** // ****** FUNCTIONS FOR SD RAW DATA TRANSFER *******
   3:SD_routines.c **** //**************************************************************
   4:SD_routines.c **** //Controller: ATmega32 (Clock: 8 Mhz-internal)
   5:SD_routines.c **** //Compiler	: AVR-GCC (winAVR with AVRStudio)
   6:SD_routines.c **** //Project V.: Version - 2.4.1
   7:SD_routines.c **** //Author	: CC Dharmani, Chennai (India)
   8:SD_routines.c **** //			  www.dharmanitech.com
   9:SD_routines.c **** //Date		: 24 Apr 2011
  10:SD_routines.c **** //**************************************************************
  11:SD_routines.c **** 
  12:SD_routines.c **** //Link to the Post: http://www.dharmanitech.com/2009/01/sd-card-interfacing-with-atmega8-fat32.html
  13:SD_routines.c **** 
  14:SD_routines.c **** #include <avr/io.h>
  15:SD_routines.c **** #include <avr/pgmspace.h>
  16:SD_routines.c **** #include "SPI_routines.h"
  17:SD_routines.c **** #include "SD_routines.h"
  18:SD_routines.c **** #include "UART_routines.h"
  19:SD_routines.c **** 
  20:SD_routines.c **** //******************************************************************
  21:SD_routines.c **** //Function	: to initialize the SD/SDHC card in SPI mode
  22:SD_routines.c **** //Arguments	: none
  23:SD_routines.c **** //return	: unsigned char; will be 0 if no error,
  24:SD_routines.c **** // 			  otherwise the response byte will be sent
  25:SD_routines.c **** //******************************************************************
  26:SD_routines.c **** unsigned char SD_init(void)
  27:SD_routines.c **** {
  28:SD_routines.c **** unsigned char i, response, SD_version;
  29:SD_routines.c **** unsigned int retry=0 ;
  30:SD_routines.c **** 
  31:SD_routines.c ****  for(i=0;i<10;i++)
  32:SD_routines.c ****       SPI_transmit(0xff);   //80 clock pulses spent before sending the first command
  33:SD_routines.c **** 
  34:SD_routines.c **** SD_CS_ASSERT;
  35:SD_routines.c **** do
  36:SD_routines.c **** {
  37:SD_routines.c ****   
  38:SD_routines.c ****    response = SD_sendCommand(GO_IDLE_STATE, 0); //send 'reset & go idle' command
  39:SD_routines.c ****    retry++;
  40:SD_routines.c ****    if(retry>0x20) 
  41:SD_routines.c ****    	  return 1;   //time out, card not detected
  42:SD_routines.c ****    
  43:SD_routines.c **** } while(response != 0x01);
  44:SD_routines.c **** 
  45:SD_routines.c **** SD_CS_DEASSERT;
  46:SD_routines.c **** SPI_transmit (0xff);
  47:SD_routines.c **** SPI_transmit (0xff);
  48:SD_routines.c **** 
  49:SD_routines.c **** retry = 0;
  50:SD_routines.c **** 
  51:SD_routines.c **** SD_version = 2; //default set to SD compliance with ver2.x; 
  52:SD_routines.c **** 				//this may change after checking the next command
  53:SD_routines.c **** do
  54:SD_routines.c **** {
  55:SD_routines.c **** response = SD_sendCommand(SEND_IF_COND,0x000001AA); //Check power supply status, mendatory for SDHC
  56:SD_routines.c **** retry++;
  57:SD_routines.c **** if(retry>0xfe) 
  58:SD_routines.c ****    {
  59:SD_routines.c **** 	  TX_NEWLINE;
  60:SD_routines.c **** 	  SD_version = 1;
  61:SD_routines.c **** 	  cardType = 1;
  62:SD_routines.c **** 	  break;
  63:SD_routines.c ****    } //time out
  64:SD_routines.c **** 
  65:SD_routines.c **** }while(response != 0x01);
  66:SD_routines.c **** 
  67:SD_routines.c **** retry = 0;
  68:SD_routines.c **** 
  69:SD_routines.c **** do
  70:SD_routines.c **** {
  71:SD_routines.c **** response = SD_sendCommand(APP_CMD,0); //CMD55, must be sent before sending any ACMD command
  72:SD_routines.c **** response = SD_sendCommand(SD_SEND_OP_COND,0x40000000); //ACMD41
  73:SD_routines.c **** 
  74:SD_routines.c **** retry++;
  75:SD_routines.c **** if(retry>0xfe) 
  76:SD_routines.c ****    {
  77:SD_routines.c ****       TX_NEWLINE;
  78:SD_routines.c **** 	  return 2;  //time out, card initialization failed
  79:SD_routines.c ****    } 
  80:SD_routines.c **** 
  81:SD_routines.c **** }while(response != 0x00);
  82:SD_routines.c **** 
  83:SD_routines.c **** 
  84:SD_routines.c **** retry = 0;
  85:SD_routines.c **** SDHC_flag = 0;
  86:SD_routines.c **** 
  87:SD_routines.c **** if (SD_version == 2)
  88:SD_routines.c **** { 
  89:SD_routines.c ****    do
  90:SD_routines.c ****    {
  91:SD_routines.c **** 	 response = SD_sendCommand(READ_OCR,0);
  92:SD_routines.c **** 	 retry++;
  93:SD_routines.c **** 	 if(retry>0xfe) 
  94:SD_routines.c ****      {
  95:SD_routines.c ****        TX_NEWLINE;
  96:SD_routines.c **** 	   cardType = 0;
  97:SD_routines.c **** 	   break;
  98:SD_routines.c ****      } //time out
  99:SD_routines.c **** 
 100:SD_routines.c ****    }while(response != 0x00);
 101:SD_routines.c **** 
 102:SD_routines.c ****    if(SDHC_flag == 1) cardType = 2;
 103:SD_routines.c ****    else cardType = 3;
 104:SD_routines.c **** }
 105:SD_routines.c **** 
 106:SD_routines.c **** //SD_sendCommand(CRC_ON_OFF, OFF); //disable CRC; deafault - CRC disabled in SPI mode
 107:SD_routines.c **** //SD_sendCommand(SET_BLOCK_LEN, 512); //set block size to 512; default size is 512
 108:SD_routines.c **** 
 109:SD_routines.c **** 
 110:SD_routines.c **** return 0; //successful return
 111:SD_routines.c **** }
 112:SD_routines.c **** 
 113:SD_routines.c **** //******************************************************************
 114:SD_routines.c **** //Function	: to send a command to SD card
 115:SD_routines.c **** //Arguments	: unsigned char (8-bit command value)
 116:SD_routines.c **** // 			  & unsigned long (32-bit command argument)
 117:SD_routines.c **** //return	: unsigned char; response byte
 118:SD_routines.c **** //******************************************************************
 119:SD_routines.c **** unsigned char SD_sendCommand(unsigned char cmd, unsigned long arg)
 120:SD_routines.c **** {
  15               		.loc 1 120 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 FF92      		push r15
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 15, -2
  22 0002 0F93      		push r16
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 16, -3
  26 0004 1F93      		push r17
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 17, -4
  30 0006 CF93      		push r28
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 28, -5
  34 0008 DF93      		push r29
  35               	.LCFI4:
  36               		.cfi_def_cfa_offset 7
  37               		.cfi_offset 29, -6
  38 000a 00D0      		rcall .
  39 000c 00D0      		rcall .
  40               	.LCFI5:
  41               		.cfi_def_cfa_offset 11
  42 000e CDB7      		in r28,__SP_L__
  43 0010 DEB7      		in r29,__SP_H__
  44               	.LCFI6:
  45               		.cfi_def_cfa_register 28
  46               	/* prologue: function */
  47               	/* frame size = 4 */
  48               	/* stack size = 9 */
  49               	.L__stack_usage = 9
  50 0012 082F      		mov r16,r24
  51               	.LVL1:
 121:SD_routines.c **** unsigned char response, retry=0, status;
 122:SD_routines.c **** 
 123:SD_routines.c **** //SD card accepts byte address while SDHC accepts block address in multiples of 512
 124:SD_routines.c **** //so, if it's SD card we need to convert block address into corresponding byte address by 
 125:SD_routines.c **** //multipying it with 512. which is equivalent to shifting it left 9 times
 126:SD_routines.c **** //following 'if' loop does that
 127:SD_routines.c **** 
 128:SD_routines.c **** if(SDHC_flag == 0)		
  52               		.loc 1 128 0
  53 0014 8091 0000 		lds r24,SDHC_flag
  54               	.LVL2:
  55 0018 8111      		cpse r24,__zero_reg__
  56 001a 00C0      		rjmp .L2
 129:SD_routines.c **** if(cmd == READ_SINGLE_BLOCK     ||
  57               		.loc 1 129 0
  58 001c 8FEE      		ldi r24,lo8(-17)
  59 001e 800F      		add r24,r16
  60 0020 8230      		cpi r24,lo8(2)
  61 0022 00F0      		brlo .L3
 130:SD_routines.c ****    cmd == READ_MULTIPLE_BLOCKS  ||
  62               		.loc 1 130 0
  63 0024 88EE      		ldi r24,lo8(-24)
  64 0026 800F      		add r24,r16
  65 0028 8230      		cpi r24,lo8(2)
  66 002a 00F0      		brlo .L3
 131:SD_routines.c ****    cmd == WRITE_SINGLE_BLOCK    ||
 132:SD_routines.c ****    cmd == WRITE_MULTIPLE_BLOCKS ||
  67               		.loc 1 132 0
  68 002c 80EE      		ldi r24,lo8(-32)
  69 002e 800F      		add r24,r16
  70 0030 8230      		cpi r24,lo8(2)
  71 0032 00F4      		brsh .L2
  72               	.L3:
 133:SD_routines.c ****    cmd == ERASE_BLOCK_START_ADDR|| 
 134:SD_routines.c ****    cmd == ERASE_BLOCK_END_ADDR ) 
 135:SD_routines.c ****    {
 136:SD_routines.c ****      arg = arg << 9;
  73               		.loc 1 136 0
  74 0034 89E0      		ldi r24,9
  75               		1:
  76 0036 440F      		lsl r20
  77 0038 551F      		rol r21
  78 003a 661F      		rol r22
  79 003c 771F      		rol r23
  80 003e 8A95      		dec r24
  81 0040 01F4      		brne 1b
  82               	.LVL3:
  83               	.L2:
 137:SD_routines.c ****    }	   
 138:SD_routines.c **** 
 139:SD_routines.c **** SD_CS_ASSERT;
  84               		.loc 1 139 0
  85 0042 C498      		cbi 0x18,4
 140:SD_routines.c **** 
 141:SD_routines.c **** SPI_transmit(cmd | 0x40); //send command, first two bits always '01'
  86               		.loc 1 141 0
  87 0044 802F      		mov r24,r16
  88 0046 8064      		ori r24,lo8(64)
  89 0048 4983      		std Y+1,r20
  90 004a 5A83      		std Y+2,r21
  91 004c 6B83      		std Y+3,r22
  92 004e 7C83      		std Y+4,r23
  93 0050 0E94 0000 		call SPI_transmit
  94               	.LVL4:
 142:SD_routines.c **** SPI_transmit(arg>>24);
  95               		.loc 1 142 0
  96 0054 7C81      		ldd r23,Y+4
  97 0056 872F      		mov r24,r23
  98 0058 0E94 0000 		call SPI_transmit
  99               	.LVL5:
 143:SD_routines.c **** SPI_transmit(arg>>16);
 100               		.loc 1 143 0
 101 005c 6B81      		ldd r22,Y+3
 102 005e 862F      		mov r24,r22
 103 0060 0E94 0000 		call SPI_transmit
 104               	.LVL6:
 144:SD_routines.c **** SPI_transmit(arg>>8);
 105               		.loc 1 144 0
 106 0064 5A81      		ldd r21,Y+2
 107 0066 852F      		mov r24,r21
 108 0068 0E94 0000 		call SPI_transmit
 109               	.LVL7:
 145:SD_routines.c **** SPI_transmit(arg);
 110               		.loc 1 145 0
 111 006c 4981      		ldd r20,Y+1
 112 006e 842F      		mov r24,r20
 113 0070 0E94 0000 		call SPI_transmit
 114               	.LVL8:
 146:SD_routines.c **** 
 147:SD_routines.c **** if(cmd == SEND_IF_COND)	 //it is compulsory to send correct CRC for CMD8 (CRC=0x87) & CMD0 (CRC=0x9
 115               		.loc 1 147 0
 116 0074 0830      		cpi r16,lo8(8)
 117 0076 01F4      		brne .L4
 148:SD_routines.c ****   SPI_transmit(0x87);    //for remaining commands, CRC is ignored in SPI mode
 118               		.loc 1 148 0
 119 0078 87E8      		ldi r24,lo8(-121)
 120 007a 00C0      		rjmp .L15
 121               	.L4:
 149:SD_routines.c **** else 
 150:SD_routines.c ****   SPI_transmit(0x95); 
 122               		.loc 1 150 0
 123 007c 85E9      		ldi r24,lo8(-107)
 124               	.L15:
 125 007e 0E94 0000 		call SPI_transmit
 126               	.LVL9:
 120:SD_routines.c **** {
 127               		.loc 1 120 0
 128 0082 10E0      		ldi r17,0
 129               	.LVL10:
 130               	.L7:
 151:SD_routines.c **** 
 152:SD_routines.c **** while((response = SPI_receive()) == 0xff) //wait response
 131               		.loc 1 152 0 discriminator 1
 132 0084 0E94 0000 		call SPI_receive
 133               	.LVL11:
 134 0088 F82E      		mov r15,r24
 135               	.LVL12:
 136 008a 8FEF      		ldi r24,lo8(-1)
 137 008c F812      		cpse r15,r24
 138 008e 00C0      		rjmp .L17
 139               	.LVL13:
 140 0090 1150      		subi r17,lo8(-(-1))
 141               	.LVL14:
 153:SD_routines.c ****    if(retry++ > 0xfe) break; //time out error
 142               		.loc 1 153 0
 143 0092 01F4      		brne .L7
 144 0094 00C0      		rjmp .L6
 145               	.L17:
 154:SD_routines.c **** 
 155:SD_routines.c **** if(response == 0x00 && cmd == 58)  //checking response of CMD58
 146               		.loc 1 155 0
 147 0096 F110      		cpse r15,__zero_reg__
 148 0098 00C0      		rjmp .L6
 149               		.loc 1 155 0 is_stmt 0 discriminator 1
 150 009a 0A33      		cpi r16,lo8(58)
 151 009c 01F4      		brne .L6
 156:SD_routines.c **** {
 157:SD_routines.c ****   status = SPI_receive() & 0x40;     //first byte of the OCR register (bit 31:24)
 152               		.loc 1 157 0 is_stmt 1
 153 009e 0E94 0000 		call SPI_receive
 154               	.LVL15:
 158:SD_routines.c ****   if(status == 0x40) SDHC_flag = 1;  //we need it to verify SDHC card
 155               		.loc 1 158 0
 156 00a2 86FF      		sbrs r24,6
 157 00a4 00C0      		rjmp .L9
 158               		.loc 1 158 0 is_stmt 0 discriminator 1
 159 00a6 81E0      		ldi r24,lo8(1)
 160               	.LVL16:
 161 00a8 8093 0000 		sts SDHC_flag,r24
 162 00ac 00C0      		rjmp .L10
 163               	.LVL17:
 164               	.L9:
 159:SD_routines.c ****   else SDHC_flag = 0;
 165               		.loc 1 159 0 is_stmt 1
 166 00ae 1092 0000 		sts SDHC_flag,__zero_reg__
 167               	.LVL18:
 168               	.L10:
 160:SD_routines.c **** 
 161:SD_routines.c ****   SPI_receive(); //remaining 3 bytes of the OCR register are ignored here
 169               		.loc 1 161 0
 170 00b2 0E94 0000 		call SPI_receive
 171               	.LVL19:
 162:SD_routines.c ****   SPI_receive(); //one can use these bytes to check power supply limits of SD
 172               		.loc 1 162 0
 173 00b6 0E94 0000 		call SPI_receive
 174               	.LVL20:
 163:SD_routines.c ****   SPI_receive(); 
 175               		.loc 1 163 0
 176 00ba 0E94 0000 		call SPI_receive
 177               	.LVL21:
 178 00be F12C      		mov r15,__zero_reg__
 179               	.LVL22:
 180               	.L6:
 164:SD_routines.c **** }
 165:SD_routines.c **** 
 166:SD_routines.c **** SPI_receive(); //extra 8 CLK
 181               		.loc 1 166 0
 182 00c0 0E94 0000 		call SPI_receive
 183               	.LVL23:
 167:SD_routines.c **** SD_CS_DEASSERT;
 184               		.loc 1 167 0
 185 00c4 C49A      		sbi 0x18,4
 168:SD_routines.c **** 
 169:SD_routines.c **** return response; //return state
 170:SD_routines.c **** }
 186               		.loc 1 170 0
 187 00c6 8F2D      		mov r24,r15
 188               	/* epilogue start */
 189 00c8 0F90      		pop __tmp_reg__
 190 00ca 0F90      		pop __tmp_reg__
 191 00cc 0F90      		pop __tmp_reg__
 192 00ce 0F90      		pop __tmp_reg__
 193 00d0 DF91      		pop r29
 194 00d2 CF91      		pop r28
 195 00d4 1F91      		pop r17
 196 00d6 0F91      		pop r16
 197               	.LVL24:
 198 00d8 FF90      		pop r15
 199 00da 0895      		ret
 200               		.cfi_endproc
 201               	.LFE2:
 203               	.global	SD_init
 205               	SD_init:
 206               	.LFB1:
  27:SD_routines.c **** {
 207               		.loc 1 27 0
 208               		.cfi_startproc
 209 00dc 0F93      		push r16
 210               	.LCFI7:
 211               		.cfi_def_cfa_offset 3
 212               		.cfi_offset 16, -2
 213 00de 1F93      		push r17
 214               	.LCFI8:
 215               		.cfi_def_cfa_offset 4
 216               		.cfi_offset 17, -3
 217 00e0 CF93      		push r28
 218               	.LCFI9:
 219               		.cfi_def_cfa_offset 5
 220               		.cfi_offset 28, -4
 221 00e2 DF93      		push r29
 222               	.LCFI10:
 223               		.cfi_def_cfa_offset 6
 224               		.cfi_offset 29, -5
 225               	/* prologue: function */
 226               	/* frame size = 0 */
 227               	/* stack size = 4 */
 228               	.L__stack_usage = 4
 229               	.LVL25:
  27:SD_routines.c **** {
 230               		.loc 1 27 0
 231 00e4 1AE0      		ldi r17,lo8(10)
 232               	.LVL26:
 233               	.L20:
  32:SD_routines.c ****       SPI_transmit(0xff);   //80 clock pulses spent before sending the first command
 234               		.loc 1 32 0 discriminator 2
 235 00e6 8FEF      		ldi r24,lo8(-1)
 236 00e8 0E94 0000 		call SPI_transmit
 237               	.LVL27:
 238 00ec 1150      		subi r17,lo8(-(-1))
 239               	.LVL28:
  31:SD_routines.c ****  for(i=0;i<10;i++)
 240               		.loc 1 31 0 discriminator 2
 241 00ee 01F4      		brne .L20
  34:SD_routines.c **** SD_CS_ASSERT;
 242               		.loc 1 34 0
 243 00f0 C498      		cbi 0x18,4
 244 00f2 C1E2      		ldi r28,lo8(33)
 245 00f4 D0E0      		ldi r29,0
 246               	.LVL29:
 247               	.L23:
  38:SD_routines.c ****    response = SD_sendCommand(GO_IDLE_STATE, 0); //send 'reset & go idle' command
 248               		.loc 1 38 0
 249 00f6 40E0      		ldi r20,0
 250 00f8 50E0      		ldi r21,0
 251 00fa BA01      		movw r22,r20
 252 00fc 80E0      		ldi r24,0
 253 00fe 0E94 0000 		call SD_sendCommand
 254               	.LVL30:
 255 0102 2197      		sbiw r28,1
 256               	.LVL31:
  40:SD_routines.c ****    if(retry>0x20) 
 257               		.loc 1 40 0
 258 0104 2097      		sbiw r28,0
 259 0106 01F4      		brne .+2
 260 0108 00C0      		rjmp .L34
 261               	.LVL32:
  43:SD_routines.c **** } while(response != 0x01);
 262               		.loc 1 43 0
 263 010a 8130      		cpi r24,lo8(1)
 264 010c 01F4      		brne .L23
  45:SD_routines.c **** SD_CS_DEASSERT;
 265               		.loc 1 45 0
 266 010e C49A      		sbi 0x18,4
  46:SD_routines.c **** SPI_transmit (0xff);
 267               		.loc 1 46 0
 268 0110 8FEF      		ldi r24,lo8(-1)
 269               	.LVL33:
 270 0112 0E94 0000 		call SPI_transmit
 271               	.LVL34:
  47:SD_routines.c **** SPI_transmit (0xff);
 272               		.loc 1 47 0
 273 0116 8FEF      		ldi r24,lo8(-1)
 274 0118 0E94 0000 		call SPI_transmit
 275               	.LVL35:
 276 011c CFEF      		ldi r28,lo8(-1)
 277 011e D0E0      		ldi r29,0
 278               	.LVL36:
 279               	.L26:
  55:SD_routines.c **** response = SD_sendCommand(SEND_IF_COND,0x000001AA); //Check power supply status, mendatory for SDHC
 280               		.loc 1 55 0
 281 0120 4AEA      		ldi r20,lo8(-86)
 282 0122 51E0      		ldi r21,lo8(1)
 283 0124 60E0      		ldi r22,0
 284 0126 70E0      		ldi r23,0
 285 0128 88E0      		ldi r24,lo8(8)
 286 012a 0E94 0000 		call SD_sendCommand
 287               	.LVL37:
 288 012e 2197      		sbiw r28,1
 289               	.LVL38:
  57:SD_routines.c **** if(retry>0xfe) 
 290               		.loc 1 57 0
 291 0130 2097      		sbiw r28,0
 292 0132 01F4      		brne .L24
  59:SD_routines.c **** 	  TX_NEWLINE;
 293               		.loc 1 59 0
 294 0134 8DE0      		ldi r24,lo8(13)
 295               	.LVL39:
 296 0136 0E94 0000 		call transmitByte
 297               	.LVL40:
 298 013a 8AE0      		ldi r24,lo8(10)
 299 013c 0E94 0000 		call transmitByte
 300               	.LVL41:
  61:SD_routines.c **** 	  cardType = 1;
 301               		.loc 1 61 0
 302 0140 81E0      		ldi r24,lo8(1)
 303 0142 8093 0000 		sts cardType,r24
  60:SD_routines.c **** 	  SD_version = 1;
 304               		.loc 1 60 0
 305 0146 01E0      		ldi r16,lo8(1)
  62:SD_routines.c **** 	  break;
 306               		.loc 1 62 0
 307 0148 00C0      		rjmp .L25
 308               	.LVL42:
 309               	.L24:
  65:SD_routines.c **** }while(response != 0x01);
 310               		.loc 1 65 0
 311 014a 8130      		cpi r24,lo8(1)
 312 014c 01F4      		brne .L26
  51:SD_routines.c **** SD_version = 2; //default set to SD compliance with ver2.x; 
 313               		.loc 1 51 0
 314 014e 02E0      		ldi r16,lo8(2)
 315               	.LVL43:
 316               	.L25:
 317 0150 CFEF      		ldi r28,lo8(-1)
 318 0152 D0E0      		ldi r29,0
 319               	.LVL44:
 320               	.L29:
  71:SD_routines.c **** response = SD_sendCommand(APP_CMD,0); //CMD55, must be sent before sending any ACMD command
 321               		.loc 1 71 0
 322 0154 40E0      		ldi r20,0
 323 0156 50E0      		ldi r21,0
 324 0158 BA01      		movw r22,r20
 325 015a 87E3      		ldi r24,lo8(55)
 326 015c 0E94 0000 		call SD_sendCommand
 327               	.LVL45:
  72:SD_routines.c **** response = SD_sendCommand(SD_SEND_OP_COND,0x40000000); //ACMD41
 328               		.loc 1 72 0
 329 0160 40E0      		ldi r20,0
 330 0162 50E0      		ldi r21,0
 331 0164 60E0      		ldi r22,0
 332 0166 70E4      		ldi r23,lo8(64)
 333 0168 89E2      		ldi r24,lo8(41)
 334 016a 0E94 0000 		call SD_sendCommand
 335               	.LVL46:
 336 016e 2197      		sbiw r28,1
 337               	.LVL47:
  75:SD_routines.c **** if(retry>0xfe) 
 338               		.loc 1 75 0
 339 0170 2097      		sbiw r28,0
 340 0172 01F4      		brne .L27
  77:SD_routines.c ****       TX_NEWLINE;
 341               		.loc 1 77 0
 342 0174 8DE0      		ldi r24,lo8(13)
 343               	.LVL48:
 344 0176 0E94 0000 		call transmitByte
 345               	.LVL49:
 346 017a 8AE0      		ldi r24,lo8(10)
 347 017c 0E94 0000 		call transmitByte
 348               	.LVL50:
  78:SD_routines.c **** 	  return 2;  //time out, card initialization failed
 349               		.loc 1 78 0
 350 0180 12E0      		ldi r17,lo8(2)
 351               	.LVL51:
 352 0182 00C0      		rjmp .L21
 353               	.LVL52:
 354               	.L27:
  81:SD_routines.c **** }while(response != 0x00);
 355               		.loc 1 81 0
 356 0184 8111      		cpse r24,__zero_reg__
 357 0186 00C0      		rjmp .L29
 358               	.LVL53:
  85:SD_routines.c **** SDHC_flag = 0;
 359               		.loc 1 85 0
 360 0188 1092 0000 		sts SDHC_flag,__zero_reg__
  87:SD_routines.c **** if (SD_version == 2)
 361               		.loc 1 87 0
 362 018c 0230      		cpi r16,lo8(2)
 363 018e 01F4      		brne .L21
 364 0190 CFEF      		ldi r28,lo8(-1)
 365 0192 D0E0      		ldi r29,0
 366               	.LVL54:
 367               	.L32:
  91:SD_routines.c **** 	 response = SD_sendCommand(READ_OCR,0);
 368               		.loc 1 91 0
 369 0194 40E0      		ldi r20,0
 370 0196 50E0      		ldi r21,0
 371 0198 BA01      		movw r22,r20
 372 019a 8AE3      		ldi r24,lo8(58)
 373               	.LVL55:
 374 019c 0E94 0000 		call SD_sendCommand
 375               	.LVL56:
 376 01a0 2197      		sbiw r28,1
 377               	.LVL57:
  93:SD_routines.c **** 	 if(retry>0xfe) 
 378               		.loc 1 93 0
 379 01a2 2097      		sbiw r28,0
 380 01a4 01F4      		brne .L30
  95:SD_routines.c ****        TX_NEWLINE;
 381               		.loc 1 95 0
 382 01a6 8DE0      		ldi r24,lo8(13)
 383               	.LVL58:
 384 01a8 0E94 0000 		call transmitByte
 385               	.LVL59:
 386 01ac 8AE0      		ldi r24,lo8(10)
 387 01ae 0E94 0000 		call transmitByte
 388               	.LVL60:
  96:SD_routines.c **** 	   cardType = 0;
 389               		.loc 1 96 0
 390 01b2 1092 0000 		sts cardType,__zero_reg__
  97:SD_routines.c **** 	   break;
 391               		.loc 1 97 0
 392 01b6 00C0      		rjmp .L31
 393               	.LVL61:
 394               	.L30:
 100:SD_routines.c ****    }while(response != 0x00);
 395               		.loc 1 100 0
 396 01b8 8111      		cpse r24,__zero_reg__
 397 01ba 00C0      		rjmp .L32
 398               	.LVL62:
 399               	.L31:
 102:SD_routines.c ****    if(SDHC_flag == 1) cardType = 2;
 400               		.loc 1 102 0
 401 01bc 8091 0000 		lds r24,SDHC_flag
 402 01c0 8130      		cpi r24,lo8(1)
 403 01c2 01F4      		brne .L33
 102:SD_routines.c ****    if(SDHC_flag == 1) cardType = 2;
 404               		.loc 1 102 0 is_stmt 0 discriminator 1
 405 01c4 82E0      		ldi r24,lo8(2)
 406 01c6 00C0      		rjmp .L39
 407               	.L33:
 103:SD_routines.c ****    else cardType = 3;
 408               		.loc 1 103 0 is_stmt 1
 409 01c8 83E0      		ldi r24,lo8(3)
 410               	.L39:
 411 01ca 8093 0000 		sts cardType,r24
 412 01ce 00C0      		rjmp .L21
 413               	.LVL63:
 414               	.L34:
  41:SD_routines.c ****    	  return 1;   //time out, card not detected
 415               		.loc 1 41 0
 416 01d0 11E0      		ldi r17,lo8(1)
 417               	.LVL64:
 418               	.L21:
 111:SD_routines.c **** }
 419               		.loc 1 111 0
 420 01d2 812F      		mov r24,r17
 421               	/* epilogue start */
 422 01d4 DF91      		pop r29
 423 01d6 CF91      		pop r28
 424 01d8 1F91      		pop r17
 425 01da 0F91      		pop r16
 426 01dc 0895      		ret
 427               		.cfi_endproc
 428               	.LFE1:
 430               	.global	SD_erase
 432               	SD_erase:
 433               	.LFB3:
 171:SD_routines.c **** 
 172:SD_routines.c **** //*****************************************************************
 173:SD_routines.c **** //Function	: to erase specified no. of blocks of SD card
 174:SD_routines.c **** //Arguments	: none
 175:SD_routines.c **** //return	: unsigned char; will be 0 if no error,
 176:SD_routines.c **** // 			  otherwise the response byte will be sent
 177:SD_routines.c **** //*****************************************************************
 178:SD_routines.c **** unsigned char SD_erase (unsigned long startBlock, unsigned long totalBlocks)
 179:SD_routines.c **** {
 434               		.loc 1 179 0
 435               		.cfi_startproc
 436               	.LVL65:
 437 01de 8F92      		push r8
 438               	.LCFI11:
 439               		.cfi_def_cfa_offset 3
 440               		.cfi_offset 8, -2
 441 01e0 9F92      		push r9
 442               	.LCFI12:
 443               		.cfi_def_cfa_offset 4
 444               		.cfi_offset 9, -3
 445 01e2 AF92      		push r10
 446               	.LCFI13:
 447               		.cfi_def_cfa_offset 5
 448               		.cfi_offset 10, -4
 449 01e4 BF92      		push r11
 450               	.LCFI14:
 451               		.cfi_def_cfa_offset 6
 452               		.cfi_offset 11, -5
 453 01e6 CF92      		push r12
 454               	.LCFI15:
 455               		.cfi_def_cfa_offset 7
 456               		.cfi_offset 12, -6
 457 01e8 DF92      		push r13
 458               	.LCFI16:
 459               		.cfi_def_cfa_offset 8
 460               		.cfi_offset 13, -7
 461 01ea EF92      		push r14
 462               	.LCFI17:
 463               		.cfi_def_cfa_offset 9
 464               		.cfi_offset 14, -8
 465 01ec FF92      		push r15
 466               	.LCFI18:
 467               		.cfi_def_cfa_offset 10
 468               		.cfi_offset 15, -9
 469               	/* prologue: function */
 470               	/* frame size = 0 */
 471               	/* stack size = 8 */
 472               	.L__stack_usage = 8
 473 01ee 6B01      		movw r12,r22
 474 01f0 7C01      		movw r14,r24
 475 01f2 4901      		movw r8,r18
 476 01f4 5A01      		movw r10,r20
 180:SD_routines.c **** unsigned char response;
 181:SD_routines.c **** 
 182:SD_routines.c **** response = SD_sendCommand(ERASE_BLOCK_START_ADDR, startBlock); //send starting block address
 477               		.loc 1 182 0
 478 01f6 AB01      		movw r20,r22
 479 01f8 BC01      		movw r22,r24
 480 01fa 80E2      		ldi r24,lo8(32)
 481 01fc 0E94 0000 		call SD_sendCommand
 482               	.LVL66:
 183:SD_routines.c **** if(response != 0x00) //check for SD status: 0x00 - OK (No flags set)
 483               		.loc 1 183 0
 484 0200 8111      		cpse r24,__zero_reg__
 485 0202 00C0      		rjmp .L41
 184:SD_routines.c ****   return response;
 185:SD_routines.c **** 
 186:SD_routines.c **** response = SD_sendCommand(ERASE_BLOCK_END_ADDR,(startBlock + totalBlocks - 1)); //send end block ad
 486               		.loc 1 186 0
 487 0204 B501      		movw r22,r10
 488 0206 A401      		movw r20,r8
 489 0208 4150      		subi r20,1
 490 020a 5109      		sbc r21,__zero_reg__
 491 020c 6109      		sbc r22,__zero_reg__
 492 020e 7109      		sbc r23,__zero_reg__
 493 0210 4C0D      		add r20,r12
 494 0212 5D1D      		adc r21,r13
 495 0214 6E1D      		adc r22,r14
 496 0216 7F1D      		adc r23,r15
 497 0218 81E2      		ldi r24,lo8(33)
 498               	.LVL67:
 499 021a 0E94 0000 		call SD_sendCommand
 500               	.LVL68:
 187:SD_routines.c **** if(response != 0x00)
 501               		.loc 1 187 0
 502 021e 8111      		cpse r24,__zero_reg__
 503 0220 00C0      		rjmp .L41
 188:SD_routines.c ****   return response;
 189:SD_routines.c **** 
 190:SD_routines.c **** response = SD_sendCommand(ERASE_SELECTED_BLOCKS, 0); //erase all selected blocks
 504               		.loc 1 190 0
 505 0222 40E0      		ldi r20,0
 506 0224 50E0      		ldi r21,0
 507 0226 BA01      		movw r22,r20
 508 0228 86E2      		ldi r24,lo8(38)
 509               	.LVL69:
 510               	/* epilogue start */
 191:SD_routines.c **** if(response != 0x00)
 192:SD_routines.c ****   return response;
 193:SD_routines.c **** 
 194:SD_routines.c **** return 0; //normal return
 195:SD_routines.c **** }
 511               		.loc 1 195 0
 512 022a FF90      		pop r15
 513 022c EF90      		pop r14
 514 022e DF90      		pop r13
 515 0230 CF90      		pop r12
 516               	.LVL70:
 517 0232 BF90      		pop r11
 518 0234 AF90      		pop r10
 519 0236 9F90      		pop r9
 520 0238 8F90      		pop r8
 521               	.LVL71:
 190:SD_routines.c **** response = SD_sendCommand(ERASE_SELECTED_BLOCKS, 0); //erase all selected blocks
 522               		.loc 1 190 0
 523 023a 0C94 0000 		jmp SD_sendCommand
 524               	.LVL72:
 525               	.L41:
 526               	/* epilogue start */
 527               		.loc 1 195 0
 528 023e FF90      		pop r15
 529 0240 EF90      		pop r14
 530 0242 DF90      		pop r13
 531 0244 CF90      		pop r12
 532               	.LVL73:
 533 0246 BF90      		pop r11
 534 0248 AF90      		pop r10
 535 024a 9F90      		pop r9
 536 024c 8F90      		pop r8
 537               	.LVL74:
 538 024e 0895      		ret
 539               		.cfi_endproc
 540               	.LFE3:
 542               	.global	SD_readSingleBlock
 544               	SD_readSingleBlock:
 545               	.LFB4:
 196:SD_routines.c **** 
 197:SD_routines.c **** //******************************************************************
 198:SD_routines.c **** //Function	: to read a single block from SD card
 199:SD_routines.c **** //Arguments	: none
 200:SD_routines.c **** //return	: unsigned char; will be 0 if no error,
 201:SD_routines.c **** // 			  otherwise the response byte will be sent
 202:SD_routines.c **** //******************************************************************
 203:SD_routines.c **** unsigned char SD_readSingleBlock(unsigned long startBlock)
 204:SD_routines.c **** {
 546               		.loc 1 204 0
 547               		.cfi_startproc
 548               	.LVL75:
 549 0250 CF93      		push r28
 550               	.LCFI19:
 551               		.cfi_def_cfa_offset 3
 552               		.cfi_offset 28, -2
 553 0252 DF93      		push r29
 554               	.LCFI20:
 555               		.cfi_def_cfa_offset 4
 556               		.cfi_offset 29, -3
 557               	/* prologue: function */
 558               	/* frame size = 0 */
 559               	/* stack size = 2 */
 560               	.L__stack_usage = 2
 561 0254 AB01      		movw r20,r22
 562 0256 BC01      		movw r22,r24
 563               	.LVL76:
 205:SD_routines.c **** unsigned char response;
 206:SD_routines.c **** unsigned int i, retry=0;
 207:SD_routines.c **** 
 208:SD_routines.c ****  response = SD_sendCommand(READ_SINGLE_BLOCK, startBlock); //read a Block command
 564               		.loc 1 208 0
 565 0258 81E1      		ldi r24,lo8(17)
 566 025a 0E94 0000 		call SD_sendCommand
 567               	.LVL77:
 209:SD_routines.c ****  
 210:SD_routines.c ****  if(response != 0x00) return response; //check for SD status: 0x00 - OK (No flags set)
 568               		.loc 1 210 0
 569 025e 8111      		cpse r24,__zero_reg__
 570 0260 00C0      		rjmp .L45
 211:SD_routines.c **** 
 212:SD_routines.c **** SD_CS_ASSERT;
 571               		.loc 1 212 0
 572 0262 C498      		cbi 0x18,4
 213:SD_routines.c **** 
 214:SD_routines.c **** retry = 0;
 215:SD_routines.c **** while(SPI_receive() != 0xfe) //wait for start block token 0xfe (0x11111110)
 573               		.loc 1 215 0
 574 0264 C0E0      		ldi r28,0
 575 0266 D0E0      		ldi r29,0
 576               	.LVL78:
 577               	.L46:
 578               		.loc 1 215 0 is_stmt 0 discriminator 1
 579 0268 0E94 0000 		call SPI_receive
 580               	.LVL79:
 581 026c 8E3F      		cpi r24,lo8(-2)
 582 026e 01F0      		breq .L52
 583               	.LVL80:
 584 0270 2197      		sbiw r28,1
 585               	.LVL81:
 216:SD_routines.c ****   if(retry++ > 0xfffe){SD_CS_DEASSERT; return 1;} //return if time-out
 586               		.loc 1 216 0 is_stmt 1
 587 0272 2097      		sbiw r28,0
 588 0274 01F4      		brne .L46
 589               		.loc 1 216 0 is_stmt 0 discriminator 1
 590 0276 C49A      		sbi 0x18,4
 591 0278 81E0      		ldi r24,lo8(1)
 592 027a 00C0      		rjmp .L45
 593               	.L52:
 215:SD_routines.c **** while(SPI_receive() != 0xfe) //wait for start block token 0xfe (0x11111110)
 594               		.loc 1 215 0 is_stmt 1
 595 027c C0E0      		ldi r28,0
 596 027e D0E0      		ldi r29,0
 597               	.LVL82:
 598               	.L50:
 217:SD_routines.c **** 
 218:SD_routines.c **** for(i=0; i<512; i++) //read 512 bytes
 219:SD_routines.c ****   buffer[i] = SPI_receive();
 599               		.loc 1 219 0 discriminator 2
 600 0280 0E94 0000 		call SPI_receive
 601               	.LVL83:
 602 0284 FE01      		movw r30,r28
 603 0286 E050      		subi r30,lo8(-(buffer))
 604 0288 F040      		sbci r31,hi8(-(buffer))
 605 028a 8083      		st Z,r24
 218:SD_routines.c **** for(i=0; i<512; i++) //read 512 bytes
 606               		.loc 1 218 0 discriminator 2
 607 028c 2196      		adiw r28,1
 608               	.LVL84:
 609 028e C115      		cp r28,__zero_reg__
 610 0290 82E0      		ldi r24,2
 611 0292 D807      		cpc r29,r24
 612 0294 01F4      		brne .L50
 220:SD_routines.c **** 
 221:SD_routines.c **** SPI_receive(); //receive incoming CRC (16-bit), CRC is ignored here
 613               		.loc 1 221 0
 614 0296 0E94 0000 		call SPI_receive
 615               	.LVL85:
 222:SD_routines.c **** SPI_receive();
 616               		.loc 1 222 0
 617 029a 0E94 0000 		call SPI_receive
 618               	.LVL86:
 223:SD_routines.c **** 
 224:SD_routines.c **** SPI_receive(); //extra 8 clock pulses
 619               		.loc 1 224 0
 620 029e 0E94 0000 		call SPI_receive
 621               	.LVL87:
 225:SD_routines.c **** SD_CS_DEASSERT;
 622               		.loc 1 225 0
 623 02a2 C49A      		sbi 0x18,4
 226:SD_routines.c **** 
 227:SD_routines.c **** return 0;
 624               		.loc 1 227 0
 625 02a4 80E0      		ldi r24,0
 626               	.LVL88:
 627               	.L45:
 628               	/* epilogue start */
 228:SD_routines.c **** }
 629               		.loc 1 228 0
 630 02a6 DF91      		pop r29
 631 02a8 CF91      		pop r28
 632 02aa 0895      		ret
 633               		.cfi_endproc
 634               	.LFE4:
 636               	.global	SD_writeSingleBlock
 638               	SD_writeSingleBlock:
 639               	.LFB5:
 229:SD_routines.c **** 
 230:SD_routines.c **** //******************************************************************
 231:SD_routines.c **** //Function	: to write to a single block of SD card
 232:SD_routines.c **** //Arguments	: none
 233:SD_routines.c **** //return	: unsigned char; will be 0 if no error,
 234:SD_routines.c **** // 			  otherwise the response byte will be sent
 235:SD_routines.c **** //******************************************************************
 236:SD_routines.c **** unsigned char SD_writeSingleBlock(unsigned long startBlock)
 237:SD_routines.c **** {
 640               		.loc 1 237 0
 641               		.cfi_startproc
 642               	.LVL89:
 643 02ac CF93      		push r28
 644               	.LCFI21:
 645               		.cfi_def_cfa_offset 3
 646               		.cfi_offset 28, -2
 647 02ae DF93      		push r29
 648               	.LCFI22:
 649               		.cfi_def_cfa_offset 4
 650               		.cfi_offset 29, -3
 651               	/* prologue: function */
 652               	/* frame size = 0 */
 653               	/* stack size = 2 */
 654               	.L__stack_usage = 2
 655 02b0 AB01      		movw r20,r22
 656 02b2 BC01      		movw r22,r24
 657               	.LVL90:
 238:SD_routines.c **** unsigned char response;
 239:SD_routines.c **** unsigned int i, retry=0;
 240:SD_routines.c **** 
 241:SD_routines.c ****  response = SD_sendCommand(WRITE_SINGLE_BLOCK, startBlock); //write a Block command
 658               		.loc 1 241 0
 659 02b4 88E1      		ldi r24,lo8(24)
 660 02b6 0E94 0000 		call SD_sendCommand
 661               	.LVL91:
 242:SD_routines.c ****   
 243:SD_routines.c ****  if(response != 0x00) return response; //check for SD status: 0x00 - OK (No flags set)
 662               		.loc 1 243 0
 663 02ba 8111      		cpse r24,__zero_reg__
 664 02bc 00C0      		rjmp .L54
 244:SD_routines.c **** 
 245:SD_routines.c **** SD_CS_ASSERT;
 665               		.loc 1 245 0
 666 02be C498      		cbi 0x18,4
 246:SD_routines.c **** 
 247:SD_routines.c **** SPI_transmit(0xfe);     //Send start block token 0xfe (0x11111110)
 667               		.loc 1 247 0
 668 02c0 8EEF      		ldi r24,lo8(-2)
 669               	.LVL92:
 670 02c2 0E94 0000 		call SPI_transmit
 671               	.LVL93:
 248:SD_routines.c **** 
 249:SD_routines.c **** for(i=0; i<512; i++)    //send 512 bytes data
 672               		.loc 1 249 0
 673 02c6 C0E0      		ldi r28,0
 674 02c8 D0E0      		ldi r29,0
 675               	.LVL94:
 676               	.L56:
 250:SD_routines.c ****   SPI_transmit(buffer[i]);
 677               		.loc 1 250 0 discriminator 2
 678 02ca FE01      		movw r30,r28
 679 02cc E050      		subi r30,lo8(-(buffer))
 680 02ce F040      		sbci r31,hi8(-(buffer))
 681 02d0 8081      		ld r24,Z
 682 02d2 0E94 0000 		call SPI_transmit
 683               	.LVL95:
 249:SD_routines.c **** for(i=0; i<512; i++)    //send 512 bytes data
 684               		.loc 1 249 0 discriminator 2
 685 02d6 2196      		adiw r28,1
 686               	.LVL96:
 687 02d8 C115      		cp r28,__zero_reg__
 688 02da 22E0      		ldi r18,2
 689 02dc D207      		cpc r29,r18
 690 02de 01F4      		brne .L56
 251:SD_routines.c **** 
 252:SD_routines.c **** SPI_transmit(0xff);     //transmit dummy CRC (16-bit), CRC is ignored here
 691               		.loc 1 252 0
 692 02e0 8FEF      		ldi r24,lo8(-1)
 693 02e2 0E94 0000 		call SPI_transmit
 694               	.LVL97:
 253:SD_routines.c **** SPI_transmit(0xff);
 695               		.loc 1 253 0
 696 02e6 8FEF      		ldi r24,lo8(-1)
 697 02e8 0E94 0000 		call SPI_transmit
 698               	.LVL98:
 254:SD_routines.c **** 
 255:SD_routines.c **** response = SPI_receive();
 699               		.loc 1 255 0
 700 02ec 0E94 0000 		call SPI_receive
 701               	.LVL99:
 256:SD_routines.c **** 
 257:SD_routines.c **** if( (response & 0x1f) != 0x05) //response= 0xXXX0AAA1 ; AAA='010' - data accepted
 702               		.loc 1 257 0
 703 02f0 982F      		mov r25,r24
 704 02f2 9F71      		andi r25,lo8(31)
 705 02f4 9530      		cpi r25,lo8(5)
 706 02f6 01F0      		breq .L57
 258:SD_routines.c **** {                              //AAA='101'-data rejected due to CRC error
 259:SD_routines.c ****   SD_CS_DEASSERT;              //AAA='110'-data rejected due to write error
 707               		.loc 1 259 0
 708 02f8 C49A      		sbi 0x18,4
 260:SD_routines.c ****   return response;
 709               		.loc 1 260 0
 710 02fa 00C0      		rjmp .L54
 711               	.L57:
 257:SD_routines.c **** if( (response & 0x1f) != 0x05) //response= 0xXXX0AAA1 ; AAA='010' - data accepted
 712               		.loc 1 257 0
 713 02fc C0E0      		ldi r28,0
 714 02fe D0E0      		ldi r29,0
 715               	.LVL100:
 716               	.L59:
 261:SD_routines.c **** }
 262:SD_routines.c **** 
 263:SD_routines.c **** while(!SPI_receive()) //wait for SD card to complete writing and get idle
 717               		.loc 1 263 0 discriminator 1
 718 0300 0E94 0000 		call SPI_receive
 719               	.LVL101:
 720 0304 8111      		cpse r24,__zero_reg__
 721 0306 00C0      		rjmp .L66
 264:SD_routines.c **** if(retry++ > 0xfffe){SD_CS_DEASSERT; return 1;}
 722               		.loc 1 264 0
 723 0308 2196      		adiw r28,1
 724               	.LVL102:
 725 030a 01F4      		brne .L59
 726 030c 00C0      		rjmp .L65
 727               	.L66:
 265:SD_routines.c **** 
 266:SD_routines.c **** SD_CS_DEASSERT;
 728               		.loc 1 266 0
 729 030e C49A      		sbi 0x18,4
 267:SD_routines.c **** SPI_transmit(0xff);   //just spend 8 clock cycle delay before reasserting the CS line
 730               		.loc 1 267 0
 731 0310 8FEF      		ldi r24,lo8(-1)
 732 0312 0E94 0000 		call SPI_transmit
 733               	.LVL103:
 268:SD_routines.c **** SD_CS_ASSERT;         //re-asserting the CS line to verify if card is still busy
 734               		.loc 1 268 0
 735 0316 C498      		cbi 0x18,4
 269:SD_routines.c **** 
 270:SD_routines.c **** while(!SPI_receive()) //wait for SD card to complete writing and get idle
 736               		.loc 1 270 0
 737 0318 00C0      		rjmp .L61
 738               	.LVL104:
 739               	.L65:
 271:SD_routines.c ****    if(retry++ > 0xfffe){SD_CS_DEASSERT; return 1;}
 740               		.loc 1 271 0 discriminator 1
 741 031a C49A      		sbi 0x18,4
 742 031c 81E0      		ldi r24,lo8(1)
 743 031e 00C0      		rjmp .L54
 744               	.LVL105:
 745               	.L63:
 746               		.loc 1 271 0 is_stmt 0
 747 0320 CE01      		movw r24,r28
 748 0322 0196      		adiw r24,1
 749               	.LVL106:
 750 0324 2196      		adiw r28,1
 751 0326 01F0      		breq .L65
 752 0328 EC01      		movw r28,r24
 753               	.LVL107:
 754               	.L61:
 270:SD_routines.c **** while(!SPI_receive()) //wait for SD card to complete writing and get idle
 755               		.loc 1 270 0 is_stmt 1 discriminator 1
 756 032a 0E94 0000 		call SPI_receive
 757               	.LVL108:
 758 032e 8823      		tst r24
 759 0330 01F0      		breq .L63
 272:SD_routines.c **** SD_CS_DEASSERT;
 760               		.loc 1 272 0
 761 0332 C49A      		sbi 0x18,4
 273:SD_routines.c **** 
 274:SD_routines.c **** return 0;
 762               		.loc 1 274 0
 763 0334 80E0      		ldi r24,0
 764               	.LVL109:
 765               	.L54:
 766               	/* epilogue start */
 275:SD_routines.c **** }
 767               		.loc 1 275 0
 768 0336 DF91      		pop r29
 769 0338 CF91      		pop r28
 770 033a 0895      		ret
 771               		.cfi_endproc
 772               	.LFE5:
 774               		.comm	buffer,512,1
 775               		.comm	cardType,1,1
 776               		.comm	SDHC_flag,1,1
 777               		.comm	totalBlocks,4,1
 778               		.comm	startBlock,4,1
 779               	.Letext0:
 780               		.file 2 "SD_routines.h"
 781               		.file 3 "/usr/lib/avr/include/stdint.h"
 782               		.file 4 "SPI_routines.h"
 783               		.file 5 "UART_routines.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 SD_routines.c
     /tmp/cctCUMsU.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cctCUMsU.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cctCUMsU.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cctCUMsU.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cctCUMsU.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cctCUMsU.s:12     .text:0000000000000000 SD_sendCommand
                            *COM*:0000000000000001 SDHC_flag
     /tmp/cctCUMsU.s:205    .text:00000000000000dc SD_init
                            *COM*:0000000000000001 cardType
     /tmp/cctCUMsU.s:432    .text:00000000000001de SD_erase
     /tmp/cctCUMsU.s:544    .text:0000000000000250 SD_readSingleBlock
                            *COM*:0000000000000200 buffer
     /tmp/cctCUMsU.s:638    .text:00000000000002ac SD_writeSingleBlock
                            *COM*:0000000000000004 totalBlocks
                            *COM*:0000000000000004 startBlock

UNDEFINED SYMBOLS
SPI_transmit
SPI_receive
transmitByte
__do_clear_bss
